
JuliaSetVisualizer_Linux.elf:     file format elf32-littlenios2
JuliaSetVisualizer_Linux.elf
architecture: nios2:r1, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x00100224

Program Header:
    LOAD off    0x00001000 vaddr 0x00010000 paddr 0x00010000 align 2**12
         filesz 0x00001474 memsz 0x0000171c flags rw-
    LOAD off    0x00003000 vaddr 0x00100000 paddr 0x00100000 align 2**12
         filesz 0x00000000 memsz 0x00000000 flags r-x
    LOAD off    0x00003020 vaddr 0x00100020 paddr 0x00100020 align 2**12
         filesz 0x00006bd4 memsz 0x00006bd4 flags r-x

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .entry        00000000  00100000  00100000  00003000  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .exceptions   00000204  00100020  00100020  00003020  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .text         00006704  00100224  00100224  00003224  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .rodata       000002cc  00106928  00106928  00009928  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .rwdata       00001474  00010000  00010000  00001000  2**2
                  CONTENTS, ALLOC, LOAD, DATA, SMALL_DATA
  5 .bss          000002a8  00011474  00011474  00002474  2**2
                  ALLOC, SMALL_DATA
  6 .onchip_memory2_1 00000000  0001171c  0001171c  00009bf4  2**0
                  CONTENTS
  7 .onchip_flash_0_data 00000000  00106bf4  00106bf4  00009bf4  2**0
                  CONTENTS
  8 .comment      0000002c  00000000  00000000  00009bf4  2**0
                  CONTENTS, READONLY
  9 .debug_aranges 00000760  00000000  00000000  00009c20  2**3
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_info   000226a8  00000000  00000000  0000a380  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_abbrev 00007237  00000000  00000000  0002ca28  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_line   00008656  00000000  00000000  00033c5f  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_frame  0000157c  00000000  00000000  0003c2b8  2**2
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_str    000032bf  00000000  00000000  0003d834  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_loc    00001aa3  00000000  00000000  00040af3  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_alt_sim_info 00000040  00000000  00000000  00042598  2**2
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_ranges 00000320  00000000  00000000  000425d8  2**3
                  CONTENTS, READONLY, DEBUGGING
 18 .thread_model 00000003  00000000  00000000  00044e86  2**0
                  CONTENTS, READONLY
 19 .cpu          0000000c  00000000  00000000  00044e89  2**0
                  CONTENTS, READONLY
 20 .qsys         00000001  00000000  00000000  00044e95  2**0
                  CONTENTS, READONLY
 21 .simulation_enabled 00000001  00000000  00000000  00044e96  2**0
                  CONTENTS, READONLY
 22 .sysid_hash   00000004  00000000  00000000  00044e97  2**0
                  CONTENTS, READONLY
 23 .sysid_base   00000004  00000000  00000000  00044e9b  2**0
                  CONTENTS, READONLY
 24 .sysid_time   00000004  00000000  00000000  00044e9f  2**0
                  CONTENTS, READONLY
 25 .stderr_dev   0000000b  00000000  00000000  00044ea3  2**0
                  CONTENTS, READONLY
 26 .stdin_dev    0000000b  00000000  00000000  00044eae  2**0
                  CONTENTS, READONLY
 27 .stdout_dev   0000000b  00000000  00000000  00044eb9  2**0
                  CONTENTS, READONLY
 28 .sopc_system_name 00000003  00000000  00000000  00044ec4  2**0
                  CONTENTS, READONLY
 29 .quartus_project_dir 00000034  00000000  00000000  00044ec7  2**0
                  CONTENTS, READONLY
 30 .jdi          00004b48  00000000  00000000  00044efb  2**0
                  CONTENTS, READONLY
 31 .sopcinfo     000a162d  00000000  00000000  00049a43  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
00100000 l    d  .entry	00000000 .entry
00100020 l    d  .exceptions	00000000 .exceptions
00100224 l    d  .text	00000000 .text
00106928 l    d  .rodata	00000000 .rodata
00010000 l    d  .rwdata	00000000 .rwdata
00011474 l    d  .bss	00000000 .bss
0001171c l    d  .onchip_memory2_1	00000000 .onchip_memory2_1
00106bf4 l    d  .onchip_flash_0_data	00000000 .onchip_flash_0_data
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_alt_sim_info	00000000 .debug_alt_sim_info
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    df *ABS*	00000000 ../JuliaSetVisualizer_Linux_bsp//obj/HAL/src/crt0.o
00100258 l       .text	00000000 alt_after_alt_main
00000000 l    df *ABS*	00000000 alt_irq_handler.c
00000000 l    df *ABS*	00000000 alt_instruction_exception_entry.c
00000000 l    df *ABS*	00000000 main.c
0001141c l     O .rwdata	00000004 vga_ctrl
00011420 l     O .rwdata	00000001 addr
00000000 l    df *ABS*	00000000 HID.c
00000000 l    df *ABS*	00000000 MAX3421E.c
00000000 l    df *ABS*	00000000 transfer.c
00011484 l     O .bss	00000004 usb_delay.2681
00011488 l     O .bss	00000001 tmp_addr.2682
00000000 l    df *ABS*	00000000 lib2-divmod.c
00000000 l    df *ABS*	00000000 lib2-mul.c
00000000 l    df *ABS*	00000000 memcpy.c
00000000 l    df *ABS*	00000000 printf.c
00000000 l    df *ABS*	00000000 putchar.c
00000000 l    df *ABS*	00000000 puts.c
00000000 l    df *ABS*	00000000 strlen.c
00000000 l    df *ABS*	00000000 vfprintf.c
0010303c l     F .text	0000006c print_repeat
00000000 l    df *ABS*	00000000 fvwrite_small_dev.c
00000000 l    df *ABS*	00000000 impure.c
00010030 l     O .rwdata	000000e4 impure_data
00000000 l    df *ABS*	00000000 putc.c
00000000 l    df *ABS*	00000000 writer.c
00000000 l    df *ABS*	00000000 int_errno.c
00000000 l    df *ABS*	00000000 alt_main.c
00000000 l    df *ABS*	00000000 alt_tick.c
00000000 l    df *ABS*	00000000 alt_usleep.c
00000000 l    df *ABS*	00000000 alt_write.c
001039b4 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_sys_init.c
00103af4 l     F .text	00000034 alt_dev_reg
00010114 l     O .rwdata	00001060 jtag_uart_0
00011174 l     O .rwdata	00000100 onchip_flash_0
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_fd.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_init.c
00103df4 l     F .text	00000204 altera_avalon_jtag_uart_irq
00103ff8 l     F .text	000000a0 altera_avalon_jtag_uart_timeout
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_ioctl.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_read.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_write.c
00000000 l    df *ABS*	00000000 altera_avalon_spi.c
00000000 l    df *ABS*	00000000 altera_avalon_timer_sc.c
00104830 l     F .text	00000078 alt_avalon_timer_sc_irq
00000000 l    df *ABS*	00000000 altera_onchip_flash.c
00104924 l     F .text	00000034 alt_flash_device_register
00000000 l    df *ABS*	00000000 alt_alarm_start.c
00000000 l    df *ABS*	00000000 alt_busy_sleep.c
00000000 l    df *ABS*	00000000 alt_close.c
00105aa8 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_dcache_flush.c
00000000 l    df *ABS*	00000000 alt_dev.c
00105be8 l     F .text	0000002c alt_dev_null_write
00000000 l    df *ABS*	00000000 alt_dev_llist_insert.c
00105c14 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_errno.c
00000000 l    df *ABS*	00000000 alt_flash_dev.c
00000000 l    df *ABS*	00000000 alt_iic.c
00000000 l    df *ABS*	00000000 alt_iic_isr_register.c
00000000 l    df *ABS*	00000000 alt_io_redirect.c
00106044 l     F .text	000000d4 alt_open_fd
00000000 l    df *ABS*	00000000 alt_irq_vars.c
00000000 l    df *ABS*	00000000 alt_open.c
00106194 l     F .text	0000003c alt_get_errno
001061d0 l     F .text	000000dc alt_file_locked
00000000 l    df *ABS*	00000000 alt_release_fd.c
00000000 l    df *ABS*	00000000 altera_nios2_gen2_irq.c
00000000 l    df *ABS*	00000000 alt_find_dev.c
00000000 l    df *ABS*	00000000 alt_find_file.c
00000000 l    df *ABS*	00000000 alt_get_fd.c
00000000 l    df *ABS*	00000000 exit.c
00000000 l    df *ABS*	00000000 memcmp.c
00000000 l    df *ABS*	00000000 __call_atexit.c
00000000 l    df *ABS*	00000000 alt_exit.c
000114a8 g     O .bss	00000004 alt_instruction_exception_handler
00102f70 g     F .text	0000001c putchar
00103774 g     F .text	0000006c alt_main
0001142c g     O .rwdata	00000008 ctrl_xfers
00100730 g     F .text	00000050 textVGAClr
00102f8c g     F .text	00000084 _puts_r
0001161c g     O .bss	00000100 alt_irq
00102498 g     F .text	00000630 USB_Task
00102f20 g     F .text	00000048 printf
00101578 g     F .text	00000084 kbdPoll
0010025c g     F .text	000001e8 GetDriverandReport
001016dc g     F .text	000000d0 MAXreg_wr
00010000 g     O .rwdata	00000030 ClientDriverTable
0010647c g     F .text	00000024 altera_nios2_gen2_irq_init
00102ac8 g     F .text	0000002c MSDProbe
00100000 g     F .entry	00000000 __reset
00101f9c g     F .text	000000ec XferCtrlData
000114ac g     O .bss	00000010 hid_ep
0001148c g     O .bss	00000004 errno
00011494 g     O .bss	00000004 alt_argv
0001941c g       *ABS*	00000000 _gp
00103984 g     F .text	00000030 usleep
00101888 g     F .text	000000bc MAXreg_rd
00105790 g     F .text	00000094 alt_onchip_flash_poll_for_status_write_passed
0001129c g     O .rwdata	00000180 alt_fd_list
001014bc g     F .text	00000038 HID_init
00102f68 g     F .text	00000008 _putchar_r
001064a0 g     F .text	00000090 alt_find_dev
00102ebc g     F .text	00000028 memcpy
00100000 g       *ABS*	00000000 __alt_mem_onchip_flash_0_data
00106118 g     F .text	0000007c alt_io_redirect
00011428 g     O .rwdata	00000004 SPI_MASTER_BASE
00103010 g     F .text	00000010 puts
001066f0 g     F .text	00000098 alt_exception_cause_generated_bad_addr
001041f4 g     F .text	0000021c altera_avalon_jtag_uart_read
00102ee4 g     F .text	0000003c _printf_r
00102dd4 g     F .text	00000064 .hidden __udivsi3
001056fc g     F .text	00000094 alt_onchip_flash_poll_for_status_erase_passed
00011448 g     O .rwdata	00000008 altera_onchip_flash_list
00011434 g     O .rwdata	00000001 usb_task_state
00101c58 g     F .text	00000094 MAX3421E_init
00100700 g     F .text	00000030 setKeycode
00105bc0 g     F .text	00000028 alt_dcache_flush
00104ac0 g     F .text	00000168 alt_onchip_flash_erase_block
00011460 g     O .rwdata	00000004 alt_max_fd
00011438 g     O .rwdata	00000004 _global_impure_ptr
0001171c g       *ABS*	00000000 __bss_end
00105f60 g     F .text	000000e4 alt_iic_isr_register
0010387c g     F .text	00000108 alt_tick
00105f14 g     F .text	0000004c alt_ic_irq_enabled
001037e0 g     F .text	0000009c alt_alarm_stop
000114a4 g     O .bss	00000004 alt_irq_active
00102b98 g     F .text	0000002c DummyProbe
001000fc g     F .exceptions	000000c8 alt_irq_handler
00011274 g     O .rwdata	00000028 alt_dev_null
001014f4 g     F .text	00000084 mousePoll
00101aac g     F .text	00000024 Vbus_power
00011458 g     O .rwdata	00000008 alt_dev_list
001039f0 g     F .text	00000104 write
001036d0 g     F .text	00000054 _putc_r
00011489 g     O .bss	00000001 usb_error
00102e38 g     F .text	0000005c .hidden __umodsi3
0001171c g       *ABS*	00000000 end
00103d34 g     F .text	000000c0 altera_avalon_jtag_uart_init
001001c4 g     F .exceptions	00000060 alt_instruction_exception_entry
00102108 g     F .text	00000180 XferDispatchPkt
00018000 g       *ABS*	00000000 __alt_stack_pointer
001048a8 g     F .text	0000007c alt_avalon_timer_sc_init
00104410 g     F .text	00000224 altera_avalon_jtag_uart_write
001030a8 g     F .text	00000518 ___vfprintf_internal_r
00101e14 g     F .text	00000034 MaxGpxHandler
00104a24 g     F .text	0000009c alt_onchip_flash_get_info
001067d8 g     F .text	0000011c __call_exitprocs
00100224 g     F .text	00000038 _start
0001149c g     O .bss	00000004 _alt_tick_rate
00101944 g     F .text	000000d0 MAXbytes_rd
00104634 g     F .text	000001fc alt_avalon_spi_command
000114a0 g     O .bss	00000004 _alt_nticks
00103b60 g     F .text	00000070 alt_sys_init
000115d4 g     O .bss	00000048 devtable
001010d8 g     F .text	000003e4 HIDKProbe
000114bc g     O .bss	00000018 msd_ep
00011424 g     O .rwdata	00000004 BTN_PIO
00104098 g     F .text	00000068 altera_avalon_jtag_uart_close
00102410 g     F .text	00000088 USB_init
000114d4 g     O .bss	00000100 bigbuf
00102e94 g     F .text	00000028 .hidden __mulsi3
00010000 g       *ABS*	00000000 __alt_mem_onchip_memory2_1
00011480 g     O .bss	00000001 last_usb_task_state
00011478 g     O .bss	00000008 dev0ep
00100480 g     F .text	00000040 clearLED
00103bd0 g     F .text	00000060 altera_avalon_jtag_uart_read_fd
00106638 g     F .text	000000b8 alt_get_fd
00105950 g     F .text	00000158 alt_busy_sleep
00102af4 g     F .text	0000003c MSDEventHandler
001067a8 g     F .text	00000030 memcmp
00103c90 g     F .text	00000050 altera_avalon_jtag_uart_close_fd
0001171c g       *ABS*	00000000 __alt_stack_base
00103ce0 g     F .text	00000054 altera_avalon_jtag_uart_ioctl_fd
00104958 g     F .text	000000cc alt_onchip_flash_read
00102b5c g     F .text	0000003c CDCEventHandler
00102bc4 g     F .text	0000003c DummyEventHandler
00106530 g     F .text	00000108 alt_find_file
00105c50 g     F .text	000000a4 alt_dev_llist_insert
00011468 g     O .rwdata	00000008 alt_flash_dev_list
001035d8 g     F .text	000000a8 __sfvwrite_small_dev
00011474 g       *ABS*	00000000 __bss_start
00101ad0 g     F .text	00000188 MAX_busprobe
00011474 g     O .bss	00000002 hid_device
00100780 g     F .text	00000574 main
00101cec g     F .text	0000005c MAX3421E_Task
00011498 g     O .bss	00000004 alt_envp
00103c30 g     F .text	00000060 altera_avalon_jtag_uart_write_fd
00102c58 g     F .text	00000084 ConvUTF8ToStr
00011464 g     O .rwdata	00000004 alt_errno
0010566c g     F .text	00000090 alt_onchip_flash_poll_for_status_to_go_idle
00103680 g     F .text	00000050 putc
00102cdc g     F .text	00000080 .hidden __divsi3
00102288 g     F .text	00000188 XferInTransfer
001005d0 g     F .text	00000130 printSignedHex1
001051cc g     F .text	000004a0 altera_onchip_flash_init
00102c20 g     F .text	00000038 GetDevtable
00102088 g     F .text	00000080 XferCtrlND
00101a14 g     F .text	00000098 MAX3421E_reset
00103b28 g     F .text	00000038 alt_irq_init
0010640c g     F .text	00000070 alt_release_fd
00103724 g     F .text	00000050 _write_r
0001143c g     O .rwdata	00000004 _impure_ptr
00011490 g     O .bss	00000004 alt_argc
001017ac g     F .text	000000dc MAXbytes_wr
00100020 g       .exceptions	00000000 alt_irq_entry
00011450 g     O .rwdata	00000008 alt_fs_list
00104c28 g     F .text	000002d8 alt_onchip_flash_write_block
00102b30 g     F .text	0000002c CDCProbe
00100444 g     F .text	0000003c setLED
00102c00 g     F .text	00000020 GetUsbTaskState
00105db0 g     F .text	00000050 alt_ic_isr_register
00106964 g     O .rodata	00000010 devclasses
00011474 g       *ABS*	00000000 _edata
00101638 g     F .text	0000003c HIDKEventHandler
00104f00 g     F .text	000002cc alt_onchip_flash_write
0001171c g       *ABS*	00000000 _end
00105cf4 g     F .text	00000068 alt_flash_open_dev
00101d48 g     F .text	000000cc MaxIntHandler
00104100 g     F .text	000000f4 altera_avalon_jtag_uart_ioctl
00101674 g     F .text	00000040 SPI_init
00105e88 g     F .text	0000008c alt_ic_irq_disable
00106788 g     F .text	00000020 exit
00105d5c g     F .text	00000054 alt_flash_close_dev
00102d5c g     F .text	00000078 .hidden __modsi3
00018000 g       *ABS*	00000000 __alt_data_end
00100020 g     F .exceptions	00000000 alt_exception
001015fc g     F .text	0000003c HIDMEventHandler
001068f4 g     F .text	00000034 _exit
00105824 g     F .text	0000012c alt_alarm_start
001004c0 g     F .text	00000110 printSignedHex0
00103020 g     F .text	0000001c strlen
001062ac g     F .text	00000160 open
00011470 g     O .rwdata	00000004 alt_priority_mask
00105e00 g     F .text	00000088 alt_ic_irq_enable
001035c0 g     F .text	00000018 __vfprintf_internal
00100cf4 g     F .text	000003e4 HIDMProbe
001016b4 g     F .text	00000028 SPI_wr
00011440 g     O .rwdata	00000008 alt_alarm_list
00105ae4 g     F .text	000000dc close
00101e48 g     F .text	00000154 XferCtrlReq



Disassembly of section .exceptions:

00100020 <alt_exception>:

#else /* ALT_EXCEPTION_STACK disabled */
        /* 
         * Reserve space on normal stack for registers about to be pushed.
         */
        addi  sp, sp, -76
  100020:	deffed04 	addi	sp,sp,-76
         * documentation for details).
         *
         * Leave a gap in the stack frame at 4(sp) for the muldiv handler to
         * store zero into.
         */
        stw   ra,  0(sp)
  100024:	dfc00015 	stw	ra,0(sp)
        stw   r1,   8(sp)
  100028:	d8400215 	stw	at,8(sp)
        stw   r2,  12(sp)
  10002c:	d8800315 	stw	r2,12(sp)
        stw   r3,  16(sp)
  100030:	d8c00415 	stw	r3,16(sp)
        stw   r4,  20(sp)
  100034:	d9000515 	stw	r4,20(sp)
        stw   r5,  24(sp)
  100038:	d9400615 	stw	r5,24(sp)
        stw   r6,  28(sp)
  10003c:	d9800715 	stw	r6,28(sp)
        stw   r7,  32(sp)
  100040:	d9c00815 	stw	r7,32(sp)
        rdctl r5, estatus   /* Read early to avoid usage stall */
  100044:	000b307a 	rdctl	r5,estatus
        stw   r8,  36(sp)
  100048:	da000915 	stw	r8,36(sp)
        stw   r9,  40(sp)
  10004c:	da400a15 	stw	r9,40(sp)
        stw   r10, 44(sp)
  100050:	da800b15 	stw	r10,44(sp)
        stw   r11, 48(sp)
  100054:	dac00c15 	stw	r11,48(sp)
        stw   r12, 52(sp)
  100058:	db000d15 	stw	r12,52(sp)
        stw   r13, 56(sp)
  10005c:	db400e15 	stw	r13,56(sp)
        stw   r14, 60(sp)
  100060:	db800f15 	stw	r14,60(sp)
        stw   r15, 64(sp)
  100064:	dbc01015 	stw	r15,64(sp)
        /*
         * ea-4 contains the address of the instruction being executed
         * when the exception occured. For interrupt exceptions, we will
         * will be re-issue the isntruction. Store it in 72(sp)
         */
        stw   r5,  68(sp)  /* estatus */
  100068:	d9401115 	stw	r5,68(sp)
        addi  r15, ea, -4  /* instruction that caused exception */
  10006c:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
  100070:	dbc01215 	stw	r15,72(sp)
#else
        /*
         * Test to see if the exception was a software exception or caused 
         * by an external interrupt, and vector accordingly.
         */
        rdctl r4, ipending
  100074:	0009313a 	rdctl	r4,ipending
        andi  r2, r5, 1
  100078:	2880004c 	andi	r2,r5,1
        beq   r2, zero, .Lnot_irq
  10007c:	10000326 	beq	r2,zero,10008c <alt_exception+0x6c>
        beq   r4, zero, .Lnot_irq
  100080:	20000226 	beq	r4,zero,10008c <alt_exception+0x6c>
        /*
         * Now that all necessary registers have been preserved, call 
         * alt_irq_handler() to process the interrupts.
         */

        call alt_irq_handler
  100084:	01000fc0 	call	1000fc <alt_irq_handler>

        .section .exceptions.irqreturn, "xa"

        br    .Lexception_exit
  100088:	00000706 	br	1000a8 <alt_exception+0x88>
         * upon completion, so we write ea (address of instruction *after*
         * the one where the exception occured) into 72(sp). The actual
         * instruction that caused the exception is written in r2, which these
         * handlers will utilize.
         */
        stw ea, 72(sp) /* EA is PC+4 so will skip over instruction causing exception */
  10008c:	df401215 	stw	ea,72(sp)
.Lunknown_16bit:
        addi.n r4, r4, 2 /* Need PC+2 to skip over instruction causing exception */
        stw r4, 72(sp)

#else /* CDX is not Enabled and all instructions are 32bits */
        ldw r2, -4(ea) /* Instruction value that caused exception */
  100090:	e8bfff17 	ldw	r2,-4(ea)
         * debugger is present) or go into an infinite loop since the
         * handling behavior is undefined; in that case we will not return here.
         */

        /* Load exception-causing address as first argument (r4) */
        addi   r4, ea, -4
  100094:	e93fff04 	addi	r4,ea,-4

        /* Call the instruction-exception entry */
        call   alt_instruction_exception_entry
  100098:	01001c40 	call	1001c4 <alt_instruction_exception_entry>
         * instruction
         *
         * Return code was 0: Skip. The instruction after the exception is
         * already stored in 72(sp).
         */
        bne   r2, r0, .Lexception_exit
  10009c:	1000021e 	bne	r2,zero,1000a8 <alt_exception+0x88>

        /*
         * Otherwise, modify 72(sp) to re-issue the instruction that caused the
         * exception.
         */
        addi  r15, ea, -4  /* instruction that caused exception */
  1000a0:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
  1000a4:	dbc01215 	stw	r15,72(sp)
        /* 
         * Restore the saved registers, so that all general purpose registers 
         * have been restored to their state at the time the interrupt occured.
         */

        ldw   r5,  68(sp)
  1000a8:	d9401117 	ldw	r5,68(sp)
        ldw   ea,  72(sp)  /* This becomes the PC once eret is executed */
  1000ac:	df401217 	ldw	ea,72(sp)
        ldw   ra,   0(sp)
  1000b0:	dfc00017 	ldw	ra,0(sp)

        wrctl estatus, r5
  1000b4:	2801707a 	wrctl	estatus,r5

        ldw   r1,   8(sp)
  1000b8:	d8400217 	ldw	at,8(sp)
        ldw   r2,  12(sp)
  1000bc:	d8800317 	ldw	r2,12(sp)
        ldw   r3,  16(sp)
  1000c0:	d8c00417 	ldw	r3,16(sp)
        ldw   r4,  20(sp)
  1000c4:	d9000517 	ldw	r4,20(sp)
        ldw   r5,  24(sp)
  1000c8:	d9400617 	ldw	r5,24(sp)
        ldw   r6,  28(sp)
  1000cc:	d9800717 	ldw	r6,28(sp)
        ldw   r7,  32(sp)
  1000d0:	d9c00817 	ldw	r7,32(sp)

#if defined(ALT_EXCEPTION_STACK) && defined(ALT_STACK_CHECK)
        ldw   et, %gprel(alt_exception_old_stack_limit)(gp)
#endif

        ldw   r8,  36(sp)
  1000d4:	da000917 	ldw	r8,36(sp)
        ldw   r9,  40(sp)
  1000d8:	da400a17 	ldw	r9,40(sp)
        ldw   r10, 44(sp)
  1000dc:	da800b17 	ldw	r10,44(sp)
        ldw   r11, 48(sp)
  1000e0:	dac00c17 	ldw	r11,48(sp)
        ldw   r12, 52(sp)
  1000e4:	db000d17 	ldw	r12,52(sp)
        ldw   r13, 56(sp)
  1000e8:	db400e17 	ldw	r13,56(sp)
        ldw   r14, 60(sp)
  1000ec:	db800f17 	ldw	r14,60(sp)
        ldw   r15, 64(sp)
  1000f0:	dbc01017 	ldw	r15,64(sp)
        stw   et, %gprel(alt_stack_limit_value)(gp)
        stw   zero, %gprel(alt_exception_old_stack_limit)(gp)
#endif /* ALT_STACK_CHECK */
        ldw   sp,  76(sp)
#else /* ALT_EXCEPTION_STACK disabled */
        addi  sp, sp, 76
  1000f4:	dec01304 	addi	sp,sp,76

        /*
         * Return to the interrupted instruction.
         */

        eret
  1000f8:	ef80083a 	eret

001000fc <alt_irq_handler>:
 * instruction is present if the macro ALT_CI_INTERRUPT_VECTOR defined.
 */

void alt_irq_handler (void) __attribute__ ((section (".exceptions")));
void alt_irq_handler (void)
{
  1000fc:	defff904 	addi	sp,sp,-28
  100100:	dfc00615 	stw	ra,24(sp)
  100104:	df000515 	stw	fp,20(sp)
  100108:	df000504 	addi	fp,sp,20
  
  /*
   * Notify the operating system that we are at interrupt level.
   */ 
  
  ALT_OS_INT_ENTER();
  10010c:	0001883a 	nop
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
  100110:	0005313a 	rdctl	r2,ipending
  100114:	e0bffc15 	stw	r2,-16(fp)

  return active;
  100118:	e0bffc17 	ldw	r2,-16(fp)
   * Consider the case where the high priority interupt is asserted during
   * the interrupt entry sequence for a lower priority interrupt to see why
   * this is the case.
   */

  active = alt_irq_pending ();
  10011c:	e0bfff15 	stw	r2,-4(fp)

  do
  {
    i = 0;
  100120:	e03ffd15 	stw	zero,-12(fp)
    mask = 1;
  100124:	00800044 	movi	r2,1
  100128:	e0bffe15 	stw	r2,-8(fp)
     * called to clear the interrupt condition.
     */

    do
    {
      if (active & mask)
  10012c:	e0ffff17 	ldw	r3,-4(fp)
  100130:	e0bffe17 	ldw	r2,-8(fp)
  100134:	1884703a 	and	r2,r3,r2
  100138:	10001126 	beq	r2,zero,100180 <alt_irq_handler+0x84>
      { 
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
        alt_irq[i].handler(alt_irq[i].context); 
  10013c:	e0bffd17 	ldw	r2,-12(fp)
  100140:	100690fa 	slli	r3,r2,3
  100144:	00800074 	movhi	r2,1
  100148:	1885883a 	add	r2,r3,r2
  10014c:	10c58717 	ldw	r3,5660(r2)
  100150:	e0bffd17 	ldw	r2,-12(fp)
  100154:	100890fa 	slli	r4,r2,3
  100158:	00800074 	movhi	r2,1
  10015c:	2085883a 	add	r2,r4,r2
  100160:	10858817 	ldw	r2,5664(r2)
  100164:	1009883a 	mov	r4,r2
  100168:	183ee83a 	callr	r3
#else
        alt_irq[i].handler(alt_irq[i].context, i); 
#endif
        break;
  10016c:	0001883a 	nop
  NIOS2_READ_IPENDING (active);
  100170:	0005313a 	rdctl	r2,ipending
  100174:	e0bffb15 	stw	r2,-20(fp)
  return active;
  100178:	e0bffb17 	ldw	r2,-20(fp)
  10017c:	00000706 	br	10019c <alt_irq_handler+0xa0>
      }
      mask <<= 1;
  100180:	e0bffe17 	ldw	r2,-8(fp)
  100184:	1085883a 	add	r2,r2,r2
  100188:	e0bffe15 	stw	r2,-8(fp)
      i++;
  10018c:	e0bffd17 	ldw	r2,-12(fp)
  100190:	10800044 	addi	r2,r2,1
  100194:	e0bffd15 	stw	r2,-12(fp)
      if (active & mask)
  100198:	003fe406 	br	10012c <alt_irq_handler+0x30>

    } while (1);

    active = alt_irq_pending ();
  10019c:	e0bfff15 	stw	r2,-4(fp)
    
  } while (active);
  1001a0:	e0bfff17 	ldw	r2,-4(fp)
  1001a4:	103fde1e 	bne	r2,zero,100120 <alt_irq_handler+0x24>

  /*
   * Notify the operating system that interrupt processing is complete.
   */ 

  ALT_OS_INT_EXIT();
  1001a8:	0001883a 	nop
}
  1001ac:	0001883a 	nop
  1001b0:	e037883a 	mov	sp,fp
  1001b4:	dfc00117 	ldw	ra,4(sp)
  1001b8:	df000017 	ldw	fp,0(sp)
  1001bc:	dec00204 	addi	sp,sp,8
  1001c0:	f800283a 	ret

001001c4 <alt_instruction_exception_entry>:
 * that handler if it has been registered. Absent a handler, it will
 * break break or hang as discussed below.
 */
int 
alt_instruction_exception_entry (alt_u32 exception_pc)
{
  1001c4:	defffb04 	addi	sp,sp,-20
  1001c8:	dfc00415 	stw	ra,16(sp)
  1001cc:	df000315 	stw	fp,12(sp)
  1001d0:	df000304 	addi	fp,sp,12
  1001d4:	e13ffd15 	stw	r4,-12(fp)
  cause = ( (cause & NIOS2_EXCEPTION_REG_CAUSE_MASK) >>
              NIOS2_EXCEPTION_REG_CAUSE_OFST );

  NIOS2_READ_BADADDR(badaddr);
#else
  cause = NIOS2_EXCEPTION_CAUSE_NOT_PRESENT;
  1001d8:	00bfffc4 	movi	r2,-1
  1001dc:	e0bfff15 	stw	r2,-4(fp)
  badaddr = 0;
  1001e0:	e03ffe15 	stw	zero,-8(fp)
#endif /* NIOS2_HAS_EXTRA_EXCEPTION_INFO */

  if(alt_instruction_exception_handler) {
  1001e4:	d0a02317 	ldw	r2,-32628(gp)
  1001e8:	10000726 	beq	r2,zero,100208 <alt_instruction_exception_entry+0x44>
     * Call handler. Its return value indicates whether the exception-causing
     * instruction should be re-issued. The code that called us,
     * alt_eceptions_entry.S, will look at this value and adjust the ea
     * register as necessary
     */
    return alt_instruction_exception_handler(cause, exception_pc, badaddr);
  1001ec:	d0a02317 	ldw	r2,-32628(gp)
  1001f0:	e0ffff17 	ldw	r3,-4(fp)
  1001f4:	e1bffe17 	ldw	r6,-8(fp)
  1001f8:	e17ffd17 	ldw	r5,-12(fp)
  1001fc:	1809883a 	mov	r4,r3
  100200:	103ee83a 	callr	r2
  100204:	00000206 	br	100210 <alt_instruction_exception_entry+0x4c>
   *    (a peripheral which negates its interrupt output before its
   *    interrupt handler has been executed will cause spurious interrupts)
   */
  else {
#ifdef NIOS2_HAS_DEBUG_STUB
    NIOS2_BREAK();
  100208:	003da03a 	break	0
      ;
#endif /* NIOS2_HAS_DEBUG_STUB */
  }

  /* We should not get here. Remove compiler warning. */
  return NIOS2_EXCEPTION_RETURN_REISSUE_INST;
  10020c:	0005883a 	mov	r2,zero
}
  100210:	e037883a 	mov	sp,fp
  100214:	dfc00117 	ldw	ra,4(sp)
  100218:	df000017 	ldw	fp,0(sp)
  10021c:	dec00204 	addi	sp,sp,8
  100220:	f800283a 	ret

Disassembly of section .text:

00100224 <_start>:

    /*
     * Now that the caches are initialized, set up the stack pointer and global pointer.
     * The values provided by the linker are assumed to be correctly aligned.
     */
    movhi sp, %hi(__alt_stack_pointer)
  100224:	06c00074 	movhi	sp,1
    ori sp, sp, %lo(__alt_stack_pointer)
  100228:	dee00014 	ori	sp,sp,32768
    movhi gp, %hi(_gp)
  10022c:	06800074 	movhi	gp,1
    ori gp, gp, %lo(_gp)
  100230:	d6a50714 	ori	gp,gp,37916
 */
#ifndef ALT_SIM_OPTIMIZE
    /* Log that the BSS is about to be cleared. */
    ALT_LOG_PUTS(alt_log_msg_bss)

    movhi r2, %hi(__bss_start)
  100234:	00800074 	movhi	r2,1
    ori r2, r2, %lo(__bss_start)
  100238:	10851d14 	ori	r2,r2,5236

    movhi r3, %hi(__bss_end)
  10023c:	00c00074 	movhi	r3,1
    ori r3, r3, %lo(__bss_end)
  100240:	18c5c714 	ori	r3,r3,5916

    beq r2, r3, 1f
  100244:	10c00326 	beq	r2,r3,100254 <_start+0x30>

0:
    stw zero, (r2)
  100248:	10000015 	stw	zero,0(r2)
    addi r2, r2, 4
  10024c:	10800104 	addi	r2,r2,4
    bltu r2, r3, 0b
  100250:	10fffd36 	bltu	r2,r3,100248 <_start+0x24>

    /* Log that alt_main is about to be called. */
    ALT_LOG_PUTS(alt_log_msg_alt_main)

    /* Call the C entry point. It should never return. */
    call alt_main
  100254:	01037740 	call	103774 <alt_main>

00100258 <alt_after_alt_main>:

    /* Wait in infinite loop in case alt_main does return. */
alt_after_alt_main:
    br alt_after_alt_main
  100258:	003fff06 	br	100258 <alt_after_alt_main>

0010025c <GetDriverandReport>:
static BYTE addr = 1; 				//hard-wired USB address
const char* const devclasses[] = { " Uninitialized", " HID Keyboard", " HID Mouse", " Mass storage" };

volatile unsigned int *BTN_PIO = (unsigned int*)0x00000050; //make a pointer to access the PIO block

BYTE GetDriverandReport() {
  10025c:	defff604 	addi	sp,sp,-40
  100260:	dfc00915 	stw	ra,36(sp)
  100264:	df000815 	stw	fp,32(sp)
  100268:	df000804 	addi	fp,sp,32
	BYTE i;
	BYTE rcode;
	BYTE device = 0xFF;
  10026c:	00bfffc4 	movi	r2,-1
  100270:	e0bfff85 	stb	r2,-2(fp)
	BYTE tmpbyte;

	DEV_RECORD* tpl_ptr;
	printf("Reached USB_STATE_RUNNING (0x40)\n");
  100274:	01000434 	movhi	r4,16
  100278:	211a5d04 	addi	r4,r4,26996
  10027c:	01030100 	call	103010 <puts>
	for (i = 1; i < USB_NUMDEVICES; i++) {
  100280:	00800044 	movi	r2,1
  100284:	e0bfffc5 	stb	r2,-1(fp)
  100288:	00001d06 	br	100300 <GetDriverandReport+0xa4>
		tpl_ptr = GetDevtable(i);
  10028c:	e0bfffc3 	ldbu	r2,-1(fp)
  100290:	1009883a 	mov	r4,r2
  100294:	0102c200 	call	102c20 <GetDevtable>
  100298:	e0bffe15 	stw	r2,-8(fp)
		if (tpl_ptr->epinfo != NULL) {
  10029c:	e0bffe17 	ldw	r2,-8(fp)
  1002a0:	10800017 	ldw	r2,0(r2)
  1002a4:	10001326 	beq	r2,zero,1002f4 <GetDriverandReport+0x98>
			printf("Device: %d", i);
  1002a8:	e0bfffc3 	ldbu	r2,-1(fp)
  1002ac:	100b883a 	mov	r5,r2
  1002b0:	01000434 	movhi	r4,16
  1002b4:	211a6604 	addi	r4,r4,27032
  1002b8:	0102f200 	call	102f20 <printf>
			printf("%s \n", devclasses[tpl_ptr->devclass]);
  1002bc:	e0bffe17 	ldw	r2,-8(fp)
  1002c0:	10800103 	ldbu	r2,4(r2)
  1002c4:	10803fcc 	andi	r2,r2,255
  1002c8:	100690ba 	slli	r3,r2,2
  1002cc:	00800434 	movhi	r2,16
  1002d0:	1885883a 	add	r2,r3,r2
  1002d4:	109a5917 	ldw	r2,26980(r2)
  1002d8:	100b883a 	mov	r5,r2
  1002dc:	01000434 	movhi	r4,16
  1002e0:	211a6904 	addi	r4,r4,27044
  1002e4:	0102f200 	call	102f20 <printf>
			device = tpl_ptr->devclass;
  1002e8:	e0bffe17 	ldw	r2,-8(fp)
  1002ec:	10800103 	ldbu	r2,4(r2)
  1002f0:	e0bfff85 	stb	r2,-2(fp)
	for (i = 1; i < USB_NUMDEVICES; i++) {
  1002f4:	e0bfffc3 	ldbu	r2,-1(fp)
  1002f8:	10800044 	addi	r2,r2,1
  1002fc:	e0bfffc5 	stb	r2,-1(fp)
  100300:	e0bfffc3 	ldbu	r2,-1(fp)
  100304:	10800230 	cmpltui	r2,r2,8
  100308:	103fe01e 	bne	r2,zero,10028c <GetDriverandReport+0x30>
		}
	}
	//Query rate and protocol
	rcode = XferGetIdle(addr, 0, hid_device.interface, 0, &tmpbyte);
  10030c:	d0a00103 	ldbu	r2,-32764(gp)
  100310:	11003fcc 	andi	r4,r2,255
  100314:	d0a01643 	ldbu	r2,-32679(gp)
  100318:	10803fcc 	andi	r2,r2,255
  10031c:	e0fffd84 	addi	r3,fp,-10
  100320:	d8c00415 	stw	r3,16(sp)
  100324:	00c00044 	movi	r3,1
  100328:	d8c00315 	stw	r3,12(sp)
  10032c:	d8800215 	stw	r2,8(sp)
  100330:	d8000115 	stw	zero,4(sp)
  100334:	d8000015 	stw	zero,0(sp)
  100338:	01c00084 	movi	r7,2
  10033c:	01802844 	movi	r6,161
  100340:	000b883a 	mov	r5,zero
  100344:	0101e480 	call	101e48 <XferCtrlReq>
  100348:	e0bffdc5 	stb	r2,-9(fp)
	if (rcode) {   //error handling
  10034c:	e0bffdc3 	ldbu	r2,-9(fp)
  100350:	10000926 	beq	r2,zero,100378 <GetDriverandReport+0x11c>
		printf("GetIdle Error. Error code: ");
  100354:	01000434 	movhi	r4,16
  100358:	211a6b04 	addi	r4,r4,27052
  10035c:	0102f200 	call	102f20 <printf>
		printf("%x \n", rcode);
  100360:	e0bffdc3 	ldbu	r2,-9(fp)
  100364:	100b883a 	mov	r5,r2
  100368:	01000434 	movhi	r4,16
  10036c:	211a7204 	addi	r4,r4,27080
  100370:	0102f200 	call	102f20 <printf>
  100374:	00000906 	br	10039c <GetDriverandReport+0x140>
	} else {
		printf("Update rate: ");
  100378:	01000434 	movhi	r4,16
  10037c:	211a7404 	addi	r4,r4,27088
  100380:	0102f200 	call	102f20 <printf>
		printf("%x \n", tmpbyte);
  100384:	e0bffd83 	ldbu	r2,-10(fp)
  100388:	10803fcc 	andi	r2,r2,255
  10038c:	100b883a 	mov	r5,r2
  100390:	01000434 	movhi	r4,16
  100394:	211a7204 	addi	r4,r4,27080
  100398:	0102f200 	call	102f20 <printf>
	}
	printf("Protocol: ");
  10039c:	01000434 	movhi	r4,16
  1003a0:	211a7804 	addi	r4,r4,27104
  1003a4:	0102f200 	call	102f20 <printf>
	rcode = XferGetProto(addr, 0, hid_device.interface, &tmpbyte);
  1003a8:	d0a00103 	ldbu	r2,-32764(gp)
  1003ac:	11003fcc 	andi	r4,r2,255
  1003b0:	d0a01643 	ldbu	r2,-32679(gp)
  1003b4:	10803fcc 	andi	r2,r2,255
  1003b8:	e0fffd84 	addi	r3,fp,-10
  1003bc:	d8c00415 	stw	r3,16(sp)
  1003c0:	00c00044 	movi	r3,1
  1003c4:	d8c00315 	stw	r3,12(sp)
  1003c8:	d8800215 	stw	r2,8(sp)
  1003cc:	d8000115 	stw	zero,4(sp)
  1003d0:	d8000015 	stw	zero,0(sp)
  1003d4:	01c000c4 	movi	r7,3
  1003d8:	01802844 	movi	r6,161
  1003dc:	000b883a 	mov	r5,zero
  1003e0:	0101e480 	call	101e48 <XferCtrlReq>
  1003e4:	e0bffdc5 	stb	r2,-9(fp)
	if (rcode) {   //error handling
  1003e8:	e0bffdc3 	ldbu	r2,-9(fp)
  1003ec:	10000926 	beq	r2,zero,100414 <GetDriverandReport+0x1b8>
		printf("GetProto Error. Error code ");
  1003f0:	01000434 	movhi	r4,16
  1003f4:	211a7b04 	addi	r4,r4,27116
  1003f8:	0102f200 	call	102f20 <printf>
		printf("%x \n", rcode);
  1003fc:	e0bffdc3 	ldbu	r2,-9(fp)
  100400:	100b883a 	mov	r5,r2
  100404:	01000434 	movhi	r4,16
  100408:	211a7204 	addi	r4,r4,27080
  10040c:	0102f200 	call	102f20 <printf>
  100410:	00000606 	br	10042c <GetDriverandReport+0x1d0>
	} else {
		printf("%d \n", tmpbyte);
  100414:	e0bffd83 	ldbu	r2,-10(fp)
  100418:	10803fcc 	andi	r2,r2,255
  10041c:	100b883a 	mov	r5,r2
  100420:	01000434 	movhi	r4,16
  100424:	211a8204 	addi	r4,r4,27144
  100428:	0102f200 	call	102f20 <printf>
	}
	return device;
  10042c:	e0bfff83 	ldbu	r2,-2(fp)
}
  100430:	e037883a 	mov	sp,fp
  100434:	dfc00117 	ldw	ra,4(sp)
  100438:	df000017 	ldw	fp,0(sp)
  10043c:	dec00204 	addi	sp,sp,8
  100440:	f800283a 	ret

00100444 <setLED>:

void setLED(int LED) {
  100444:	defffe04 	addi	sp,sp,-8
  100448:	df000115 	stw	fp,4(sp)
  10044c:	df000104 	addi	fp,sp,4
  100450:	e13fff15 	stw	r4,-4(fp)
	IOWR_ALTERA_AVALON_PIO_DATA(LEDS_PIO_BASE,
  100454:	00c06c37 	ldwio	r3,432(zero)
  100458:	01000044 	movi	r4,1
  10045c:	e0bfff17 	ldw	r2,-4(fp)
  100460:	2084983a 	sll	r2,r4,r2
  100464:	1884b03a 	or	r2,r3,r2
  100468:	00806c35 	stwio	r2,432(zero)
			(IORD_ALTERA_AVALON_PIO_DATA(LEDS_PIO_BASE) | (0x001 << LED)));
}
  10046c:	0001883a 	nop
  100470:	e037883a 	mov	sp,fp
  100474:	df000017 	ldw	fp,0(sp)
  100478:	dec00104 	addi	sp,sp,4
  10047c:	f800283a 	ret

00100480 <clearLED>:

void clearLED(int LED) {
  100480:	defffe04 	addi	sp,sp,-8
  100484:	df000115 	stw	fp,4(sp)
  100488:	df000104 	addi	fp,sp,4
  10048c:	e13fff15 	stw	r4,-4(fp)
	IOWR_ALTERA_AVALON_PIO_DATA(LEDS_PIO_BASE,
  100490:	00c06c37 	ldwio	r3,432(zero)
  100494:	01000044 	movi	r4,1
  100498:	e0bfff17 	ldw	r2,-4(fp)
  10049c:	2084983a 	sll	r2,r4,r2
  1004a0:	0084303a 	nor	r2,zero,r2
  1004a4:	1884703a 	and	r2,r3,r2
  1004a8:	00806c35 	stwio	r2,432(zero)
			(IORD_ALTERA_AVALON_PIO_DATA(LEDS_PIO_BASE) & ~(0x001 << LED)));

}
  1004ac:	0001883a 	nop
  1004b0:	e037883a 	mov	sp,fp
  1004b4:	df000017 	ldw	fp,0(sp)
  1004b8:	dec00104 	addi	sp,sp,4
  1004bc:	f800283a 	ret

001004c0 <printSignedHex0>:

void printSignedHex0(signed char value) {
  1004c0:	defffc04 	addi	sp,sp,-16
  1004c4:	dfc00315 	stw	ra,12(sp)
  1004c8:	df000215 	stw	fp,8(sp)
  1004cc:	df000204 	addi	fp,sp,8
  1004d0:	2005883a 	mov	r2,r4
  1004d4:	e0bffe05 	stb	r2,-8(fp)
	BYTE tens = 0;
  1004d8:	e03fffc5 	stb	zero,-1(fp)
	BYTE ones = 0;
  1004dc:	e03fff85 	stb	zero,-2(fp)
	WORD pio_val = IORD_ALTERA_AVALON_PIO_DATA(HEX_DIGITS_PIO_BASE);
  1004e0:	00807037 	ldwio	r2,448(zero)
  1004e4:	e0bfff0d 	sth	r2,-4(fp)
	if (value < 0) {
  1004e8:	e0bffe07 	ldb	r2,-8(fp)
  1004ec:	1000060e 	bge	r2,zero,100508 <printSignedHex0+0x48>
		setLED(11);
  1004f0:	010002c4 	movi	r4,11
  1004f4:	01004440 	call	100444 <setLED>
		value = -value;
  1004f8:	e0bffe03 	ldbu	r2,-8(fp)
  1004fc:	0085c83a 	sub	r2,zero,r2
  100500:	e0bffe05 	stb	r2,-8(fp)
  100504:	00000206 	br	100510 <printSignedHex0+0x50>
	} else {
		clearLED(11);
  100508:	010002c4 	movi	r4,11
  10050c:	01004800 	call	100480 <clearLED>
	}
	//handled hundreds
	if (value / 100)
  100510:	e0bffe03 	ldbu	r2,-8(fp)
  100514:	108018c4 	addi	r2,r2,99
  100518:	10803fcc 	andi	r2,r2,255
  10051c:	108031f0 	cmpltui	r2,r2,199
  100520:	1000031e 	bne	r2,zero,100530 <printSignedHex0+0x70>
		setLED(13);
  100524:	01000344 	movi	r4,13
  100528:	01004440 	call	100444 <setLED>
  10052c:	00000206 	br	100538 <printSignedHex0+0x78>
	else
		clearLED(13);
  100530:	01000344 	movi	r4,13
  100534:	01004800 	call	100480 <clearLED>

	value = value % 100;
  100538:	e0bffe07 	ldb	r2,-8(fp)
  10053c:	01401904 	movi	r5,100
  100540:	1009883a 	mov	r4,r2
  100544:	0102d5c0 	call	102d5c <__modsi3>
  100548:	e0bffe05 	stb	r2,-8(fp)
	tens = value / 10;
  10054c:	e0bffe07 	ldb	r2,-8(fp)
  100550:	01400284 	movi	r5,10
  100554:	1009883a 	mov	r4,r2
  100558:	0102cdc0 	call	102cdc <__divsi3>
  10055c:	e0bfffc5 	stb	r2,-1(fp)
	ones = value % 10;
  100560:	e0bffe07 	ldb	r2,-8(fp)
  100564:	01400284 	movi	r5,10
  100568:	1009883a 	mov	r4,r2
  10056c:	0102d5c0 	call	102d5c <__modsi3>
  100570:	e0bfff85 	stb	r2,-2(fp)

	pio_val &= 0x00FF;
  100574:	e0bfff0b 	ldhu	r2,-4(fp)
  100578:	10803fcc 	andi	r2,r2,255
  10057c:	e0bfff0d 	sth	r2,-4(fp)
	pio_val |= (tens << 12);
  100580:	e0bfffc3 	ldbu	r2,-1(fp)
  100584:	1004933a 	slli	r2,r2,12
  100588:	1007883a 	mov	r3,r2
  10058c:	e0bfff0b 	ldhu	r2,-4(fp)
  100590:	1884b03a 	or	r2,r3,r2
  100594:	e0bfff0d 	sth	r2,-4(fp)
	pio_val |= (ones << 8);
  100598:	e0bfff83 	ldbu	r2,-2(fp)
  10059c:	1004923a 	slli	r2,r2,8
  1005a0:	1007883a 	mov	r3,r2
  1005a4:	e0bfff0b 	ldhu	r2,-4(fp)
  1005a8:	1884b03a 	or	r2,r3,r2
  1005ac:	e0bfff0d 	sth	r2,-4(fp)

	IOWR_ALTERA_AVALON_PIO_DATA(HEX_DIGITS_PIO_BASE, pio_val);
  1005b0:	e0bfff0b 	ldhu	r2,-4(fp)
  1005b4:	00807035 	stwio	r2,448(zero)
}
  1005b8:	0001883a 	nop
  1005bc:	e037883a 	mov	sp,fp
  1005c0:	dfc00117 	ldw	ra,4(sp)
  1005c4:	df000017 	ldw	fp,0(sp)
  1005c8:	dec00204 	addi	sp,sp,8
  1005cc:	f800283a 	ret

001005d0 <printSignedHex1>:

void printSignedHex1(signed char value) {
  1005d0:	defffb04 	addi	sp,sp,-20
  1005d4:	dfc00415 	stw	ra,16(sp)
  1005d8:	df000315 	stw	fp,12(sp)
  1005dc:	df000304 	addi	fp,sp,12
  1005e0:	2005883a 	mov	r2,r4
  1005e4:	e0bffd05 	stb	r2,-12(fp)
	BYTE tens = 0;
  1005e8:	e03fffc5 	stb	zero,-1(fp)
	BYTE ones = 0;
  1005ec:	e03fff85 	stb	zero,-2(fp)
	DWORD pio_val = IORD_ALTERA_AVALON_PIO_DATA(HEX_DIGITS_PIO_BASE);
  1005f0:	00807037 	ldwio	r2,448(zero)
  1005f4:	e0bffe15 	stw	r2,-8(fp)
	if (value < 0) {
  1005f8:	e0bffd07 	ldb	r2,-12(fp)
  1005fc:	1000060e 	bge	r2,zero,100618 <printSignedHex1+0x48>
		setLED(10);
  100600:	01000284 	movi	r4,10
  100604:	01004440 	call	100444 <setLED>
		value = -value;
  100608:	e0bffd03 	ldbu	r2,-12(fp)
  10060c:	0085c83a 	sub	r2,zero,r2
  100610:	e0bffd05 	stb	r2,-12(fp)
  100614:	00000206 	br	100620 <printSignedHex1+0x50>
	} else {
		clearLED(10);
  100618:	01000284 	movi	r4,10
  10061c:	01004800 	call	100480 <clearLED>
	}
	//handled hundreds
	if (value / 100)
  100620:	e0bffd03 	ldbu	r2,-12(fp)
  100624:	108018c4 	addi	r2,r2,99
  100628:	10803fcc 	andi	r2,r2,255
  10062c:	108031f0 	cmpltui	r2,r2,199
  100630:	1000031e 	bne	r2,zero,100640 <printSignedHex1+0x70>
		setLED(12);
  100634:	01000304 	movi	r4,12
  100638:	01004440 	call	100444 <setLED>
  10063c:	00000206 	br	100648 <printSignedHex1+0x78>
	else
		clearLED(12);
  100640:	01000304 	movi	r4,12
  100644:	01004800 	call	100480 <clearLED>

	value = value % 100;
  100648:	e0bffd07 	ldb	r2,-12(fp)
  10064c:	01401904 	movi	r5,100
  100650:	1009883a 	mov	r4,r2
  100654:	0102d5c0 	call	102d5c <__modsi3>
  100658:	e0bffd05 	stb	r2,-12(fp)
	tens = value / 10;
  10065c:	e0bffd07 	ldb	r2,-12(fp)
  100660:	01400284 	movi	r5,10
  100664:	1009883a 	mov	r4,r2
  100668:	0102cdc0 	call	102cdc <__divsi3>
  10066c:	e0bfffc5 	stb	r2,-1(fp)
	ones = value % 10;
  100670:	e0bffd07 	ldb	r2,-12(fp)
  100674:	01400284 	movi	r5,10
  100678:	1009883a 	mov	r4,r2
  10067c:	0102d5c0 	call	102d5c <__modsi3>
  100680:	e0bfff85 	stb	r2,-2(fp)
	tens = value / 10;
  100684:	e0bffd07 	ldb	r2,-12(fp)
  100688:	01400284 	movi	r5,10
  10068c:	1009883a 	mov	r4,r2
  100690:	0102cdc0 	call	102cdc <__divsi3>
  100694:	e0bfffc5 	stb	r2,-1(fp)
	ones = value % 10;
  100698:	e0bffd07 	ldb	r2,-12(fp)
  10069c:	01400284 	movi	r5,10
  1006a0:	1009883a 	mov	r4,r2
  1006a4:	0102d5c0 	call	102d5c <__modsi3>
  1006a8:	e0bfff85 	stb	r2,-2(fp)

	pio_val &= 0xFF00;
  1006ac:	e0bffe17 	ldw	r2,-8(fp)
  1006b0:	10bfc00c 	andi	r2,r2,65280
  1006b4:	e0bffe15 	stw	r2,-8(fp)
	pio_val |= (tens << 4);
  1006b8:	e0bfffc3 	ldbu	r2,-1(fp)
  1006bc:	1004913a 	slli	r2,r2,4
  1006c0:	1007883a 	mov	r3,r2
  1006c4:	e0bffe17 	ldw	r2,-8(fp)
  1006c8:	10c4b03a 	or	r2,r2,r3
  1006cc:	e0bffe15 	stw	r2,-8(fp)
	pio_val |= (ones << 0);
  1006d0:	e0bfff83 	ldbu	r2,-2(fp)
  1006d4:	e0fffe17 	ldw	r3,-8(fp)
  1006d8:	1884b03a 	or	r2,r3,r2
  1006dc:	e0bffe15 	stw	r2,-8(fp)

	IOWR_ALTERA_AVALON_PIO_DATA(HEX_DIGITS_PIO_BASE, pio_val);
  1006e0:	e0bffe17 	ldw	r2,-8(fp)
  1006e4:	00807035 	stwio	r2,448(zero)
}
  1006e8:	0001883a 	nop
  1006ec:	e037883a 	mov	sp,fp
  1006f0:	dfc00117 	ldw	ra,4(sp)
  1006f4:	df000017 	ldw	fp,0(sp)
  1006f8:	dec00204 	addi	sp,sp,8
  1006fc:	f800283a 	ret

00100700 <setKeycode>:

void setKeycode(WORD keycode)
{
  100700:	defffe04 	addi	sp,sp,-8
  100704:	df000115 	stw	fp,4(sp)
  100708:	df000104 	addi	fp,sp,4
  10070c:	2005883a 	mov	r2,r4
  100710:	e0bfff0d 	sth	r2,-4(fp)
	IOWR_ALTERA_AVALON_PIO_DATA(KEYCODE_BASE, keycode);
  100714:	e0bfff0b 	ldhu	r2,-4(fp)
  100718:	00808035 	stwio	r2,512(zero)
}
  10071c:	0001883a 	nop
  100720:	e037883a 	mov	sp,fp
  100724:	df000017 	ldw	fp,0(sp)
  100728:	dec00104 	addi	sp,sp,4
  10072c:	f800283a 	ret

00100730 <textVGAClr>:



void textVGAClr()
{
  100730:	defffe04 	addi	sp,sp,-8
  100734:	df000115 	stw	fp,4(sp)
  100738:	df000104 	addi	fp,sp,4
	for (int i = 0; i<(ROWS*COLUMNS); i++)
  10073c:	e03fff15 	stw	zero,-4(fp)
  100740:	00000706 	br	100760 <textVGAClr+0x30>
	{
		vga_ctrl->VRAM[i] = 0x00;
  100744:	d0e00017 	ldw	r3,-32768(gp)
  100748:	e0bfff17 	ldw	r2,-4(fp)
  10074c:	1885883a 	add	r2,r3,r2
  100750:	10000005 	stb	zero,0(r2)
	for (int i = 0; i<(ROWS*COLUMNS); i++)
  100754:	e0bfff17 	ldw	r2,-4(fp)
  100758:	10800044 	addi	r2,r2,1
  10075c:	e0bfff15 	stw	r2,-4(fp)
  100760:	e0bfff17 	ldw	r2,-4(fp)
  100764:	10825810 	cmplti	r2,r2,2400
  100768:	103ff61e 	bne	r2,zero,100744 <textVGAClr+0x14>
	}
}
  10076c:	0001883a 	nop
  100770:	e037883a 	mov	sp,fp
  100774:	df000017 	ldw	fp,0(sp)
  100778:	dec00104 	addi	sp,sp,4
  10077c:	f800283a 	ret

00100780 <main>:

int main() {
  100780:	deffe604 	addi	sp,sp,-104
  100784:	dfc01915 	stw	ra,100(sp)
  100788:	df001815 	stw	fp,96(sp)
  10078c:	dc001715 	stw	r16,92(sp)
  100790:	df001804 	addi	fp,sp,96
	BYTE rcode;
	BOOT_MOUSE_REPORT buf;		//USB mouse report
	BOOT_KBD_REPORT kbdbuf;

	BYTE runningdebugflag = 0;//flag to dump out a bunch of information when we first get to USB_STATE_RUNNING
  100794:	e03ffec5 	stb	zero,-5(fp)
	BYTE errorflag = 0; //flag once we get an error device so we don't keep dumping out state info
  100798:	e03ffe85 	stb	zero,-6(fp)
	BYTE device;
	WORD keycode;
	WORD prev_keycode;


	printf("initializing MAX3421E...\n");
  10079c:	01000434 	movhi	r4,16
  1007a0:	211a8404 	addi	r4,r4,27152
  1007a4:	01030100 	call	103010 <puts>
	MAX3421E_init();
  1007a8:	0101c580 	call	101c58 <MAX3421E_init>
	printf("initializing USB...\n");
  1007ac:	01000434 	movhi	r4,16
  1007b0:	211a8b04 	addi	r4,r4,27180
  1007b4:	01030100 	call	103010 <puts>
	USB_init();
  1007b8:	01024100 	call	102410 <USB_init>

	char coord_prompt[] = "Enter fractal selection.";
  1007bc:	009b9144 	movi	r2,28229
  1007c0:	e0bfee8d 	sth	r2,-70(fp)
  1007c4:	00995d04 	movi	r2,25972
  1007c8:	e0bfef0d 	sth	r2,-68(fp)
  1007cc:	00881c84 	movi	r2,8306
  1007d0:	e0bfef8d 	sth	r2,-66(fp)
  1007d4:	009c9984 	movi	r2,29286
  1007d8:	e0bff00d 	sth	r2,-64(fp)
  1007dc:	0098d844 	movi	r2,25441
  1007e0:	e0bff08d 	sth	r2,-62(fp)
  1007e4:	00985d04 	movi	r2,24948
  1007e8:	e0bff10d 	sth	r2,-60(fp)
  1007ec:	00881b04 	movi	r2,8300
  1007f0:	e0bff18d 	sth	r2,-58(fp)
  1007f4:	00995cc4 	movi	r2,25971
  1007f8:	e0bff20d 	sth	r2,-56(fp)
  1007fc:	00995b04 	movi	r2,25964
  100800:	e0bff28d 	sth	r2,-54(fp)
  100804:	009d18c4 	movi	r2,29795
  100808:	e0bff30d 	sth	r2,-52(fp)
  10080c:	009bda44 	movi	r2,28521
  100810:	e0bff38d 	sth	r2,-50(fp)
  100814:	008b9b84 	movi	r2,11886
  100818:	e0bff40d 	sth	r2,-48(fp)
  10081c:	e03ff485 	stb	zero,-46(fp)
	char color_prompt[] = "Enter color selection.";
  100820:	e0ffe8c4 	addi	r3,fp,-93
  100824:	00800434 	movhi	r2,16
  100828:	109aa004 	addi	r2,r2,27264
  10082c:	010005c4 	movi	r4,23
  100830:	200d883a 	mov	r6,r4
  100834:	100b883a 	mov	r5,r2
  100838:	1809883a 	mov	r4,r3
  10083c:	0102ebc0 	call	102ebc <memcpy>

	IOWR_ALTERA_AVALON_PIO_DATA(REAL_VAL_BASE, 0xFFFFFFFF);
  100840:	00bfffc4 	movi	r2,-1
  100844:	00806035 	stwio	r2,384(zero)
	IOWR_ALTERA_AVALON_PIO_DATA(IMAG_VAL_BASE, 0xFFFFFFFF);
  100848:	00bfffc4 	movi	r2,-1
  10084c:	00800035 	stwio	r2,0(zero)
	
	while (1) {
		printf(".");
  100850:	01000b84 	movi	r4,46
  100854:	0102f700 	call	102f70 <putchar>
		MAX3421E_Task();
  100858:	0101cec0 	call	101cec <MAX3421E_Task>
		USB_Task();
  10085c:	01024980 	call	102498 <USB_Task>
		
		//usleep (500000);
		if (GetUsbTaskState() == USB_STATE_RUNNING) {
  100860:	0102c000 	call	102c00 <GetUsbTaskState>
  100864:	10803fcc 	andi	r2,r2,255
  100868:	10801018 	cmpnei	r2,r2,64
  10086c:	1000ff1e 	bne	r2,zero,100c6c <main+0x4ec>
			if (!runningdebugflag) {
  100870:	e0bffec3 	ldbu	r2,-5(fp)
  100874:	1000071e 	bne	r2,zero,100894 <main+0x114>
				runningdebugflag = 1;
  100878:	00800044 	movi	r2,1
  10087c:	e0bffec5 	stb	r2,-5(fp)
				setLED(9);
  100880:	01000244 	movi	r4,9
  100884:	01004440 	call	100444 <setLED>
				device = GetDriverandReport();
  100888:	010025c0 	call	10025c <GetDriverandReport>
  10088c:	e0bffe45 	stb	r2,-7(fp)
  100890:	003fef06 	br	100850 <main+0xd0>
			} else if (device == 1) {
  100894:	e0bffe43 	ldbu	r2,-7(fp)
  100898:	10800058 	cmpnei	r2,r2,1
  10089c:	103fec1e 	bne	r2,zero,100850 <main+0xd0>
				//run keyboard debug polling
				if (*BTN_PIO == 2){
  1008a0:	d0a00217 	ldw	r2,-32760(gp)
  1008a4:	10800017 	ldw	r2,0(r2)
  1008a8:	10800098 	cmpnei	r2,r2,2
  1008ac:	1000061e 	bne	r2,zero,1008c8 <main+0x148>
					IOWR_ALTERA_AVALON_PIO_DATA(TRANSITION_BASE, 0x0);
  1008b0:	0005883a 	mov	r2,zero
  1008b4:	00806835 	stwio	r2,416(zero)
					IOWR_ALTERA_AVALON_PIO_DATA(REAL_VAL_BASE, 0xFFFFFFFF);
  1008b8:	00bfffc4 	movi	r2,-1
  1008bc:	00806035 	stwio	r2,384(zero)
					IOWR_ALTERA_AVALON_PIO_DATA(IMAG_VAL_BASE, 0xFFFFFFFF);
  1008c0:	00bfffc4 	movi	r2,-1
  1008c4:	00800035 	stwio	r2,0(zero)
				}
				
				int state = IORD_ALTERA_AVALON_PIO_DATA(STATE_BASE);
  1008c8:	00805c37 	ldwio	r2,368(zero)
  1008cc:	e0bff915 	stw	r2,-28(fp)

				rcode = kbdPoll(&kbdbuf);
  1008d0:	e0bff4c4 	addi	r2,fp,-45
  1008d4:	1009883a 	mov	r4,r2
  1008d8:	01015780 	call	101578 <kbdPoll>
  1008dc:	e0bff8c5 	stb	r2,-29(fp)
				if (rcode == hrNAK) {
  1008e0:	e0bff8c3 	ldbu	r2,-29(fp)
  1008e4:	10800118 	cmpnei	r2,r2,4
  1008e8:	10010026 	beq	r2,zero,100cec <main+0x56c>
					continue; //NAK means no new data
				} else if (rcode) {
  1008ec:	e0bff8c3 	ldbu	r2,-29(fp)
  1008f0:	10000926 	beq	r2,zero,100918 <main+0x198>
					printf("Rcode: ");
  1008f4:	01000434 	movhi	r4,16
  1008f8:	211a9004 	addi	r4,r4,27200
  1008fc:	0102f200 	call	102f20 <printf>
					printf("%x \n", rcode);
  100900:	e0bff8c3 	ldbu	r2,-29(fp)
  100904:	100b883a 	mov	r5,r2
  100908:	01000434 	movhi	r4,16
  10090c:	211a7204 	addi	r4,r4,27080
  100910:	0102f200 	call	102f20 <printf>
					continue;
  100914:	0000f606 	br	100cf0 <main+0x570>
				}
				printf("keycodes: ");
  100918:	01000434 	movhi	r4,16
  10091c:	211a9204 	addi	r4,r4,27208
  100920:	0102f200 	call	102f20 <printf>
				for (int i = 0; i < 6; i++) {
  100924:	e03ffc15 	stw	zero,-16(fp)
  100928:	00000c06 	br	10095c <main+0x1dc>
					printf("%x ", kbdbuf.keycode[i]);
  10092c:	e0bffc17 	ldw	r2,-16(fp)
  100930:	e0ffff04 	addi	r3,fp,-4
  100934:	1885883a 	add	r2,r3,r2
  100938:	10bff643 	ldbu	r2,-39(r2)
  10093c:	10803fcc 	andi	r2,r2,255
  100940:	100b883a 	mov	r5,r2
  100944:	01000434 	movhi	r4,16
  100948:	211a9504 	addi	r4,r4,27220
  10094c:	0102f200 	call	102f20 <printf>
				for (int i = 0; i < 6; i++) {
  100950:	e0bffc17 	ldw	r2,-16(fp)
  100954:	10800044 	addi	r2,r2,1
  100958:	e0bffc15 	stw	r2,-16(fp)
  10095c:	e0bffc17 	ldw	r2,-16(fp)
  100960:	10800190 	cmplti	r2,r2,6
  100964:	103ff11e 	bne	r2,zero,10092c <main+0x1ac>
				}

				if (prev_keycode == NULL){
  100968:	e0bffd8b 	ldhu	r2,-10(fp)
  10096c:	1000031e 	bne	r2,zero,10097c <main+0x1fc>
					prev_keycode = kbdbuf.keycode[0];
  100970:	e0bff543 	ldbu	r2,-43(fp)
  100974:	10803fcc 	andi	r2,r2,255
  100978:	e0bffd8d 	sth	r2,-10(fp)
				}

				if (state == 0){ // ASSIGN FRACTAL CONSTANTS
  10097c:	e0bff917 	ldw	r2,-28(fp)
  100980:	1000571e 	bne	r2,zero,100ae0 <main+0x360>
                    for (int j = 0; j < ROWS; j++){
  100984:	e03ffb15 	stw	zero,-20(fp)
  100988:	00001206 	br	1009d4 <main+0x254>
                        memcpy((void*)&vga_ctrl->VRAM[j*COLUMNS]+(ROWS-j),coord_prompt, sizeof(coord_prompt));
  10098c:	d4200017 	ldw	r16,-32768(gp)
  100990:	01401404 	movi	r5,80
  100994:	e13ffb17 	ldw	r4,-20(fp)
  100998:	0102e940 	call	102e94 <__mulsi3>
  10099c:	8085883a 	add	r2,r16,r2
  1009a0:	01000784 	movi	r4,30
  1009a4:	e0fffb17 	ldw	r3,-20(fp)
  1009a8:	20c7c83a 	sub	r3,r4,r3
  1009ac:	10c5883a 	add	r2,r2,r3
  1009b0:	1009883a 	mov	r4,r2
  1009b4:	e0bfee84 	addi	r2,fp,-70
  1009b8:	00c00644 	movi	r3,25
  1009bc:	180d883a 	mov	r6,r3
  1009c0:	100b883a 	mov	r5,r2
  1009c4:	0102ebc0 	call	102ebc <memcpy>
                    for (int j = 0; j < ROWS; j++){
  1009c8:	e0bffb17 	ldw	r2,-20(fp)
  1009cc:	10800044 	addi	r2,r2,1
  1009d0:	e0bffb15 	stw	r2,-20(fp)
  1009d4:	e0bffb17 	ldw	r2,-20(fp)
  1009d8:	10800790 	cmplti	r2,r2,30
  1009dc:	103feb1e 	bne	r2,zero,10098c <main+0x20c>
                    }
                    if ((prev_keycode == 0x00) && (kbdbuf.keycode[0] != 0x00)){
  1009e0:	e0bffd8b 	ldhu	r2,-10(fp)
  1009e4:	10003a1e 	bne	r2,zero,100ad0 <main+0x350>
  1009e8:	e0bff543 	ldbu	r2,-43(fp)
  1009ec:	10803fcc 	andi	r2,r2,255
  1009f0:	10003726 	beq	r2,zero,100ad0 <main+0x350>
                        switch(kbdbuf.keycode[0]){
  1009f4:	e0bff543 	ldbu	r2,-43(fp)
  1009f8:	10803fcc 	andi	r2,r2,255
  1009fc:	10bff884 	addi	r2,r2,-30
  100a00:	10c002a8 	cmpgeui	r3,r2,10
  100a04:	1800301e 	bne	r3,zero,100ac8 <main+0x348>
  100a08:	100690ba 	slli	r3,r2,2
  100a0c:	00800434 	movhi	r2,16
  100a10:	1885883a 	add	r2,r3,r2
  100a14:	10828717 	ldw	r2,2588(r2)
  100a18:	1000683a 	jmp	r2
  100a1c:	00100a5c 	xori	zero,zero,16425
  100a20:	00100a70 	cmpltui	zero,zero,16425
  100a24:	00100a84 	movi	zero,16426
  100a28:	00100a98 	cmpnei	zero,zero,16426
  100a2c:	00100ab0 	cmpltui	zero,zero,16426
  100a30:	00100ac8 	cmpgei	zero,zero,16427
  100a34:	00100ac8 	cmpgei	zero,zero,16427
  100a38:	00100ac8 	cmpgei	zero,zero,16427
  100a3c:	00100ac8 	cmpgei	zero,zero,16427
  100a40:	00100a44 	movi	zero,16425
                                case KEY_0:
                                	IOWR_ALTERA_AVALON_PIO_DATA(REAL_VAL_BASE, 0xFFFF3334);
  100a44:	00bffff4 	movhi	r2,65535
  100a48:	108ccd04 	addi	r2,r2,13108
  100a4c:	00806035 	stwio	r2,384(zero)
                                	IOWR_ALTERA_AVALON_PIO_DATA(IMAG_VAL_BASE, 0x000027EF);
  100a50:	0089fbc4 	movi	r2,10223
  100a54:	00800035 	stwio	r2,0(zero)
                                	break;
  100a58:	00001b06 	br	100ac8 <main+0x348>
                                case KEY_1:
                                	IOWR_ALTERA_AVALON_PIO_DATA(REAL_VAL_BASE, 0xFFFF999A);
  100a5c:	00a66684 	movi	r2,-26214
  100a60:	00806035 	stwio	r2,384(zero)
                                	IOWR_ALTERA_AVALON_PIO_DATA(IMAG_VAL_BASE, 0x00009999);
  100a64:	00a66654 	movui	r2,39321
  100a68:	00800035 	stwio	r2,0(zero)
                                	break;
  100a6c:	00001606 	br	100ac8 <main+0x348>
                                case KEY_2:
                                	IOWR_ALTERA_AVALON_PIO_DATA(REAL_VAL_BASE, 0x000048F5);
  100a70:	00923d44 	movi	r2,18677
  100a74:	00806035 	stwio	r2,384(zero)
                                	IOWR_ALTERA_AVALON_PIO_DATA(IMAG_VAL_BASE, 0x00000000);
  100a78:	0005883a 	mov	r2,zero
  100a7c:	00800035 	stwio	r2,0(zero)
                                	break;
  100a80:	00001106 	br	100ac8 <main+0x348>
                                case KEY_3:
                                	IOWR_ALTERA_AVALON_PIO_DATA(REAL_VAL_BASE, 0x0000416F);
  100a84:	00905bc4 	movi	r2,16751
  100a88:	00806035 	stwio	r2,384(zero)
                                	IOWR_ALTERA_AVALON_PIO_DATA(IMAG_VAL_BASE, 0x00008D0E);
  100a8c:	00a34394 	movui	r2,36110
  100a90:	00800035 	stwio	r2,0(zero)
                                	break;
  100a94:	00000c06 	br	100ac8 <main+0x348>
                                case KEY_4:
                                	IOWR_ALTERA_AVALON_PIO_DATA(REAL_VAL_BASE, 0xFFFF399A);
  100a98:	00bffff4 	movhi	r2,65535
  100a9c:	108e6684 	addi	r2,r2,14746
  100aa0:	00806035 	stwio	r2,384(zero)
                                	IOWR_ALTERA_AVALON_PIO_DATA(IMAG_VAL_BASE, 0X00000000);
  100aa4:	0005883a 	mov	r2,zero
  100aa8:	00800035 	stwio	r2,0(zero)
                                	break;
  100aac:	00000606 	br	100ac8 <main+0x348>
                                case KEY_5:
                                	IOWR_ALTERA_AVALON_PIO_DATA(REAL_VAL_BASE, 0xFFFF45EA);
  100ab0:	00bffff4 	movhi	r2,65535
  100ab4:	10917a84 	addi	r2,r2,17898
  100ab8:	00806035 	stwio	r2,384(zero)
                                	IOWR_ALTERA_AVALON_PIO_DATA(IMAG_VAL_BASE, 0x0000305B);
  100abc:	008c16c4 	movi	r2,12379
  100ac0:	00800035 	stwio	r2,0(zero)
                                	break;
  100ac4:	0001883a 	nop
                                // case KEY_8:
                                //     real_val += (80.1);
                                // case KEY_9:
                                //     real_val += (90.1);
                        }
                        IOWR_ALTERA_AVALON_PIO_DATA(TRANSITION_BASE, 0x1);
  100ac8:	00800044 	movi	r2,1
  100acc:	00806835 	stwio	r2,416(zero)
                    }
					prev_keycode = kbdbuf.keycode[0];
  100ad0:	e0bff543 	ldbu	r2,-43(fp)
  100ad4:	10803fcc 	andi	r2,r2,255
  100ad8:	e0bffd8d 	sth	r2,-10(fp)
  100adc:	00005006 	br	100c20 <main+0x4a0>
                }
                else if (state == 1){ // ASSIGN COLOR
  100ae0:	e0bff917 	ldw	r2,-28(fp)
  100ae4:	10800058 	cmpnei	r2,r2,1
  100ae8:	10004d1e 	bne	r2,zero,100c20 <main+0x4a0>
					for (int j = 0; j < ROWS; j++){
  100aec:	e03ffa15 	stw	zero,-24(fp)
  100af0:	00001206 	br	100b3c <main+0x3bc>
                        memcpy((void*)&vga_ctrl->VRAM[j*COLUMNS]+(ROWS-j),color_prompt, sizeof(color_prompt));
  100af4:	d4200017 	ldw	r16,-32768(gp)
  100af8:	01401404 	movi	r5,80
  100afc:	e13ffa17 	ldw	r4,-24(fp)
  100b00:	0102e940 	call	102e94 <__mulsi3>
  100b04:	8085883a 	add	r2,r16,r2
  100b08:	01000784 	movi	r4,30
  100b0c:	e0fffa17 	ldw	r3,-24(fp)
  100b10:	20c7c83a 	sub	r3,r4,r3
  100b14:	10c5883a 	add	r2,r2,r3
  100b18:	1009883a 	mov	r4,r2
  100b1c:	e0bfe8c4 	addi	r2,fp,-93
  100b20:	00c005c4 	movi	r3,23
  100b24:	180d883a 	mov	r6,r3
  100b28:	100b883a 	mov	r5,r2
  100b2c:	0102ebc0 	call	102ebc <memcpy>
					for (int j = 0; j < ROWS; j++){
  100b30:	e0bffa17 	ldw	r2,-24(fp)
  100b34:	10800044 	addi	r2,r2,1
  100b38:	e0bffa15 	stw	r2,-24(fp)
  100b3c:	e0bffa17 	ldw	r2,-24(fp)
  100b40:	10800790 	cmplti	r2,r2,30
  100b44:	103feb1e 	bne	r2,zero,100af4 <main+0x374>
                    }
                    if ((prev_keycode == 0x00) && (kbdbuf.keycode[0] != 0x00)){
  100b48:	e0bffd8b 	ldhu	r2,-10(fp)
  100b4c:	1000311e 	bne	r2,zero,100c14 <main+0x494>
  100b50:	e0bff543 	ldbu	r2,-43(fp)
  100b54:	10803fcc 	andi	r2,r2,255
  100b58:	10002e26 	beq	r2,zero,100c14 <main+0x494>
                        switch(kbdbuf.keycode[0]){
  100b5c:	e0bff543 	ldbu	r2,-43(fp)
  100b60:	10803fcc 	andi	r2,r2,255
  100b64:	10bff884 	addi	r2,r2,-30
  100b68:	10c002a8 	cmpgeui	r3,r2,10
  100b6c:	1800271e 	bne	r3,zero,100c0c <main+0x48c>
  100b70:	100690ba 	slli	r3,r2,2
  100b74:	00800434 	movhi	r2,16
  100b78:	1885883a 	add	r2,r3,r2
  100b7c:	1082e117 	ldw	r2,2948(r2)
  100b80:	1000683a 	jmp	r2
  100b84:	00100bb8 	rdprs	zero,zero,16430
  100b88:	00100bc4 	movi	zero,16431
  100b8c:	00100bd0 	cmplti	zero,zero,16431
  100b90:	00100bdc 	xori	zero,zero,16431
  100b94:	00100be8 	cmpgeui	zero,zero,16431
  100b98:	00100bf4 	movhi	zero,16431
  100b9c:	00100c00 	call	100c0 <impure_data+0x90>
  100ba0:	00100c0c 	andi	zero,zero,16432
  100ba4:	00100c0c 	andi	zero,zero,16432
  100ba8:	00100bac 	andhi	zero,zero,16430
                                case KEY_0:
                                	IOWR_ALTERA_AVALON_PIO_DATA(COLOR_BASE, 0x00000000);
  100bac:	0005883a 	mov	r2,zero
  100bb0:	00806435 	stwio	r2,400(zero)
                                	break;
  100bb4:	00001506 	br	100c0c <main+0x48c>
                                case KEY_1:
                                	IOWR_ALTERA_AVALON_PIO_DATA(COLOR_BASE, 0x00000001);
  100bb8:	00800044 	movi	r2,1
  100bbc:	00806435 	stwio	r2,400(zero)
                                	break;
  100bc0:	00001206 	br	100c0c <main+0x48c>
                                case KEY_2:
                                	IOWR_ALTERA_AVALON_PIO_DATA(COLOR_BASE, 0x00000002);
  100bc4:	00800084 	movi	r2,2
  100bc8:	00806435 	stwio	r2,400(zero)
                                	break;
  100bcc:	00000f06 	br	100c0c <main+0x48c>
                                case KEY_3:
                                	IOWR_ALTERA_AVALON_PIO_DATA(COLOR_BASE, 0x00000003);
  100bd0:	008000c4 	movi	r2,3
  100bd4:	00806435 	stwio	r2,400(zero)
                                	break;
  100bd8:	00000c06 	br	100c0c <main+0x48c>
                                case KEY_4:
                                	IOWR_ALTERA_AVALON_PIO_DATA(COLOR_BASE, 0x00000004);
  100bdc:	00800104 	movi	r2,4
  100be0:	00806435 	stwio	r2,400(zero)
                                	break;
  100be4:	00000906 	br	100c0c <main+0x48c>
                                case KEY_5:
                                	IOWR_ALTERA_AVALON_PIO_DATA(COLOR_BASE, 0x00000005);
  100be8:	00800144 	movi	r2,5
  100bec:	00806435 	stwio	r2,400(zero)
                                	break;
  100bf0:	00000606 	br	100c0c <main+0x48c>
                                case KEY_6:
                                	IOWR_ALTERA_AVALON_PIO_DATA(COLOR_BASE, 0x00000006);
  100bf4:	00800184 	movi	r2,6
  100bf8:	00806435 	stwio	r2,400(zero)
                                	break;
  100bfc:	00000306 	br	100c0c <main+0x48c>
                                case KEY_7:
                                	IOWR_ALTERA_AVALON_PIO_DATA(COLOR_BASE, 0x00000007);
  100c00:	008001c4 	movi	r2,7
  100c04:	00806435 	stwio	r2,400(zero)
                                	break;
  100c08:	0001883a 	nop
                                // case KEY_8:
                                //     real_val += (80.1);
                                // case KEY_9:
                                //     real_val += (90.1);
                        }
                        IOWR_ALTERA_AVALON_PIO_DATA(TRANSITION_BASE, 0x1);
  100c0c:	00800044 	movi	r2,1
  100c10:	00806835 	stwio	r2,416(zero)
                    }
					prev_keycode = kbdbuf.keycode[0];
  100c14:	e0bff543 	ldbu	r2,-43(fp)
  100c18:	10803fcc 	andi	r2,r2,255
  100c1c:	e0bffd8d 	sth	r2,-10(fp)
				// 	}
				// }
				// const char * = "0x320";
  				// int hex_value = (int)strtol(, NULL, 0);

				setKeycode(kbdbuf.keycode[0]);
  100c20:	e0bff543 	ldbu	r2,-43(fp)
  100c24:	10803fcc 	andi	r2,r2,255
  100c28:	1009883a 	mov	r4,r2
  100c2c:	01007000 	call	100700 <setKeycode>
				printSignedHex0(kbdbuf.keycode[0]);
  100c30:	e0bff543 	ldbu	r2,-43(fp)
  100c34:	10803fcc 	andi	r2,r2,255
  100c38:	1080201c 	xori	r2,r2,128
  100c3c:	10bfe004 	addi	r2,r2,-128
  100c40:	1009883a 	mov	r4,r2
  100c44:	01004c00 	call	1004c0 <printSignedHex0>
				printSignedHex1(kbdbuf.keycode[1]);
  100c48:	e0bff583 	ldbu	r2,-42(fp)
  100c4c:	10803fcc 	andi	r2,r2,255
  100c50:	1080201c 	xori	r2,r2,128
  100c54:	10bfe004 	addi	r2,r2,-128
  100c58:	1009883a 	mov	r4,r2
  100c5c:	01005d00 	call	1005d0 <printSignedHex1>
				printf("\n");
  100c60:	01000284 	movi	r4,10
  100c64:	0102f700 	call	102f70 <putchar>
  100c68:	003ef906 	br	100850 <main+0xd0>
//				if (buf.button & 0x01)
//					setLED(0);
//				else
//					clearLED(0);
//			}
		} else if (GetUsbTaskState() == USB_STATE_ERROR) {
  100c6c:	0102c000 	call	102c00 <GetUsbTaskState>
  100c70:	10803fcc 	andi	r2,r2,255
  100c74:	10803fd8 	cmpnei	r2,r2,255
  100c78:	10000a1e 	bne	r2,zero,100ca4 <main+0x524>
			if (!errorflag) {
  100c7c:	e0bffe83 	ldbu	r2,-6(fp)
  100c80:	103ef31e 	bne	r2,zero,100850 <main+0xd0>
				errorflag = 1;
  100c84:	00800044 	movi	r2,1
  100c88:	e0bffe85 	stb	r2,-6(fp)
				clearLED(9);
  100c8c:	01000244 	movi	r4,9
  100c90:	01004800 	call	100480 <clearLED>
				printf("USB Error State\n");
  100c94:	01000434 	movhi	r4,16
  100c98:	211a9604 	addi	r4,r4,27224
  100c9c:	01030100 	call	103010 <puts>
  100ca0:	003eeb06 	br	100850 <main+0xd0>
				//print out string descriptor here
			}
		} else //not in USB running state
		{

			printf("USB task state: ");
  100ca4:	01000434 	movhi	r4,16
  100ca8:	211a9a04 	addi	r4,r4,27240
  100cac:	0102f200 	call	102f20 <printf>
			printf("%x\n", GetUsbTaskState());
  100cb0:	0102c000 	call	102c00 <GetUsbTaskState>
  100cb4:	10803fcc 	andi	r2,r2,255
  100cb8:	100b883a 	mov	r5,r2
  100cbc:	01000434 	movhi	r4,16
  100cc0:	211a9f04 	addi	r4,r4,27260
  100cc4:	0102f200 	call	102f20 <printf>
			if (runningdebugflag) {	//previously running, reset USB hardware just to clear out any funky state, HS/FS etc
  100cc8:	e0bffec3 	ldbu	r2,-5(fp)
  100ccc:	10000326 	beq	r2,zero,100cdc <main+0x55c>
				runningdebugflag = 0;
  100cd0:	e03ffec5 	stb	zero,-5(fp)
				MAX3421E_init();
  100cd4:	0101c580 	call	101c58 <MAX3421E_init>
				USB_init();
  100cd8:	01024100 	call	102410 <USB_init>
			}
			errorflag = 0;
  100cdc:	e03ffe85 	stb	zero,-6(fp)
			clearLED(9);
  100ce0:	01000244 	movi	r4,9
  100ce4:	01004800 	call	100480 <clearLED>
  100ce8:	003ed906 	br	100850 <main+0xd0>
					continue; //NAK means no new data
  100cec:	0001883a 	nop
		printf(".");
  100cf0:	003ed706 	br	100850 <main+0xd0>

00100cf4 <HIDMProbe>:
/* HID Mouse probe. Called from USB state machine.                          */
/* assumes configuration length is less than 256 bytes                      */
/* looks for Class:03, Subclass: 01, Protocol: 02 in interface descriptor   */
/* sets mouse in boot protocol                                              */
/* assumes single configuration and interface configuration 0               */
BOOL HIDMProbe(BYTE addr, DWORD flags) {
  100cf4:	defff204 	addi	sp,sp,-56
  100cf8:	dfc00d15 	stw	ra,52(sp)
  100cfc:	df000c15 	stw	fp,48(sp)
  100d00:	df000c04 	addi	fp,sp,48
  100d04:	2005883a 	mov	r2,r4
  100d08:	e17ff915 	stw	r5,-28(fp)
  100d0c:	e0bffa05 	stb	r2,-24(fp)
	BYTE tmpbyte;
	BYTE rcode;
	BYTE confvalue;
	WORD total_length;
	USB_DESCR* data_ptr = (USB_DESCR *) &bigbuf;
  100d10:	00800074 	movhi	r2,1
  100d14:	10853504 	addi	r2,r2,5332
  100d18:	e0bffe15 	stw	r2,-8(fp)
	BYTE* byte_ptr = bigbuf;
  100d1c:	00800074 	movhi	r2,1
  100d20:	10853504 	addi	r2,r2,5332
  100d24:	e0bffd15 	stw	r2,-12(fp)
	rcode = XferGetConfDescr(addr, 0, CONF_DESCR_LEN, 0, bigbuf); //get configuration descriptor
  100d28:	e0fffa03 	ldbu	r3,-24(fp)
  100d2c:	00800074 	movhi	r2,1
  100d30:	10853504 	addi	r2,r2,5332
  100d34:	d8800415 	stw	r2,16(sp)
  100d38:	00800244 	movi	r2,9
  100d3c:	d8800315 	stw	r2,12(sp)
  100d40:	d8000215 	stw	zero,8(sp)
  100d44:	00800084 	movi	r2,2
  100d48:	d8800115 	stw	r2,4(sp)
  100d4c:	d8000015 	stw	zero,0(sp)
  100d50:	01c00184 	movi	r7,6
  100d54:	01802004 	movi	r6,128
  100d58:	000b883a 	mov	r5,zero
  100d5c:	1809883a 	mov	r4,r3
  100d60:	0101e480 	call	101e48 <XferCtrlReq>
  100d64:	e0bffcc5 	stb	r2,-13(fp)
	if (rcode) {   //error handling
  100d68:	e0bffcc3 	ldbu	r2,-13(fp)
  100d6c:	10000226 	beq	r2,zero,100d78 <HIDMProbe+0x84>
		//printf("unable to get configuration descriptor");
		return (FALSE);
  100d70:	0005883a 	mov	r2,zero
  100d74:	0000d306 	br	1010c4 <HIDMProbe+0x3d0>
	}
	if (data_ptr->descr.config.wTotalLength > 256) {
  100d78:	e0bffe17 	ldw	r2,-8(fp)
  100d7c:	1080008b 	ldhu	r2,2(r2)
  100d80:	10bfffcc 	andi	r2,r2,65535
  100d84:	10804070 	cmpltui	r2,r2,257
  100d88:	1000031e 	bne	r2,zero,100d98 <HIDMProbe+0xa4>
		total_length = 256;
  100d8c:	00804004 	movi	r2,256
  100d90:	e0bfff8d 	sth	r2,-2(fp)
  100d94:	00000306 	br	100da4 <HIDMProbe+0xb0>
	} else {
		total_length = data_ptr->descr.config.wTotalLength;
  100d98:	e0bffe17 	ldw	r2,-8(fp)
  100d9c:	1080008b 	ldhu	r2,2(r2)
  100da0:	e0bfff8d 	sth	r2,-2(fp)
	}
	rcode = XferGetConfDescr(addr, 0, total_length, 0, bigbuf); //get the whole configuration
  100da4:	e13ffa03 	ldbu	r4,-24(fp)
  100da8:	e0ffff8b 	ldhu	r3,-2(fp)
  100dac:	00800074 	movhi	r2,1
  100db0:	10853504 	addi	r2,r2,5332
  100db4:	d8800415 	stw	r2,16(sp)
  100db8:	d8c00315 	stw	r3,12(sp)
  100dbc:	d8000215 	stw	zero,8(sp)
  100dc0:	00800084 	movi	r2,2
  100dc4:	d8800115 	stw	r2,4(sp)
  100dc8:	d8000015 	stw	zero,0(sp)
  100dcc:	01c00184 	movi	r7,6
  100dd0:	01802004 	movi	r6,128
  100dd4:	000b883a 	mov	r5,zero
  100dd8:	0101e480 	call	101e48 <XferCtrlReq>
  100ddc:	e0bffcc5 	stb	r2,-13(fp)
	if (rcode) {   //error handling
  100de0:	e0bffcc3 	ldbu	r2,-13(fp)
  100de4:	10000226 	beq	r2,zero,100df0 <HIDMProbe+0xfc>
		//printf("unable to get configuration");
		return (FALSE);
  100de8:	0005883a 	mov	r2,zero
  100dec:	0000b506 	br	1010c4 <HIDMProbe+0x3d0>
	}
	confvalue = data_ptr->descr.config.bConfigurationValue;
  100df0:	e0bffe17 	ldw	r2,-8(fp)
  100df4:	10800143 	ldbu	r2,5(r2)
  100df8:	e0bffc85 	stb	r2,-14(fp)
	//printf("checking configuration value (length: %d): ",
	//		data_ptr->descr.config.wTotalLength);
	//for (int i = 0; i < data_ptr->descr.config.wTotalLength; i++) {
		//printf("%x ", (unsigned char) (bigbuf[i] & 0xff));
	//}
	while (byte_ptr < bigbuf + total_length) {
  100dfc:	0000aa06 	br	1010a8 <HIDMProbe+0x3b4>
		if (data_ptr->descr.config.bDescriptorType != USB_DESCRIPTOR_INTERFACE) {
  100e00:	e0bffe17 	ldw	r2,-8(fp)
  100e04:	10800043 	ldbu	r2,1(r2)
  100e08:	10803fcc 	andi	r2,r2,255
  100e0c:	10800120 	cmpeqi	r2,r2,4
  100e10:	1000091e 	bne	r2,zero,100e38 <HIDMProbe+0x144>
			byte_ptr = byte_ptr + data_ptr->descr.config.bLength;
  100e14:	e0bffe17 	ldw	r2,-8(fp)
  100e18:	10800003 	ldbu	r2,0(r2)
  100e1c:	10803fcc 	andi	r2,r2,255
  100e20:	e0fffd17 	ldw	r3,-12(fp)
  100e24:	1885883a 	add	r2,r3,r2
  100e28:	e0bffd15 	stw	r2,-12(fp)
			data_ptr = (USB_DESCR*) byte_ptr;
  100e2c:	e0bffd17 	ldw	r2,-12(fp)
  100e30:	e0bffe15 	stw	r2,-8(fp)
  100e34:	00009c06 	br	1010a8 <HIDMProbe+0x3b4>
		} // if( data_ptr->descr.config.bDescriptorType != USB_DESCRIPTOR_INTERFACE
		else {
			//printf("starting interface parsing at byte location %d\n",
			//		data_ptr->descr.config.bLength);
			BYTE class = data_ptr->descr.interface.bInterfaceClass;
  100e38:	e0bffe17 	ldw	r2,-8(fp)
  100e3c:	10800143 	ldbu	r2,5(r2)
  100e40:	e0bffc45 	stb	r2,-15(fp)
			BYTE subclass = data_ptr->descr.interface.bInterfaceSubClass;
  100e44:	e0bffe17 	ldw	r2,-8(fp)
  100e48:	10800183 	ldbu	r2,6(r2)
  100e4c:	e0bffc05 	stb	r2,-16(fp)
			BYTE protocol = data_ptr->descr.interface.bInterfaceProtocol;
  100e50:	e0bffe17 	ldw	r2,-8(fp)
  100e54:	108001c3 	ldbu	r2,7(r2)
  100e58:	e0bffbc5 	stb	r2,-17(fp)
			//printf("class %x, subclass %x, protocol %x,\n", class, subclass,
			//		protocol);
			//interface descriptor
			if (class == HID_INTF && subclass == BOOT_INTF_SUBCLASS
  100e5c:	e0bffc43 	ldbu	r2,-15(fp)
  100e60:	108000d8 	cmpnei	r2,r2,3
  100e64:	10008e1e 	bne	r2,zero,1010a0 <HIDMProbe+0x3ac>
  100e68:	e0bffc03 	ldbu	r2,-16(fp)
  100e6c:	10800058 	cmpnei	r2,r2,1
  100e70:	10008b1e 	bne	r2,zero,1010a0 <HIDMProbe+0x3ac>
					&& protocol == HID_PROTOCOL_MOUSE) {
  100e74:	e0bffbc3 	ldbu	r2,-17(fp)
  100e78:	10800098 	cmpnei	r2,r2,2
  100e7c:	1000881e 	bne	r2,zero,1010a0 <HIDMProbe+0x3ac>
				//detected a mouse
				devtable[addr].devclass = HID_M;                  //device class
  100e80:	e0bffa03 	ldbu	r2,-24(fp)
  100e84:	100890fa 	slli	r4,r2,3
  100e88:	00c00084 	movi	r3,2
  100e8c:	00800074 	movhi	r2,1
  100e90:	2085883a 	add	r2,r4,r2
  100e94:	10c57605 	stb	r3,5592(r2)
				tmpbyte = devtable[addr].epinfo->MaxPktSize;
  100e98:	e0bffa03 	ldbu	r2,-24(fp)
  100e9c:	100690fa 	slli	r3,r2,3
  100ea0:	00800074 	movhi	r2,1
  100ea4:	1885883a 	add	r2,r3,r2
  100ea8:	10857517 	ldw	r2,5588(r2)
  100eac:	1080008b 	ldhu	r2,2(r2)
  100eb0:	e0bffb85 	stb	r2,-18(fp)
				HID_init();                         //initialize data structures
  100eb4:	01014bc0 	call	1014bc <HID_init>
				devtable[addr].epinfo = hid_ep; //switch endpoint information structure
  100eb8:	e0bffa03 	ldbu	r2,-24(fp)
  100ebc:	100890fa 	slli	r4,r2,3
  100ec0:	00c00074 	movhi	r3,1
  100ec4:	18c52b04 	addi	r3,r3,5292
  100ec8:	00800074 	movhi	r2,1
  100ecc:	2085883a 	add	r2,r4,r2
  100ed0:	10c57515 	stw	r3,5588(r2)
				devtable[addr].epinfo[0].MaxPktSize = tmpbyte;
  100ed4:	e0bffa03 	ldbu	r2,-24(fp)
  100ed8:	100690fa 	slli	r3,r2,3
  100edc:	00800074 	movhi	r2,1
  100ee0:	1885883a 	add	r2,r3,r2
  100ee4:	10857517 	ldw	r2,5588(r2)
  100ee8:	e0fffb83 	ldbu	r3,-18(fp)
  100eec:	10c0008d 	sth	r3,2(r2)
				hid_device.interface =
						data_ptr->descr.interface.bInterfaceNumber;
  100ef0:	e0bffe17 	ldw	r2,-8(fp)
  100ef4:	10800083 	ldbu	r2,2(r2)
				hid_device.interface =
  100ef8:	d0a01645 	stb	r2,-32679(gp)
				hid_device.addr = addr;
  100efc:	e0bffa03 	ldbu	r2,-24(fp)
  100f00:	d0a01605 	stb	r2,-32680(gp)
				byte_ptr = byte_ptr + data_ptr->descr.config.bLength;
  100f04:	e0bffe17 	ldw	r2,-8(fp)
  100f08:	10800003 	ldbu	r2,0(r2)
  100f0c:	10803fcc 	andi	r2,r2,255
  100f10:	e0fffd17 	ldw	r3,-12(fp)
  100f14:	1885883a 	add	r2,r3,r2
  100f18:	e0bffd15 	stw	r2,-12(fp)
				data_ptr = (USB_DESCR*) byte_ptr;
  100f1c:	e0bffd17 	ldw	r2,-12(fp)
  100f20:	e0bffe15 	stw	r2,-8(fp)
				while (byte_ptr < bigbuf + total_length) {
  100f24:	00005706 	br	101084 <HIDMProbe+0x390>
					if (data_ptr->descr.config.bDescriptorType
  100f28:	e0bffe17 	ldw	r2,-8(fp)
  100f2c:	10800043 	ldbu	r2,1(r2)
  100f30:	10803fcc 	andi	r2,r2,255
  100f34:	10800160 	cmpeqi	r2,r2,5
  100f38:	1000091e 	bne	r2,zero,100f60 <HIDMProbe+0x26c>
							!= USB_DESCRIPTOR_ENDPOINT) { //skip to endpoint descriptor
						byte_ptr = byte_ptr + data_ptr->descr.config.bLength;
  100f3c:	e0bffe17 	ldw	r2,-8(fp)
  100f40:	10800003 	ldbu	r2,0(r2)
  100f44:	10803fcc 	andi	r2,r2,255
  100f48:	e0fffd17 	ldw	r3,-12(fp)
  100f4c:	1885883a 	add	r2,r3,r2
  100f50:	e0bffd15 	stw	r2,-12(fp)
						data_ptr = (USB_DESCR*) byte_ptr;
  100f54:	e0bffd17 	ldw	r2,-12(fp)
  100f58:	e0bffe15 	stw	r2,-8(fp)
  100f5c:	00004906 	br	101084 <HIDMProbe+0x390>
					} else {
						/* fill endpoint information structure */
						devtable[addr].epinfo[1].epAddr =
  100f60:	e0bffa03 	ldbu	r2,-24(fp)
  100f64:	100690fa 	slli	r3,r2,3
  100f68:	00800074 	movhi	r2,1
  100f6c:	1885883a 	add	r2,r3,r2
  100f70:	10857517 	ldw	r2,5588(r2)
  100f74:	10800204 	addi	r2,r2,8
								data_ptr->descr.endpoint.bEndpointAddress;
  100f78:	e0fffe17 	ldw	r3,-8(fp)
  100f7c:	18c00083 	ldbu	r3,2(r3)
						devtable[addr].epinfo[1].epAddr =
  100f80:	10c00005 	stb	r3,0(r2)
						devtable[addr].epinfo[1].Attr =
  100f84:	e0bffa03 	ldbu	r2,-24(fp)
  100f88:	100690fa 	slli	r3,r2,3
  100f8c:	00800074 	movhi	r2,1
  100f90:	1885883a 	add	r2,r3,r2
  100f94:	10857517 	ldw	r2,5588(r2)
  100f98:	10800204 	addi	r2,r2,8
								data_ptr->descr.endpoint.bmAttributes;
  100f9c:	e0fffe17 	ldw	r3,-8(fp)
  100fa0:	18c000c3 	ldbu	r3,3(r3)
						devtable[addr].epinfo[1].Attr =
  100fa4:	10c00045 	stb	r3,1(r2)
						devtable[addr].epinfo[1].MaxPktSize =
  100fa8:	e0bffa03 	ldbu	r2,-24(fp)
  100fac:	100690fa 	slli	r3,r2,3
  100fb0:	00800074 	movhi	r2,1
  100fb4:	1885883a 	add	r2,r3,r2
  100fb8:	10857517 	ldw	r2,5588(r2)
  100fbc:	10800204 	addi	r2,r2,8
								data_ptr->descr.endpoint.wMaxPacketSize;
  100fc0:	e0fffe17 	ldw	r3,-8(fp)
  100fc4:	18c0010b 	ldhu	r3,4(r3)
						devtable[addr].epinfo[1].MaxPktSize =
  100fc8:	10c0008d 	sth	r3,2(r2)
						devtable[addr].epinfo[1].Interval =
  100fcc:	e0bffa03 	ldbu	r2,-24(fp)
  100fd0:	100690fa 	slli	r3,r2,3
  100fd4:	00800074 	movhi	r2,1
  100fd8:	1885883a 	add	r2,r3,r2
  100fdc:	10857517 	ldw	r2,5588(r2)
  100fe0:	10800204 	addi	r2,r2,8
								data_ptr->descr.endpoint.bInterval;
  100fe4:	e0fffe17 	ldw	r3,-8(fp)
  100fe8:	18c00183 	ldbu	r3,6(r3)
						devtable[addr].epinfo[1].Interval =
  100fec:	10c00105 	stb	r3,4(r2)
						// devtable[ addr ].epinfo[ 1 ].rcvToggle = bmRCVTOG0;
						/* configure device */
						rcode = XferSetConf(addr, 0, confvalue); //set configuration
  100ff0:	e0fffa03 	ldbu	r3,-24(fp)
  100ff4:	e0bffc83 	ldbu	r2,-14(fp)
  100ff8:	d8000415 	stw	zero,16(sp)
  100ffc:	d8000315 	stw	zero,12(sp)
  101000:	d8000215 	stw	zero,8(sp)
  101004:	d8000115 	stw	zero,4(sp)
  101008:	d8800015 	stw	r2,0(sp)
  10100c:	01c00244 	movi	r7,9
  101010:	000d883a 	mov	r6,zero
  101014:	000b883a 	mov	r5,zero
  101018:	1809883a 	mov	r4,r3
  10101c:	0101e480 	call	101e48 <XferCtrlReq>
  101020:	e0bffcc5 	stb	r2,-13(fp)
						if (rcode) {   //error handling
  101024:	e0bffcc3 	ldbu	r2,-13(fp)
  101028:	10000226 	beq	r2,zero,101034 <HIDMProbe+0x340>
							return (FALSE);
  10102c:	0005883a 	mov	r2,zero
  101030:	00002406 	br	1010c4 <HIDMProbe+0x3d0>
						}
						rcode = XferSetProto(addr, 0, hid_device.interface,
  101034:	e0fffa03 	ldbu	r3,-24(fp)
  101038:	d0a01643 	ldbu	r2,-32679(gp)
  10103c:	10803fcc 	andi	r2,r2,255
  101040:	d8000415 	stw	zero,16(sp)
  101044:	d8000315 	stw	zero,12(sp)
  101048:	d8800215 	stw	r2,8(sp)
  10104c:	d8000115 	stw	zero,4(sp)
  101050:	d8000015 	stw	zero,0(sp)
  101054:	01c002c4 	movi	r7,11
  101058:	01800844 	movi	r6,33
  10105c:	000b883a 	mov	r5,zero
  101060:	1809883a 	mov	r4,r3
  101064:	0101e480 	call	101e48 <XferCtrlReq>
  101068:	e0bffcc5 	stb	r2,-13(fp)
								BOOT_PROTOCOL);
						if (rcode) {   //error handling
  10106c:	e0bffcc3 	ldbu	r2,-13(fp)
  101070:	10000226 	beq	r2,zero,10107c <HIDMProbe+0x388>
							return (FALSE);
  101074:	0005883a 	mov	r2,zero
  101078:	00001206 	br	1010c4 <HIDMProbe+0x3d0>
						} else {
							return (TRUE);
  10107c:	00800044 	movi	r2,1
  101080:	00001006 	br	1010c4 <HIDMProbe+0x3d0>
				while (byte_ptr < bigbuf + total_length) {
  101084:	e0ffff8b 	ldhu	r3,-2(fp)
  101088:	00800074 	movhi	r2,1
  10108c:	10853504 	addi	r2,r2,5332
  101090:	1885883a 	add	r2,r3,r2
  101094:	e0fffd17 	ldw	r3,-12(fp)
  101098:	18bfa336 	bltu	r3,r2,100f28 <HIDMProbe+0x234>
			if (class == HID_INTF && subclass == BOOT_INTF_SUBCLASS
  10109c:	00000206 	br	1010a8 <HIDMProbe+0x3b4>
						}
					}
				}   //while( byte_ptr....
			}   //if (Class matches
			else { //if class don't match; die on first interface. Not really correct
				return (FALSE);
  1010a0:	0005883a 	mov	r2,zero
  1010a4:	00000706 	br	1010c4 <HIDMProbe+0x3d0>
	while (byte_ptr < bigbuf + total_length) {
  1010a8:	e0ffff8b 	ldhu	r3,-2(fp)
  1010ac:	00800074 	movhi	r2,1
  1010b0:	10853504 	addi	r2,r2,5332
  1010b4:	1885883a 	add	r2,r3,r2
  1010b8:	e0fffd17 	ldw	r3,-12(fp)
  1010bc:	18bf5036 	bltu	r3,r2,100e00 <HIDMProbe+0x10c>
			}
		} //else if( data_ptr->
	} // while( byte_ptr < &buf + total_length
	return (FALSE);
  1010c0:	0005883a 	mov	r2,zero
}
  1010c4:	e037883a 	mov	sp,fp
  1010c8:	dfc00117 	ldw	ra,4(sp)
  1010cc:	df000017 	ldw	fp,0(sp)
  1010d0:	dec00204 	addi	sp,sp,8
  1010d4:	f800283a 	ret

001010d8 <HIDKProbe>:
/* HID Keyboard probe. Called from USB state machine.                           */
/* assumes configuration length is less than 256 bytes                          */
/* looks for Class:03, Subclass: 01, Protocol: 01 in interface descriptor       */
/* sets keyboard in boot protocol                                               */
/* assumes single configuration, single endpoint, and interface configuration 0 */
BOOL HIDKProbe(BYTE addr, DWORD flags) {
  1010d8:	defff204 	addi	sp,sp,-56
  1010dc:	dfc00d15 	stw	ra,52(sp)
  1010e0:	df000c15 	stw	fp,48(sp)
  1010e4:	df000c04 	addi	fp,sp,48
  1010e8:	2005883a 	mov	r2,r4
  1010ec:	e17ff915 	stw	r5,-28(fp)
  1010f0:	e0bffa05 	stb	r2,-24(fp)
	BYTE tmpbyte;
	BYTE rcode;
	BYTE confvalue;
	WORD total_length;
	USB_DESCR* data_ptr = (USB_DESCR *) &bigbuf;
  1010f4:	00800074 	movhi	r2,1
  1010f8:	10853504 	addi	r2,r2,5332
  1010fc:	e0bffe15 	stw	r2,-8(fp)
	BYTE* byte_ptr = bigbuf;
  101100:	00800074 	movhi	r2,1
  101104:	10853504 	addi	r2,r2,5332
  101108:	e0bffd15 	stw	r2,-12(fp)
	rcode = XferGetConfDescr(addr, 0, CONF_DESCR_LEN, 0, bigbuf); //get configuration descriptor
  10110c:	e0fffa03 	ldbu	r3,-24(fp)
  101110:	00800074 	movhi	r2,1
  101114:	10853504 	addi	r2,r2,5332
  101118:	d8800415 	stw	r2,16(sp)
  10111c:	00800244 	movi	r2,9
  101120:	d8800315 	stw	r2,12(sp)
  101124:	d8000215 	stw	zero,8(sp)
  101128:	00800084 	movi	r2,2
  10112c:	d8800115 	stw	r2,4(sp)
  101130:	d8000015 	stw	zero,0(sp)
  101134:	01c00184 	movi	r7,6
  101138:	01802004 	movi	r6,128
  10113c:	000b883a 	mov	r5,zero
  101140:	1809883a 	mov	r4,r3
  101144:	0101e480 	call	101e48 <XferCtrlReq>
  101148:	e0bffcc5 	stb	r2,-13(fp)
	if (rcode) {   //error handling           
  10114c:	e0bffcc3 	ldbu	r2,-13(fp)
  101150:	10000226 	beq	r2,zero,10115c <HIDKProbe+0x84>
		return (FALSE);
  101154:	0005883a 	mov	r2,zero
  101158:	0000d306 	br	1014a8 <HIDKProbe+0x3d0>
	}
	if (data_ptr->descr.config.wTotalLength > 256) {
  10115c:	e0bffe17 	ldw	r2,-8(fp)
  101160:	1080008b 	ldhu	r2,2(r2)
  101164:	10bfffcc 	andi	r2,r2,65535
  101168:	10804070 	cmpltui	r2,r2,257
  10116c:	1000031e 	bne	r2,zero,10117c <HIDKProbe+0xa4>
		total_length = 256;
  101170:	00804004 	movi	r2,256
  101174:	e0bfff8d 	sth	r2,-2(fp)
  101178:	00000306 	br	101188 <HIDKProbe+0xb0>
	} else {
		total_length = data_ptr->descr.config.wTotalLength;
  10117c:	e0bffe17 	ldw	r2,-8(fp)
  101180:	1080008b 	ldhu	r2,2(r2)
  101184:	e0bfff8d 	sth	r2,-2(fp)
	}
	rcode = XferGetConfDescr(addr, 0, total_length, 0, bigbuf); //get the whole configuration
  101188:	e13ffa03 	ldbu	r4,-24(fp)
  10118c:	e0ffff8b 	ldhu	r3,-2(fp)
  101190:	00800074 	movhi	r2,1
  101194:	10853504 	addi	r2,r2,5332
  101198:	d8800415 	stw	r2,16(sp)
  10119c:	d8c00315 	stw	r3,12(sp)
  1011a0:	d8000215 	stw	zero,8(sp)
  1011a4:	00800084 	movi	r2,2
  1011a8:	d8800115 	stw	r2,4(sp)
  1011ac:	d8000015 	stw	zero,0(sp)
  1011b0:	01c00184 	movi	r7,6
  1011b4:	01802004 	movi	r6,128
  1011b8:	000b883a 	mov	r5,zero
  1011bc:	0101e480 	call	101e48 <XferCtrlReq>
  1011c0:	e0bffcc5 	stb	r2,-13(fp)
	if (rcode) {   //error handling
  1011c4:	e0bffcc3 	ldbu	r2,-13(fp)
  1011c8:	10000226 	beq	r2,zero,1011d4 <HIDKProbe+0xfc>
		return (FALSE);
  1011cc:	0005883a 	mov	r2,zero
  1011d0:	0000b506 	br	1014a8 <HIDKProbe+0x3d0>
	}
	confvalue = data_ptr->descr.config.bConfigurationValue; //save configuration value to use later
  1011d4:	e0bffe17 	ldw	r2,-8(fp)
  1011d8:	10800143 	ldbu	r2,5(r2)
  1011dc:	e0bffc85 	stb	r2,-14(fp)
	while (byte_ptr < bigbuf + total_length) {             //parse configuration
  1011e0:	0000aa06 	br	10148c <HIDKProbe+0x3b4>
		if (data_ptr->descr.config.bDescriptorType != USB_DESCRIPTOR_INTERFACE) { //skip to the next descriptor
  1011e4:	e0bffe17 	ldw	r2,-8(fp)
  1011e8:	10800043 	ldbu	r2,1(r2)
  1011ec:	10803fcc 	andi	r2,r2,255
  1011f0:	10800120 	cmpeqi	r2,r2,4
  1011f4:	1000091e 	bne	r2,zero,10121c <HIDKProbe+0x144>
			byte_ptr = byte_ptr + data_ptr->descr.config.bLength;
  1011f8:	e0bffe17 	ldw	r2,-8(fp)
  1011fc:	10800003 	ldbu	r2,0(r2)
  101200:	10803fcc 	andi	r2,r2,255
  101204:	e0fffd17 	ldw	r3,-12(fp)
  101208:	1885883a 	add	r2,r3,r2
  10120c:	e0bffd15 	stw	r2,-12(fp)
			data_ptr = (USB_DESCR*) byte_ptr;
  101210:	e0bffd17 	ldw	r2,-12(fp)
  101214:	e0bffe15 	stw	r2,-8(fp)
  101218:	00009c06 	br	10148c <HIDKProbe+0x3b4>
		} // if( data_ptr->descr.config.bDescriptorType != USB_DESCRIPTOR_INTERFACE
		else {
			//printf("starting interface parsing at byte location %d\n",
			//		data_ptr->descr.config.bLength);
			BYTE class = data_ptr->descr.interface.bInterfaceClass;
  10121c:	e0bffe17 	ldw	r2,-8(fp)
  101220:	10800143 	ldbu	r2,5(r2)
  101224:	e0bffc45 	stb	r2,-15(fp)
			BYTE subclass = data_ptr->descr.interface.bInterfaceSubClass;
  101228:	e0bffe17 	ldw	r2,-8(fp)
  10122c:	10800183 	ldbu	r2,6(r2)
  101230:	e0bffc05 	stb	r2,-16(fp)
			BYTE protocol = data_ptr->descr.interface.bInterfaceProtocol;
  101234:	e0bffe17 	ldw	r2,-8(fp)
  101238:	108001c3 	ldbu	r2,7(r2)
  10123c:	e0bffbc5 	stb	r2,-17(fp)
			//printf("class %x, subclass %x, protocol %x,\n", class, subclass,
			//		protocol);
			//interface descriptor
			if (class == HID_INTF && subclass == BOOT_INTF_SUBCLASS
  101240:	e0bffc43 	ldbu	r2,-15(fp)
  101244:	108000d8 	cmpnei	r2,r2,3
  101248:	10008e1e 	bne	r2,zero,101484 <HIDKProbe+0x3ac>
  10124c:	e0bffc03 	ldbu	r2,-16(fp)
  101250:	10800058 	cmpnei	r2,r2,1
  101254:	10008b1e 	bne	r2,zero,101484 <HIDKProbe+0x3ac>
					&& protocol == HID_PROTOCOL_KEYBOARD) {
  101258:	e0bffbc3 	ldbu	r2,-17(fp)
  10125c:	10800058 	cmpnei	r2,r2,1
  101260:	1000881e 	bne	r2,zero,101484 <HIDKProbe+0x3ac>
				//detected a keyboard
				devtable[addr].devclass = HID_K;             //fill device class
  101264:	e0bffa03 	ldbu	r2,-24(fp)
  101268:	100890fa 	slli	r4,r2,3
  10126c:	00c00044 	movi	r3,1
  101270:	00800074 	movhi	r2,1
  101274:	2085883a 	add	r2,r4,r2
  101278:	10c57605 	stb	r3,5592(r2)
				tmpbyte = devtable[addr].epinfo->MaxPktSize; //save max.packet size
  10127c:	e0bffa03 	ldbu	r2,-24(fp)
  101280:	100690fa 	slli	r3,r2,3
  101284:	00800074 	movhi	r2,1
  101288:	1885883a 	add	r2,r3,r2
  10128c:	10857517 	ldw	r2,5588(r2)
  101290:	1080008b 	ldhu	r2,2(r2)
  101294:	e0bffb85 	stb	r2,-18(fp)
				HID_init();                         //initialize data structures
  101298:	01014bc0 	call	1014bc <HID_init>
				devtable[addr].epinfo = hid_ep; //switch endpoint information structure
  10129c:	e0bffa03 	ldbu	r2,-24(fp)
  1012a0:	100890fa 	slli	r4,r2,3
  1012a4:	00c00074 	movhi	r3,1
  1012a8:	18c52b04 	addi	r3,r3,5292
  1012ac:	00800074 	movhi	r2,1
  1012b0:	2085883a 	add	r2,r4,r2
  1012b4:	10c57515 	stw	r3,5588(r2)
				devtable[addr].epinfo[0].MaxPktSize = tmpbyte; //fill in max.packet size
  1012b8:	e0bffa03 	ldbu	r2,-24(fp)
  1012bc:	100690fa 	slli	r3,r2,3
  1012c0:	00800074 	movhi	r2,1
  1012c4:	1885883a 	add	r2,r3,r2
  1012c8:	10857517 	ldw	r2,5588(r2)
  1012cc:	e0fffb83 	ldbu	r3,-18(fp)
  1012d0:	10c0008d 	sth	r3,2(r2)
				hid_device.interface =
						data_ptr->descr.interface.bInterfaceNumber; //fill in interface number to be used in HID requests
  1012d4:	e0bffe17 	ldw	r2,-8(fp)
  1012d8:	10800083 	ldbu	r2,2(r2)
				hid_device.interface =
  1012dc:	d0a01645 	stb	r2,-32679(gp)
				hid_device.addr = addr;                        //fill in address
  1012e0:	e0bffa03 	ldbu	r2,-24(fp)
  1012e4:	d0a01605 	stb	r2,-32680(gp)
				byte_ptr = byte_ptr + data_ptr->descr.config.bLength; //skip to the next descriptor
  1012e8:	e0bffe17 	ldw	r2,-8(fp)
  1012ec:	10800003 	ldbu	r2,0(r2)
  1012f0:	10803fcc 	andi	r2,r2,255
  1012f4:	e0fffd17 	ldw	r3,-12(fp)
  1012f8:	1885883a 	add	r2,r3,r2
  1012fc:	e0bffd15 	stw	r2,-12(fp)
				data_ptr = (USB_DESCR*) byte_ptr;
  101300:	e0bffd17 	ldw	r2,-12(fp)
  101304:	e0bffe15 	stw	r2,-8(fp)
				while (byte_ptr < bigbuf + total_length) {
  101308:	00005706 	br	101468 <HIDKProbe+0x390>
					if (data_ptr->descr.config.bDescriptorType
  10130c:	e0bffe17 	ldw	r2,-8(fp)
  101310:	10800043 	ldbu	r2,1(r2)
  101314:	10803fcc 	andi	r2,r2,255
  101318:	10800160 	cmpeqi	r2,r2,5
  10131c:	1000091e 	bne	r2,zero,101344 <HIDKProbe+0x26c>
							!= USB_DESCRIPTOR_ENDPOINT) { //skip to endpoint descriptor
						byte_ptr = byte_ptr + data_ptr->descr.config.bLength;
  101320:	e0bffe17 	ldw	r2,-8(fp)
  101324:	10800003 	ldbu	r2,0(r2)
  101328:	10803fcc 	andi	r2,r2,255
  10132c:	e0fffd17 	ldw	r3,-12(fp)
  101330:	1885883a 	add	r2,r3,r2
  101334:	e0bffd15 	stw	r2,-12(fp)
						data_ptr = (USB_DESCR*) byte_ptr;
  101338:	e0bffd17 	ldw	r2,-12(fp)
  10133c:	e0bffe15 	stw	r2,-8(fp)
  101340:	00004906 	br	101468 <HIDKProbe+0x390>
					} else {
						/* fill endpoint information structure */
						devtable[addr].epinfo[1].epAddr =
  101344:	e0bffa03 	ldbu	r2,-24(fp)
  101348:	100690fa 	slli	r3,r2,3
  10134c:	00800074 	movhi	r2,1
  101350:	1885883a 	add	r2,r3,r2
  101354:	10857517 	ldw	r2,5588(r2)
  101358:	10800204 	addi	r2,r2,8
								data_ptr->descr.endpoint.bEndpointAddress;
  10135c:	e0fffe17 	ldw	r3,-8(fp)
  101360:	18c00083 	ldbu	r3,2(r3)
						devtable[addr].epinfo[1].epAddr =
  101364:	10c00005 	stb	r3,0(r2)
						devtable[addr].epinfo[1].Attr =
  101368:	e0bffa03 	ldbu	r2,-24(fp)
  10136c:	100690fa 	slli	r3,r2,3
  101370:	00800074 	movhi	r2,1
  101374:	1885883a 	add	r2,r3,r2
  101378:	10857517 	ldw	r2,5588(r2)
  10137c:	10800204 	addi	r2,r2,8
								data_ptr->descr.endpoint.bmAttributes;
  101380:	e0fffe17 	ldw	r3,-8(fp)
  101384:	18c000c3 	ldbu	r3,3(r3)
						devtable[addr].epinfo[1].Attr =
  101388:	10c00045 	stb	r3,1(r2)
						devtable[addr].epinfo[1].MaxPktSize =
  10138c:	e0bffa03 	ldbu	r2,-24(fp)
  101390:	100690fa 	slli	r3,r2,3
  101394:	00800074 	movhi	r2,1
  101398:	1885883a 	add	r2,r3,r2
  10139c:	10857517 	ldw	r2,5588(r2)
  1013a0:	10800204 	addi	r2,r2,8
								data_ptr->descr.endpoint.wMaxPacketSize;
  1013a4:	e0fffe17 	ldw	r3,-8(fp)
  1013a8:	18c0010b 	ldhu	r3,4(r3)
						devtable[addr].epinfo[1].MaxPktSize =
  1013ac:	10c0008d 	sth	r3,2(r2)
						devtable[addr].epinfo[1].Interval =
  1013b0:	e0bffa03 	ldbu	r2,-24(fp)
  1013b4:	100690fa 	slli	r3,r2,3
  1013b8:	00800074 	movhi	r2,1
  1013bc:	1885883a 	add	r2,r3,r2
  1013c0:	10857517 	ldw	r2,5588(r2)
  1013c4:	10800204 	addi	r2,r2,8
								data_ptr->descr.endpoint.bInterval;
  1013c8:	e0fffe17 	ldw	r3,-8(fp)
  1013cc:	18c00183 	ldbu	r3,6(r3)
						devtable[addr].epinfo[1].Interval =
  1013d0:	10c00105 	stb	r3,4(r2)
						/* configure device */
						rcode = XferSetConf(addr, 0, confvalue); //set configuration
  1013d4:	e0fffa03 	ldbu	r3,-24(fp)
  1013d8:	e0bffc83 	ldbu	r2,-14(fp)
  1013dc:	d8000415 	stw	zero,16(sp)
  1013e0:	d8000315 	stw	zero,12(sp)
  1013e4:	d8000215 	stw	zero,8(sp)
  1013e8:	d8000115 	stw	zero,4(sp)
  1013ec:	d8800015 	stw	r2,0(sp)
  1013f0:	01c00244 	movi	r7,9
  1013f4:	000d883a 	mov	r6,zero
  1013f8:	000b883a 	mov	r5,zero
  1013fc:	1809883a 	mov	r4,r3
  101400:	0101e480 	call	101e48 <XferCtrlReq>
  101404:	e0bffcc5 	stb	r2,-13(fp)
						if (rcode) {   //error handling
  101408:	e0bffcc3 	ldbu	r2,-13(fp)
  10140c:	10000226 	beq	r2,zero,101418 <HIDKProbe+0x340>
							return (FALSE);
  101410:	0005883a 	mov	r2,zero
  101414:	00002406 	br	1014a8 <HIDKProbe+0x3d0>
						}
						rcode = XferSetProto(addr, 0, hid_device.interface,
  101418:	e0fffa03 	ldbu	r3,-24(fp)
  10141c:	d0a01643 	ldbu	r2,-32679(gp)
  101420:	10803fcc 	andi	r2,r2,255
  101424:	d8000415 	stw	zero,16(sp)
  101428:	d8000315 	stw	zero,12(sp)
  10142c:	d8800215 	stw	r2,8(sp)
  101430:	d8000115 	stw	zero,4(sp)
  101434:	d8000015 	stw	zero,0(sp)
  101438:	01c002c4 	movi	r7,11
  10143c:	01800844 	movi	r6,33
  101440:	000b883a 	mov	r5,zero
  101444:	1809883a 	mov	r4,r3
  101448:	0101e480 	call	101e48 <XferCtrlReq>
  10144c:	e0bffcc5 	stb	r2,-13(fp)
								BOOT_PROTOCOL);
						if (rcode) {   //error handling
  101450:	e0bffcc3 	ldbu	r2,-13(fp)
  101454:	10000226 	beq	r2,zero,101460 <HIDKProbe+0x388>
							return (FALSE);
  101458:	0005883a 	mov	r2,zero
  10145c:	00001206 	br	1014a8 <HIDKProbe+0x3d0>
						} else {
							return (TRUE);
  101460:	00800044 	movi	r2,1
  101464:	00001006 	br	1014a8 <HIDKProbe+0x3d0>
				while (byte_ptr < bigbuf + total_length) {
  101468:	e0ffff8b 	ldhu	r3,-2(fp)
  10146c:	00800074 	movhi	r2,1
  101470:	10853504 	addi	r2,r2,5332
  101474:	1885883a 	add	r2,r3,r2
  101478:	e0fffd17 	ldw	r3,-12(fp)
  10147c:	18bfa336 	bltu	r3,r2,10130c <HIDKProbe+0x234>
			if (class == HID_INTF && subclass == BOOT_INTF_SUBCLASS
  101480:	00000206 	br	10148c <HIDKProbe+0x3b4>
						}
					}
				}   //while( byte_ptr....
			}   //if (Class matches
			else { //if class don't match; stop processing after first interface. Not really correct
				return (FALSE);
  101484:	0005883a 	mov	r2,zero
  101488:	00000706 	br	1014a8 <HIDKProbe+0x3d0>
	while (byte_ptr < bigbuf + total_length) {             //parse configuration
  10148c:	e0ffff8b 	ldhu	r3,-2(fp)
  101490:	00800074 	movhi	r2,1
  101494:	10853504 	addi	r2,r2,5332
  101498:	1885883a 	add	r2,r3,r2
  10149c:	e0fffd17 	ldw	r3,-12(fp)
  1014a0:	18bf5036 	bltu	r3,r2,1011e4 <HIDKProbe+0x10c>
			}
		} //else if( data_ptr->
	} // while( byte_ptr < &buf + total_length
	return (FALSE);
  1014a4:	0005883a 	mov	r2,zero
}
  1014a8:	e037883a 	mov	sp,fp
  1014ac:	dfc00117 	ldw	ra,4(sp)
  1014b0:	df000017 	ldw	fp,0(sp)
  1014b4:	dec00204 	addi	sp,sp,8
  1014b8:	f800283a 	ret

001014bc <HID_init>:
/* HID data structures initialization */
void HID_init(void) {
  1014bc:	deffff04 	addi	sp,sp,-4
  1014c0:	df000015 	stw	fp,0(sp)
  1014c4:	d839883a 	mov	fp,sp
	hid_ep[1].sndToggle = bmSNDTOG0;
  1014c8:	00c01004 	movi	r3,64
  1014cc:	00800074 	movhi	r2,1
  1014d0:	10c52e45 	stb	r3,5305(r2)
	hid_ep[1].rcvToggle = bmRCVTOG0;
  1014d4:	00c00404 	movi	r3,16
  1014d8:	00800074 	movhi	r2,1
  1014dc:	10c52e85 	stb	r3,5306(r2)
}
  1014e0:	0001883a 	nop
  1014e4:	e037883a 	mov	sp,fp
  1014e8:	df000017 	ldw	fp,0(sp)
  1014ec:	dec00104 	addi	sp,sp,4
  1014f0:	f800283a 	ret

001014f4 <mousePoll>:
/* poll boot mouse */
BYTE mousePoll(BOOT_MOUSE_REPORT* buf) {
  1014f4:	defffb04 	addi	sp,sp,-20
  1014f8:	dfc00415 	stw	ra,16(sp)
  1014fc:	df000315 	stw	fp,12(sp)
  101500:	df000304 	addi	fp,sp,12
  101504:	e13ffe15 	stw	r4,-8(fp)
	BYTE rcode;
	MAXreg_wr( rPERADDR, hid_device.addr);    //set peripheral address
  101508:	d0a01603 	ldbu	r2,-32680(gp)
  10150c:	10803fcc 	andi	r2,r2,255
  101510:	100b883a 	mov	r5,r2
  101514:	01003804 	movi	r4,224
  101518:	01016dc0 	call	1016dc <MAXreg_wr>
	rcode = XferInTransfer(hid_device.addr, 1, 8, (BYTE*) buf,
  10151c:	d0a01603 	ldbu	r2,-32680(gp)
  101520:	11003fcc 	andi	r4,r2,255
			devtable[hid_device.addr].epinfo[1].MaxPktSize);
  101524:	d0a01603 	ldbu	r2,-32680(gp)
  101528:	10803fcc 	andi	r2,r2,255
  10152c:	100690fa 	slli	r3,r2,3
  101530:	00800074 	movhi	r2,1
  101534:	1885883a 	add	r2,r3,r2
  101538:	10857517 	ldw	r2,5588(r2)
  10153c:	10800204 	addi	r2,r2,8
  101540:	1080008b 	ldhu	r2,2(r2)
	rcode = XferInTransfer(hid_device.addr, 1, 8, (BYTE*) buf,
  101544:	10803fcc 	andi	r2,r2,255
  101548:	d8800015 	stw	r2,0(sp)
  10154c:	e1fffe17 	ldw	r7,-8(fp)
  101550:	01800204 	movi	r6,8
  101554:	01400044 	movi	r5,1
  101558:	01022880 	call	102288 <XferInTransfer>
  10155c:	e0bfffc5 	stb	r2,-1(fp)
	return (rcode);
  101560:	e0bfffc3 	ldbu	r2,-1(fp)
}
  101564:	e037883a 	mov	sp,fp
  101568:	dfc00117 	ldw	ra,4(sp)
  10156c:	df000017 	ldw	fp,0(sp)
  101570:	dec00204 	addi	sp,sp,8
  101574:	f800283a 	ret

00101578 <kbdPoll>:
/* poll boot keyboard */
BYTE kbdPoll(BOOT_KBD_REPORT* buf) {
  101578:	defffb04 	addi	sp,sp,-20
  10157c:	dfc00415 	stw	ra,16(sp)
  101580:	df000315 	stw	fp,12(sp)
  101584:	df000304 	addi	fp,sp,12
  101588:	e13ffe15 	stw	r4,-8(fp)
	BYTE rcode;
	MAXreg_wr( rPERADDR, hid_device.addr);    //set peripheral address
  10158c:	d0a01603 	ldbu	r2,-32680(gp)
  101590:	10803fcc 	andi	r2,r2,255
  101594:	100b883a 	mov	r5,r2
  101598:	01003804 	movi	r4,224
  10159c:	01016dc0 	call	1016dc <MAXreg_wr>
	rcode = XferInTransfer(hid_device.addr, 1, 8, (BYTE*) buf,
  1015a0:	d0a01603 	ldbu	r2,-32680(gp)
  1015a4:	11003fcc 	andi	r4,r2,255
			devtable[hid_device.addr].epinfo[1].MaxPktSize);
  1015a8:	d0a01603 	ldbu	r2,-32680(gp)
  1015ac:	10803fcc 	andi	r2,r2,255
  1015b0:	100690fa 	slli	r3,r2,3
  1015b4:	00800074 	movhi	r2,1
  1015b8:	1885883a 	add	r2,r3,r2
  1015bc:	10857517 	ldw	r2,5588(r2)
  1015c0:	10800204 	addi	r2,r2,8
  1015c4:	1080008b 	ldhu	r2,2(r2)
	rcode = XferInTransfer(hid_device.addr, 1, 8, (BYTE*) buf,
  1015c8:	10803fcc 	andi	r2,r2,255
  1015cc:	d8800015 	stw	r2,0(sp)
  1015d0:	e1fffe17 	ldw	r7,-8(fp)
  1015d4:	01800204 	movi	r6,8
  1015d8:	01400044 	movi	r5,1
  1015dc:	01022880 	call	102288 <XferInTransfer>
  1015e0:	e0bfffc5 	stb	r2,-1(fp)
	return (rcode);
  1015e4:	e0bfffc3 	ldbu	r2,-1(fp)
}
  1015e8:	e037883a 	mov	sp,fp
  1015ec:	dfc00117 	ldw	ra,4(sp)
  1015f0:	df000017 	ldw	fp,0(sp)
  1015f4:	dec00204 	addi	sp,sp,8
  1015f8:	f800283a 	ret

001015fc <HIDMEventHandler>:
BOOL HIDMEventHandler(BYTE address, BYTE event, void *data, DWORD size) {
  1015fc:	defffb04 	addi	sp,sp,-20
  101600:	df000415 	stw	fp,16(sp)
  101604:	df000404 	addi	fp,sp,16
  101608:	2005883a 	mov	r2,r4
  10160c:	2807883a 	mov	r3,r5
  101610:	e1bffd15 	stw	r6,-12(fp)
  101614:	e1fffc15 	stw	r7,-16(fp)
  101618:	e0bfff05 	stb	r2,-4(fp)
  10161c:	1805883a 	mov	r2,r3
  101620:	e0bffe05 	stb	r2,-8(fp)
	return (FALSE);
  101624:	0005883a 	mov	r2,zero
}
  101628:	e037883a 	mov	sp,fp
  10162c:	df000017 	ldw	fp,0(sp)
  101630:	dec00104 	addi	sp,sp,4
  101634:	f800283a 	ret

00101638 <HIDKEventHandler>:
BOOL HIDKEventHandler(BYTE address, BYTE event, void *data, DWORD size) {
  101638:	defffb04 	addi	sp,sp,-20
  10163c:	df000415 	stw	fp,16(sp)
  101640:	df000404 	addi	fp,sp,16
  101644:	2005883a 	mov	r2,r4
  101648:	2807883a 	mov	r3,r5
  10164c:	e1bffd15 	stw	r6,-12(fp)
  101650:	e1fffc15 	stw	r7,-16(fp)
  101654:	e0bfff05 	stb	r2,-4(fp)
  101658:	1805883a 	mov	r2,r3
  10165c:	e0bffe05 	stb	r2,-8(fp)
	return (FALSE);
  101660:	0005883a 	mov	r2,zero
}
  101664:	e037883a 	mov	sp,fp
  101668:	df000017 	ldw	fp,0(sp)
  10166c:	dec00104 	addi	sp,sp,4
  101670:	f800283a 	ret

00101674 <SPI_init>:
//variables and data structures
//External variables
extern BYTE usb_task_state;

/* Functions    */
void SPI_init(BYTE sync_mode, BYTE bus_mode, BYTE smp_phase) {
  101674:	defffc04 	addi	sp,sp,-16
  101678:	df000315 	stw	fp,12(sp)
  10167c:	df000304 	addi	fp,sp,12
  101680:	2005883a 	mov	r2,r4
  101684:	2809883a 	mov	r4,r5
  101688:	3007883a 	mov	r3,r6
  10168c:	e0bfff05 	stb	r2,-4(fp)
  101690:	2005883a 	mov	r2,r4
  101694:	e0bffe05 	stb	r2,-8(fp)
  101698:	1805883a 	mov	r2,r3
  10169c:	e0bffd05 	stb	r2,-12(fp)
	//Don't need to initialize SPI port, already ready to go with BSP
}
  1016a0:	0001883a 	nop
  1016a4:	e037883a 	mov	sp,fp
  1016a8:	df000017 	ldw	fp,0(sp)
  1016ac:	dec00104 	addi	sp,sp,4
  1016b0:	f800283a 	ret

001016b4 <SPI_wr>:

//writes single byte to MAX3421E via SPI, simultanously reads status register and returns it
BYTE SPI_wr(BYTE data) {
  1016b4:	defffe04 	addi	sp,sp,-8
  1016b8:	df000115 	stw	fp,4(sp)
  1016bc:	df000104 	addi	fp,sp,4
  1016c0:	2005883a 	mov	r2,r4
  1016c4:	e0bfff05 	stb	r2,-4(fp)
	//This function is never used by the code, so you do not need to fill it in
}
  1016c8:	0001883a 	nop
  1016cc:	e037883a 	mov	sp,fp
  1016d0:	df000017 	ldw	fp,0(sp)
  1016d4:	dec00104 	addi	sp,sp,4
  1016d8:	f800283a 	ret

001016dc <MAXreg_wr>:
//writes register to MAX3421E via SPI
void MAXreg_wr(BYTE reg, BYTE val) {
  1016dc:	defff804 	addi	sp,sp,-32
  1016e0:	dfc00715 	stw	ra,28(sp)
  1016e4:	df000615 	stw	fp,24(sp)
  1016e8:	df000604 	addi	fp,sp,24
  1016ec:	2005883a 	mov	r2,r4
  1016f0:	2807883a 	mov	r3,r5
  1016f4:	e0bffe05 	stb	r2,-8(fp)
  1016f8:	1805883a 	mov	r2,r3
  1016fc:	e0bffd05 	stb	r2,-12(fp)
	//write val via SPI
	//read return code from SPI peripheral (see Intel documentation) 
	//if return code < 0 print an error
	//deselect MAX3421E (may not be necessary if you are using SPI peripheral)
	int rcode;
	reg = reg + 2;
  101700:	e0bffe03 	ldbu	r2,-8(fp)
  101704:	10800084 	addi	r2,r2,2
  101708:	e0bffe05 	stb	r2,-8(fp)
	rcode = alt_avalon_spi_command(SPI_MASTER_BASE, 0, 1, &reg, 0, NULL, ALT_AVALON_SPI_COMMAND_MERGE);
  10170c:	d0a00317 	ldw	r2,-32756(gp)
  101710:	1009883a 	mov	r4,r2
  101714:	e0fffe04 	addi	r3,fp,-8
  101718:	00800044 	movi	r2,1
  10171c:	d8800215 	stw	r2,8(sp)
  101720:	d8000115 	stw	zero,4(sp)
  101724:	d8000015 	stw	zero,0(sp)
  101728:	180f883a 	mov	r7,r3
  10172c:	01800044 	movi	r6,1
  101730:	000b883a 	mov	r5,zero
  101734:	01046340 	call	104634 <alt_avalon_spi_command>
  101738:	e0bfff15 	stw	r2,-4(fp)
	if (rcode < 0)
  10173c:	e0bfff17 	ldw	r2,-4(fp)
  101740:	1000030e 	bge	r2,zero,101750 <MAXreg_wr+0x74>
		{
			printf("Error Writing Single Val");
  101744:	01000434 	movhi	r4,16
  101748:	211aa604 	addi	r4,r4,27288
  10174c:	0102f200 	call	102f20 <printf>
		}
	rcode = alt_avalon_spi_command(SPI_MASTER_BASE, 0, 1, &val, 0, NULL, 0);
  101750:	d0a00317 	ldw	r2,-32756(gp)
  101754:	1007883a 	mov	r3,r2
  101758:	e0bffd04 	addi	r2,fp,-12
  10175c:	d8000215 	stw	zero,8(sp)
  101760:	d8000115 	stw	zero,4(sp)
  101764:	d8000015 	stw	zero,0(sp)
  101768:	100f883a 	mov	r7,r2
  10176c:	01800044 	movi	r6,1
  101770:	000b883a 	mov	r5,zero
  101774:	1809883a 	mov	r4,r3
  101778:	01046340 	call	104634 <alt_avalon_spi_command>
  10177c:	e0bfff15 	stw	r2,-4(fp)
	if (rcode < 0)
  101780:	e0bfff17 	ldw	r2,-4(fp)
  101784:	1000030e 	bge	r2,zero,101794 <MAXreg_wr+0xb8>
	{
		printf("Error Writing Single Val");
  101788:	01000434 	movhi	r4,16
  10178c:	211aa604 	addi	r4,r4,27288
  101790:	0102f200 	call	102f20 <printf>
	}
}
  101794:	0001883a 	nop
  101798:	e037883a 	mov	sp,fp
  10179c:	dfc00117 	ldw	ra,4(sp)
  1017a0:	df000017 	ldw	fp,0(sp)
  1017a4:	dec00204 	addi	sp,sp,8
  1017a8:	f800283a 	ret

001017ac <MAXbytes_wr>:

//multiple-byte write
//returns a pointer to a memory position after last written
BYTE* MAXbytes_wr(BYTE reg, BYTE nbytes, BYTE* data) {
  1017ac:	defff704 	addi	sp,sp,-36
  1017b0:	dfc00815 	stw	ra,32(sp)
  1017b4:	df000715 	stw	fp,28(sp)
  1017b8:	df000704 	addi	fp,sp,28
  1017bc:	2005883a 	mov	r2,r4
  1017c0:	2807883a 	mov	r3,r5
  1017c4:	e1bffc15 	stw	r6,-16(fp)
  1017c8:	e0bffe05 	stb	r2,-8(fp)
  1017cc:	1805883a 	mov	r2,r3
  1017d0:	e0bffd05 	stb	r2,-12(fp)
	//read return code from SPI peripheral (see Intel documentation) 
	//if return code < 0  print an error
	//deselect MAX3421E (may not be necessary if you are using SPI peripheral)
	//return (data + nbytes);
	int rcode;
	reg = reg + 2;
  1017d4:	e0bffe03 	ldbu	r2,-8(fp)
  1017d8:	10800084 	addi	r2,r2,2
  1017dc:	e0bffe05 	stb	r2,-8(fp)
	rcode = alt_avalon_spi_command(SPI_MASTER_BASE, 0, 1, &reg, 0, NULL, ALT_AVALON_SPI_COMMAND_MERGE);
  1017e0:	d0a00317 	ldw	r2,-32756(gp)
  1017e4:	1009883a 	mov	r4,r2
  1017e8:	e0fffe04 	addi	r3,fp,-8
  1017ec:	00800044 	movi	r2,1
  1017f0:	d8800215 	stw	r2,8(sp)
  1017f4:	d8000115 	stw	zero,4(sp)
  1017f8:	d8000015 	stw	zero,0(sp)
  1017fc:	180f883a 	mov	r7,r3
  101800:	01800044 	movi	r6,1
  101804:	000b883a 	mov	r5,zero
  101808:	01046340 	call	104634 <alt_avalon_spi_command>
  10180c:	e0bfff15 	stw	r2,-4(fp)
	if (rcode < 0)
  101810:	e0bfff17 	ldw	r2,-4(fp)
  101814:	1000030e 	bge	r2,zero,101824 <MAXbytes_wr+0x78>
		{
			printf("Error Writing Multiple Data");
  101818:	01000434 	movhi	r4,16
  10181c:	211aad04 	addi	r4,r4,27316
  101820:	0102f200 	call	102f20 <printf>
		}
	rcode = alt_avalon_spi_command(SPI_MASTER_BASE, 0, nbytes, data, 0, NULL, 0);
  101824:	d0a00317 	ldw	r2,-32756(gp)
  101828:	1007883a 	mov	r3,r2
  10182c:	e0bffd03 	ldbu	r2,-12(fp)
  101830:	d8000215 	stw	zero,8(sp)
  101834:	d8000115 	stw	zero,4(sp)
  101838:	d8000015 	stw	zero,0(sp)
  10183c:	e1fffc17 	ldw	r7,-16(fp)
  101840:	100d883a 	mov	r6,r2
  101844:	000b883a 	mov	r5,zero
  101848:	1809883a 	mov	r4,r3
  10184c:	01046340 	call	104634 <alt_avalon_spi_command>
  101850:	e0bfff15 	stw	r2,-4(fp)
	if (rcode < 0)
  101854:	e0bfff17 	ldw	r2,-4(fp)
  101858:	1000030e 	bge	r2,zero,101868 <MAXbytes_wr+0xbc>
	{
		printf("Error Writing Multiple Data");
  10185c:	01000434 	movhi	r4,16
  101860:	211aad04 	addi	r4,r4,27316
  101864:	0102f200 	call	102f20 <printf>
	}
	return (data + nbytes);
  101868:	e0bffd03 	ldbu	r2,-12(fp)
  10186c:	e0fffc17 	ldw	r3,-16(fp)
  101870:	1885883a 	add	r2,r3,r2
}
  101874:	e037883a 	mov	sp,fp
  101878:	dfc00117 	ldw	ra,4(sp)
  10187c:	df000017 	ldw	fp,0(sp)
  101880:	dec00204 	addi	sp,sp,8
  101884:	f800283a 	ret

00101888 <MAXreg_rd>:

//reads register from MAX3421E via SPI
BYTE MAXreg_rd(BYTE reg) {
  101888:	defff804 	addi	sp,sp,-32
  10188c:	dfc00715 	stw	ra,28(sp)
  101890:	df000615 	stw	fp,24(sp)
  101894:	df000604 	addi	fp,sp,24
  101898:	2005883a 	mov	r2,r4
  10189c:	e0bffd05 	stb	r2,-12(fp)
	//if return code < 0 print an error
	//deselect MAX3421E (may not be necessary if you are using SPI peripheral)
	//return val
	int rcode;
	BYTE val;
	rcode = alt_avalon_spi_command(SPI_MASTER_BASE, 0, 1, &reg, 0, NULL, ALT_AVALON_SPI_COMMAND_MERGE);
  1018a0:	d0a00317 	ldw	r2,-32756(gp)
  1018a4:	1009883a 	mov	r4,r2
  1018a8:	e0fffd04 	addi	r3,fp,-12
  1018ac:	00800044 	movi	r2,1
  1018b0:	d8800215 	stw	r2,8(sp)
  1018b4:	d8000115 	stw	zero,4(sp)
  1018b8:	d8000015 	stw	zero,0(sp)
  1018bc:	180f883a 	mov	r7,r3
  1018c0:	01800044 	movi	r6,1
  1018c4:	000b883a 	mov	r5,zero
  1018c8:	01046340 	call	104634 <alt_avalon_spi_command>
  1018cc:	e0bfff15 	stw	r2,-4(fp)
	if (rcode < 0)
  1018d0:	e0bfff17 	ldw	r2,-4(fp)
  1018d4:	1000030e 	bge	r2,zero,1018e4 <MAXreg_rd+0x5c>
			{
				printf("Error Reading Data Val");
  1018d8:	01000434 	movhi	r4,16
  1018dc:	211ab404 	addi	r4,r4,27344
  1018e0:	0102f200 	call	102f20 <printf>
			}
	rcode = alt_avalon_spi_command(SPI_MASTER_BASE, 0, 0, NULL, 1, &val, 0);
  1018e4:	d0a00317 	ldw	r2,-32756(gp)
  1018e8:	1007883a 	mov	r3,r2
  1018ec:	d8000215 	stw	zero,8(sp)
  1018f0:	e0bffec4 	addi	r2,fp,-5
  1018f4:	d8800115 	stw	r2,4(sp)
  1018f8:	00800044 	movi	r2,1
  1018fc:	d8800015 	stw	r2,0(sp)
  101900:	000f883a 	mov	r7,zero
  101904:	000d883a 	mov	r6,zero
  101908:	000b883a 	mov	r5,zero
  10190c:	1809883a 	mov	r4,r3
  101910:	01046340 	call	104634 <alt_avalon_spi_command>
  101914:	e0bfff15 	stw	r2,-4(fp)
	if (rcode < 0)
  101918:	e0bfff17 	ldw	r2,-4(fp)
  10191c:	1000030e 	bge	r2,zero,10192c <MAXreg_rd+0xa4>
		{
			printf("Error Reading Data Val");
  101920:	01000434 	movhi	r4,16
  101924:	211ab404 	addi	r4,r4,27344
  101928:	0102f200 	call	102f20 <printf>
		}
	return val;
  10192c:	e0bffec3 	ldbu	r2,-5(fp)
}
  101930:	e037883a 	mov	sp,fp
  101934:	dfc00117 	ldw	ra,4(sp)
  101938:	df000017 	ldw	fp,0(sp)
  10193c:	dec00204 	addi	sp,sp,8
  101940:	f800283a 	ret

00101944 <MAXbytes_rd>:
//multiple-byte write
//returns a pointer to a memory position after last written
BYTE* MAXbytes_rd(BYTE reg, BYTE nbytes, BYTE* data) {
  101944:	defff704 	addi	sp,sp,-36
  101948:	dfc00815 	stw	ra,32(sp)
  10194c:	df000715 	stw	fp,28(sp)
  101950:	df000704 	addi	fp,sp,28
  101954:	2005883a 	mov	r2,r4
  101958:	2807883a 	mov	r3,r5
  10195c:	e1bffc15 	stw	r6,-16(fp)
  101960:	e0bffe05 	stb	r2,-8(fp)
  101964:	1805883a 	mov	r2,r3
  101968:	e0bffd05 	stb	r2,-12(fp)
	//if return code < 0 print an error
	//deselect MAX3421E (may not be necessary if you are using SPI peripheral)
	//return (data + nbytes);
	//dereference reg and data
	int rcode;
	rcode = alt_avalon_spi_command(SPI_MASTER_BASE, 0, 1, &reg, 0, NULL, ALT_AVALON_SPI_COMMAND_MERGE);
  10196c:	d0a00317 	ldw	r2,-32756(gp)
  101970:	1009883a 	mov	r4,r2
  101974:	e0fffe04 	addi	r3,fp,-8
  101978:	00800044 	movi	r2,1
  10197c:	d8800215 	stw	r2,8(sp)
  101980:	d8000115 	stw	zero,4(sp)
  101984:	d8000015 	stw	zero,0(sp)
  101988:	180f883a 	mov	r7,r3
  10198c:	01800044 	movi	r6,1
  101990:	000b883a 	mov	r5,zero
  101994:	01046340 	call	104634 <alt_avalon_spi_command>
  101998:	e0bfff15 	stw	r2,-4(fp)
	if (rcode < 0)
  10199c:	e0bfff17 	ldw	r2,-4(fp)
  1019a0:	1000030e 	bge	r2,zero,1019b0 <MAXbytes_rd+0x6c>
		{
			printf("Error Reading Multiple Data");
  1019a4:	01000434 	movhi	r4,16
  1019a8:	211aba04 	addi	r4,r4,27368
  1019ac:	0102f200 	call	102f20 <printf>
		}
	rcode = alt_avalon_spi_command(SPI_MASTER_BASE, 0, 0, NULL, nbytes, data, 0);
  1019b0:	d0a00317 	ldw	r2,-32756(gp)
  1019b4:	1009883a 	mov	r4,r2
  1019b8:	e0bffd03 	ldbu	r2,-12(fp)
  1019bc:	d8000215 	stw	zero,8(sp)
  1019c0:	e0fffc17 	ldw	r3,-16(fp)
  1019c4:	d8c00115 	stw	r3,4(sp)
  1019c8:	d8800015 	stw	r2,0(sp)
  1019cc:	000f883a 	mov	r7,zero
  1019d0:	000d883a 	mov	r6,zero
  1019d4:	000b883a 	mov	r5,zero
  1019d8:	01046340 	call	104634 <alt_avalon_spi_command>
  1019dc:	e0bfff15 	stw	r2,-4(fp)
	if (rcode < 0)
  1019e0:	e0bfff17 	ldw	r2,-4(fp)
  1019e4:	1000030e 	bge	r2,zero,1019f4 <MAXbytes_rd+0xb0>
	{
		printf("Error Reading Multiple Data");
  1019e8:	01000434 	movhi	r4,16
  1019ec:	211aba04 	addi	r4,r4,27368
  1019f0:	0102f200 	call	102f20 <printf>
	}
	return (data + nbytes);
  1019f4:	e0bffd03 	ldbu	r2,-12(fp)
  1019f8:	e0fffc17 	ldw	r3,-16(fp)
  1019fc:	1885883a 	add	r2,r3,r2
}
  101a00:	e037883a 	mov	sp,fp
  101a04:	dfc00117 	ldw	ra,4(sp)
  101a08:	df000017 	ldw	fp,0(sp)
  101a0c:	dec00204 	addi	sp,sp,8
  101a10:	f800283a 	ret

00101a14 <MAX3421E_reset>:
/* reset MAX3421E using chip reset bit. SPI configuration is not affected   */
void MAX3421E_reset(void) {
  101a14:	defffd04 	addi	sp,sp,-12
  101a18:	dfc00215 	stw	ra,8(sp)
  101a1c:	df000115 	stw	fp,4(sp)
  101a20:	df000104 	addi	fp,sp,4
	//hardware reset, then software reset
	IOWR_ALTERA_AVALON_PIO_DATA(USB_RST_BASE, 0);
  101a24:	0005883a 	mov	r2,zero
  101a28:	00807435 	stwio	r2,464(zero)
	usleep(1000000);
  101a2c:	010003f4 	movhi	r4,15
  101a30:	21109004 	addi	r4,r4,16960
  101a34:	01039840 	call	103984 <usleep>
	IOWR_ALTERA_AVALON_PIO_DATA(USB_RST_BASE, 1);
  101a38:	00800044 	movi	r2,1
  101a3c:	00807435 	stwio	r2,464(zero)
	BYTE tmp = 0;
  101a40:	e03fffc5 	stb	zero,-1(fp)
	MAXreg_wr( rUSBCTL, bmCHIPRES);      //Chip reset. This stops the oscillator
  101a44:	01400804 	movi	r5,32
  101a48:	01001e04 	movi	r4,120
  101a4c:	01016dc0 	call	1016dc <MAXreg_wr>
	MAXreg_wr( rUSBCTL, 0x00);                          //Remove the reset
  101a50:	000b883a 	mov	r5,zero
  101a54:	01001e04 	movi	r4,120
  101a58:	01016dc0 	call	1016dc <MAXreg_wr>
	while (!(MAXreg_rd( rUSBIRQ) & bmOSCOKIRQ)) { //wait until the PLL stabilizes
  101a5c:	00000806 	br	101a80 <MAX3421E_reset+0x6c>
		tmp++;                                      //timeout after 256 attempts
  101a60:	e0bfffc3 	ldbu	r2,-1(fp)
  101a64:	10800044 	addi	r2,r2,1
  101a68:	e0bfffc5 	stb	r2,-1(fp)
		if (tmp == 0) {
  101a6c:	e0bfffc3 	ldbu	r2,-1(fp)
  101a70:	1000031e 	bne	r2,zero,101a80 <MAX3421E_reset+0x6c>
			printf("reset timeout!");
  101a74:	01000434 	movhi	r4,16
  101a78:	211ac104 	addi	r4,r4,27396
  101a7c:	0102f200 	call	102f20 <printf>
	while (!(MAXreg_rd( rUSBIRQ) & bmOSCOKIRQ)) { //wait until the PLL stabilizes
  101a80:	01001a04 	movi	r4,104
  101a84:	01018880 	call	101888 <MAXreg_rd>
  101a88:	10803fcc 	andi	r2,r2,255
  101a8c:	1080004c 	andi	r2,r2,1
  101a90:	103ff326 	beq	r2,zero,101a60 <MAX3421E_reset+0x4c>
		}
	}
}
  101a94:	0001883a 	nop
  101a98:	e037883a 	mov	sp,fp
  101a9c:	dfc00117 	ldw	ra,4(sp)
  101aa0:	df000017 	ldw	fp,0(sp)
  101aa4:	dec00204 	addi	sp,sp,8
  101aa8:	f800283a 	ret

00101aac <Vbus_power>:
/* turn USB power on/off                                                */
/* ON pin of VBUS switch (MAX4793 or similar) is connected to GPOUT7    */
/* OVERLOAD pin of Vbus switch is connected to GPIN7                    */
/* OVERLOAD state low. NO OVERLOAD or VBUS OFF state high.              */
BOOL Vbus_power(BOOL action) {
  101aac:	defffe04 	addi	sp,sp,-8
  101ab0:	df000115 	stw	fp,4(sp)
  101ab4:	df000104 	addi	fp,sp,4
  101ab8:	e13fff15 	stw	r4,-4(fp)
	// power on/off successful
	return (1);
  101abc:	00800044 	movi	r2,1
}
  101ac0:	e037883a 	mov	sp,fp
  101ac4:	df000017 	ldw	fp,0(sp)
  101ac8:	dec00104 	addi	sp,sp,4
  101acc:	f800283a 	ret

00101ad0 <MAX_busprobe>:

/* probe bus to determine device presense and speed */
void MAX_busprobe(void) {
  101ad0:	defffd04 	addi	sp,sp,-12
  101ad4:	dfc00215 	stw	ra,8(sp)
  101ad8:	df000115 	stw	fp,4(sp)
  101adc:	df000104 	addi	fp,sp,4
	BYTE bus_sample;

//  MAXreg_wr(rHCTL,bmSAMPLEBUS);
	bus_sample = MAXreg_rd( rHRSL);            //Get J,K status
  101ae0:	01003e04 	movi	r4,248
  101ae4:	01018880 	call	101888 <MAXreg_rd>
  101ae8:	e0bfffc5 	stb	r2,-1(fp)
	bus_sample &= ( bmJSTATUS | bmKSTATUS);      //zero the rest of the byte
  101aec:	e0ffffc3 	ldbu	r3,-1(fp)
  101af0:	00bff004 	movi	r2,-64
  101af4:	1884703a 	and	r2,r3,r2
  101af8:	e0bfffc5 	stb	r2,-1(fp)

	switch (bus_sample) {                   //start full-speed or low-speed host
  101afc:	e0bfffc3 	ldbu	r2,-1(fp)
  101b00:	10c01020 	cmpeqi	r3,r2,64
  101b04:	1800221e 	bne	r3,zero,101b90 <MAX_busprobe+0xc0>
  101b08:	10c01048 	cmpgei	r3,r2,65
  101b0c:	1800021e 	bne	r3,zero,101b18 <MAX_busprobe+0x48>
  101b10:	10003b26 	beq	r2,zero,101c00 <MAX_busprobe+0x130>
			MAXreg_wr( rMODE, MODE_FS_HOST); //start full-speed host
			usb_task_state = ( USB_DETACHED_SUBSTATE_WAIT_FOR_DEVICE);
		}
		break;
	} //end switch( bus_sample )
}
  101b14:	00004a06 	br	101c40 <MAX_busprobe+0x170>
	switch (bus_sample) {                   //start full-speed or low-speed host
  101b18:	10c02020 	cmpeqi	r3,r2,128
  101b1c:	1800031e 	bne	r3,zero,101b2c <MAX_busprobe+0x5c>
  101b20:	10803020 	cmpeqi	r2,r2,192
  101b24:	1000331e 	bne	r2,zero,101bf4 <MAX_busprobe+0x124>
}
  101b28:	00004506 	br	101c40 <MAX_busprobe+0x170>
		if (usb_task_state != USB_ATTACHED_SUBSTATE_WAIT_RESET_COMPLETE) { //bus reset causes connection detect interrupt
  101b2c:	d0a00603 	ldbu	r2,-32744(gp)
  101b30:	10803fcc 	andi	r2,r2,255
  101b34:	108004e0 	cmpeqi	r2,r2,19
  101b38:	10003e1e 	bne	r2,zero,101c34 <MAX_busprobe+0x164>
			if (!(MAXreg_rd( rMODE) & bmLOWSPEED)) {
  101b3c:	01003604 	movi	r4,216
  101b40:	01018880 	call	101888 <MAXreg_rd>
  101b44:	10803fcc 	andi	r2,r2,255
  101b48:	1080008c 	andi	r2,r2,2
  101b4c:	1000071e 	bne	r2,zero,101b6c <MAX_busprobe+0x9c>
				MAXreg_wr( rMODE, MODE_FS_HOST);         //start full-speed host
  101b50:	01403244 	movi	r5,201
  101b54:	01003604 	movi	r4,216
  101b58:	01016dc0 	call	1016dc <MAXreg_wr>
				printf("Starting in full speed\n");
  101b5c:	01000434 	movhi	r4,16
  101b60:	211ac504 	addi	r4,r4,27412
  101b64:	01030100 	call	103010 <puts>
  101b68:	00000606 	br	101b84 <MAX_busprobe+0xb4>
				MAXreg_wr( rMODE, MODE_LS_HOST);    //start low-speed host
  101b6c:	014032c4 	movi	r5,203
  101b70:	01003604 	movi	r4,216
  101b74:	01016dc0 	call	1016dc <MAXreg_wr>
				printf("Starting in low speed\n");
  101b78:	01000434 	movhi	r4,16
  101b7c:	211acb04 	addi	r4,r4,27436
  101b80:	01030100 	call	103010 <puts>
			usb_task_state = ( USB_STATE_ATTACHED); //signal usb state machine to start attachment sequence
  101b84:	00800404 	movi	r2,16
  101b88:	d0a00605 	stb	r2,-32744(gp)
		break;
  101b8c:	00002906 	br	101c34 <MAX_busprobe+0x164>
		if (usb_task_state != USB_ATTACHED_SUBSTATE_WAIT_RESET_COMPLETE) { //bus reset causes connection detect interrupt
  101b90:	d0a00603 	ldbu	r2,-32744(gp)
  101b94:	10803fcc 	andi	r2,r2,255
  101b98:	108004e0 	cmpeqi	r2,r2,19
  101b9c:	1000271e 	bne	r2,zero,101c3c <MAX_busprobe+0x16c>
			if (!(MAXreg_rd( rMODE) & bmLOWSPEED)) {
  101ba0:	01003604 	movi	r4,216
  101ba4:	01018880 	call	101888 <MAXreg_rd>
  101ba8:	10803fcc 	andi	r2,r2,255
  101bac:	1080008c 	andi	r2,r2,2
  101bb0:	1000071e 	bne	r2,zero,101bd0 <MAX_busprobe+0x100>
				MAXreg_wr( rMODE, MODE_LS_HOST);   //start low-speed host
  101bb4:	014032c4 	movi	r5,203
  101bb8:	01003604 	movi	r4,216
  101bbc:	01016dc0 	call	1016dc <MAXreg_wr>
				printf("Starting in low speed\n");
  101bc0:	01000434 	movhi	r4,16
  101bc4:	211acb04 	addi	r4,r4,27436
  101bc8:	01030100 	call	103010 <puts>
  101bcc:	00000606 	br	101be8 <MAX_busprobe+0x118>
				MAXreg_wr( rMODE, MODE_FS_HOST);         //start full-speed host
  101bd0:	01403244 	movi	r5,201
  101bd4:	01003604 	movi	r4,216
  101bd8:	01016dc0 	call	1016dc <MAXreg_wr>
				printf("Starting in full speed\n");
  101bdc:	01000434 	movhi	r4,16
  101be0:	211ac504 	addi	r4,r4,27412
  101be4:	01030100 	call	103010 <puts>
			usb_task_state = ( USB_STATE_ATTACHED); //signal usb state machine to start attachment sequence
  101be8:	00800404 	movi	r2,16
  101bec:	d0a00605 	stb	r2,-32744(gp)
		break;
  101bf0:	00001206 	br	101c3c <MAX_busprobe+0x16c>
		usb_task_state = ( USB_DETACHED_SUBSTATE_ILLEGAL);
  101bf4:	00800104 	movi	r2,4
  101bf8:	d0a00605 	stb	r2,-32744(gp)
		break;
  101bfc:	00001006 	br	101c40 <MAX_busprobe+0x170>
		if (!((usb_task_state & USB_STATE_MASK) == USB_STATE_DETACHED)) //if we came here from other than detached state
  101c00:	d0a00603 	ldbu	r2,-32744(gp)
  101c04:	10803fcc 	andi	r2,r2,255
  101c08:	10803c0c 	andi	r2,r2,240
  101c0c:	10000326 	beq	r2,zero,101c1c <MAX_busprobe+0x14c>
			usb_task_state = ( USB_DETACHED_SUBSTATE_INITIALIZE); //clear device data structures
  101c10:	00800044 	movi	r2,1
  101c14:	d0a00605 	stb	r2,-32744(gp)
		break;
  101c18:	00000906 	br	101c40 <MAX_busprobe+0x170>
			MAXreg_wr( rMODE, MODE_FS_HOST); //start full-speed host
  101c1c:	01403244 	movi	r5,201
  101c20:	01003604 	movi	r4,216
  101c24:	01016dc0 	call	1016dc <MAXreg_wr>
			usb_task_state = ( USB_DETACHED_SUBSTATE_WAIT_FOR_DEVICE);
  101c28:	008000c4 	movi	r2,3
  101c2c:	d0a00605 	stb	r2,-32744(gp)
		break;
  101c30:	00000306 	br	101c40 <MAX_busprobe+0x170>
		break;
  101c34:	0001883a 	nop
  101c38:	00000106 	br	101c40 <MAX_busprobe+0x170>
		break;
  101c3c:	0001883a 	nop
}
  101c40:	0001883a 	nop
  101c44:	e037883a 	mov	sp,fp
  101c48:	dfc00117 	ldw	ra,4(sp)
  101c4c:	df000017 	ldw	fp,0(sp)
  101c50:	dec00204 	addi	sp,sp,8
  101c54:	f800283a 	ret

00101c58 <MAX3421E_init>:
/* MAX3421E initialization after power-on   */
void MAX3421E_init(void) {
  101c58:	defffe04 	addi	sp,sp,-8
  101c5c:	dfc00115 	stw	ra,4(sp)
  101c60:	df000015 	stw	fp,0(sp)
  101c64:	d839883a 	mov	fp,sp
	/* Configure full-duplex SPI, interrupt pulse   */
	MAXreg_wr( rPINCTL, (bmFDUPSPI + bmINTLEVEL + bmGPXB)); //Full-duplex SPI, level interrupt, GPX
  101c68:	01400684 	movi	r5,26
  101c6c:	01002204 	movi	r4,136
  101c70:	01016dc0 	call	1016dc <MAXreg_wr>
	MAX3421E_reset();                                //stop/start the oscillator
  101c74:	0101a140 	call	101a14 <MAX3421E_reset>
	/* configure power switch   */
	Vbus_power( OFF);                                      //turn Vbus power off
  101c78:	0009883a 	mov	r4,zero
  101c7c:	0101aac0 	call	101aac <Vbus_power>
	MAXreg_wr( rGPINIEN, bmGPINIEN7); //enable interrupt on GPIN7 (power switch overload flag)
  101c80:	01402004 	movi	r5,128
  101c84:	01002e04 	movi	r4,184
  101c88:	01016dc0 	call	1016dc <MAXreg_wr>
	Vbus_power( ON);
  101c8c:	01000044 	movi	r4,1
  101c90:	0101aac0 	call	101aac <Vbus_power>
	/* configure host operation */
	MAXreg_wr( rMODE, bmDPPULLDN | bmDMPULLDN | bmHOST | bmSEPIRQ); // set pull-downs, SOF, Host, Separate GPIN IRQ on GPX
  101c94:	01403444 	movi	r5,209
  101c98:	01003604 	movi	r4,216
  101c9c:	01016dc0 	call	1016dc <MAXreg_wr>
	//MAXreg_wr( rHIEN, bmFRAMEIE|bmCONDETIE|bmBUSEVENTIE );                      // enable SOF, connection detection, bus event IRQs
	MAXreg_wr( rHIEN, bmCONDETIE);                        //connection detection
  101ca0:	01400804 	movi	r5,32
  101ca4:	01003404 	movi	r4,208
  101ca8:	01016dc0 	call	1016dc <MAXreg_wr>
	/* HXFRDNIRQ is checked in Dispatch packet function */
	MAXreg_wr(rHCTL, bmSAMPLEBUS);        // update the JSTATUS and KSTATUS bits
  101cac:	01400104 	movi	r5,4
  101cb0:	01003a04 	movi	r4,232
  101cb4:	01016dc0 	call	1016dc <MAXreg_wr>
	MAX_busprobe();                             //check if anything is connected
  101cb8:	0101ad00 	call	101ad0 <MAX_busprobe>
	MAXreg_wr( rHIRQ, bmCONDETIRQ); //clear connection detect interrupt                 
  101cbc:	01400804 	movi	r5,32
  101cc0:	01003204 	movi	r4,200
  101cc4:	01016dc0 	call	1016dc <MAXreg_wr>
	MAXreg_wr( rCPUCTL, 0x01);                            //enable interrupt pin
  101cc8:	01400044 	movi	r5,1
  101ccc:	01002004 	movi	r4,128
  101cd0:	01016dc0 	call	1016dc <MAXreg_wr>
}
  101cd4:	0001883a 	nop
  101cd8:	e037883a 	mov	sp,fp
  101cdc:	dfc00117 	ldw	ra,4(sp)
  101ce0:	df000017 	ldw	fp,0(sp)
  101ce4:	dec00204 	addi	sp,sp,8
  101ce8:	f800283a 	ret

00101cec <MAX3421E_Task>:

/* MAX3421 state change task and interrupt handler */
void MAX3421E_Task(void) {
  101cec:	defffe04 	addi	sp,sp,-8
  101cf0:	dfc00115 	stw	ra,4(sp)
  101cf4:	df000015 	stw	fp,0(sp)
  101cf8:	d839883a 	mov	fp,sp
	if ( IORD_ALTERA_AVALON_PIO_DATA(USB_IRQ_BASE) == 0) {
  101cfc:	00807c37 	ldwio	r2,496(zero)
  101d00:	1000041e 	bne	r2,zero,101d14 <MAX3421E_Task+0x28>
		printf("MAX interrupt\n\r");
  101d04:	01000434 	movhi	r4,16
  101d08:	211ad104 	addi	r4,r4,27460
  101d0c:	0102f200 	call	102f20 <printf>
		MaxIntHandler();
  101d10:	0101d480 	call	101d48 <MaxIntHandler>
	}
	if ( IORD_ALTERA_AVALON_PIO_DATA(USB_GPX_BASE) == 1) {
  101d14:	00807837 	ldwio	r2,480(zero)
  101d18:	10800058 	cmpnei	r2,r2,1
  101d1c:	1000041e 	bne	r2,zero,101d30 <MAX3421E_Task+0x44>
		printf("GPX interrupt\n\r");
  101d20:	01000434 	movhi	r4,16
  101d24:	211ad504 	addi	r4,r4,27476
  101d28:	0102f200 	call	102f20 <printf>
		MaxGpxHandler();
  101d2c:	0101e140 	call	101e14 <MaxGpxHandler>
	}
}
  101d30:	0001883a 	nop
  101d34:	e037883a 	mov	sp,fp
  101d38:	dfc00117 	ldw	ra,4(sp)
  101d3c:	df000017 	ldw	fp,0(sp)
  101d40:	dec00204 	addi	sp,sp,8
  101d44:	f800283a 	ret

00101d48 <MaxIntHandler>:

void MaxIntHandler(void) {
  101d48:	defffd04 	addi	sp,sp,-12
  101d4c:	dfc00215 	stw	ra,8(sp)
  101d50:	df000115 	stw	fp,4(sp)
  101d54:	df000104 	addi	fp,sp,4
	BYTE HIRQ;
	BYTE HIRQ_sendback = 0x00;
  101d58:	e03fffc5 	stb	zero,-1(fp)
	HIRQ = MAXreg_rd( rHIRQ);                  //determine interrupt source
  101d5c:	01003204 	movi	r4,200
  101d60:	01018880 	call	101888 <MAXreg_rd>
  101d64:	e0bfff85 	stb	r2,-2(fp)
	printf("IRQ: %x\n", HIRQ);
  101d68:	e0bfff83 	ldbu	r2,-2(fp)
  101d6c:	100b883a 	mov	r5,r2
  101d70:	01000434 	movhi	r4,16
  101d74:	211ad904 	addi	r4,r4,27492
  101d78:	0102f200 	call	102f20 <printf>
	if (HIRQ & bmFRAMEIRQ) {                   //->1ms SOF interrupt handler
  101d7c:	e0bfff83 	ldbu	r2,-2(fp)
  101d80:	1080100c 	andi	r2,r2,64
  101d84:	10000326 	beq	r2,zero,101d94 <MaxIntHandler+0x4c>
		HIRQ_sendback |= bmFRAMEIRQ;
  101d88:	e0bfffc3 	ldbu	r2,-1(fp)
  101d8c:	10801014 	ori	r2,r2,64
  101d90:	e0bfffc5 	stb	r2,-1(fp)
	}                   //end FRAMEIRQ handling

	if (HIRQ & bmCONDETIRQ) {
  101d94:	e0bfff83 	ldbu	r2,-2(fp)
  101d98:	1080080c 	andi	r2,r2,32
  101d9c:	10000426 	beq	r2,zero,101db0 <MaxIntHandler+0x68>
		MAX_busprobe();
  101da0:	0101ad00 	call	101ad0 <MAX_busprobe>
		HIRQ_sendback |= bmCONDETIRQ;      //set sendback to 1 to clear register
  101da4:	e0bfffc3 	ldbu	r2,-1(fp)
  101da8:	10800814 	ori	r2,r2,32
  101dac:	e0bfffc5 	stb	r2,-1(fp)
	}
	if (HIRQ & bmSNDBAVIRQ) //if the send buffer is clear (previous transfer completed without issue)
  101db0:	e0bfff83 	ldbu	r2,-2(fp)
  101db4:	1080020c 	andi	r2,r2,8
  101db8:	10000326 	beq	r2,zero,101dc8 <MaxIntHandler+0x80>
	{
		MAXreg_wr(rSNDBC, 0x00);//clear the send buffer (not really necessary, but clears interrupt)
  101dbc:	000b883a 	mov	r5,zero
  101dc0:	01000e04 	movi	r4,56
  101dc4:	01016dc0 	call	1016dc <MAXreg_wr>
	}
	if (HIRQ & bmBUSEVENTIRQ) {           //bus event is either reset or suspend
  101dc8:	e0bfff83 	ldbu	r2,-2(fp)
  101dcc:	1080004c 	andi	r2,r2,1
  101dd0:	10000626 	beq	r2,zero,101dec <MaxIntHandler+0xa4>
		usb_task_state++;                       //advance USB task state machine
  101dd4:	d0a00603 	ldbu	r2,-32744(gp)
  101dd8:	10800044 	addi	r2,r2,1
  101ddc:	d0a00605 	stb	r2,-32744(gp)
		HIRQ_sendback |= bmBUSEVENTIRQ;
  101de0:	e0bfffc3 	ldbu	r2,-1(fp)
  101de4:	10800054 	ori	r2,r2,1
  101de8:	e0bfffc5 	stb	r2,-1(fp)
	}
	/* End HIRQ interrupts handling, clear serviced IRQs    */
	MAXreg_wr( rHIRQ, HIRQ_sendback); //write '1' to CONDETIRQ to ack bus state change
  101dec:	e0bfffc3 	ldbu	r2,-1(fp)
  101df0:	100b883a 	mov	r5,r2
  101df4:	01003204 	movi	r4,200
  101df8:	01016dc0 	call	1016dc <MAXreg_wr>
}
  101dfc:	0001883a 	nop
  101e00:	e037883a 	mov	sp,fp
  101e04:	dfc00117 	ldw	ra,4(sp)
  101e08:	df000017 	ldw	fp,0(sp)
  101e0c:	dec00204 	addi	sp,sp,8
  101e10:	f800283a 	ret

00101e14 <MaxGpxHandler>:

void MaxGpxHandler(void) {
  101e14:	defffd04 	addi	sp,sp,-12
  101e18:	dfc00215 	stw	ra,8(sp)
  101e1c:	df000115 	stw	fp,4(sp)
  101e20:	df000104 	addi	fp,sp,4
	BYTE GPINIRQ;
	GPINIRQ = MAXreg_rd( rGPINIRQ);            //read both IRQ registers
  101e24:	01002c04 	movi	r4,176
  101e28:	01018880 	call	101888 <MAXreg_rd>
  101e2c:	e0bfffc5 	stb	r2,-1(fp)
}
  101e30:	0001883a 	nop
  101e34:	e037883a 	mov	sp,fp
  101e38:	dfc00117 	ldw	ra,4(sp)
  101e3c:	df000017 	ldw	fp,0(sp)
  101e40:	dec00204 	addi	sp,sp,8
  101e44:	f800283a 	ret

00101e48 <XferCtrlReq>:
/* depending on request. Actual requests are defined as macros                                                                                      */
/* return codes:                */
/* 00       =   success         */
/* 01-0f    =   non-zero HRSLT  */
BYTE XferCtrlReq( BYTE addr, BYTE ep, BYTE bmReqType, BYTE bRequest, BYTE wValLo, BYTE wValHi, WORD wInd, WORD nbytes, BYTE* dataptr )
{
  101e48:	defff104 	addi	sp,sp,-60
  101e4c:	dfc00e15 	stw	ra,56(sp)
  101e50:	df000d15 	stw	fp,52(sp)
  101e54:	df000d04 	addi	fp,sp,52
  101e58:	2015883a 	mov	r10,r4
  101e5c:	2813883a 	mov	r9,r5
  101e60:	3011883a 	mov	r8,r6
  101e64:	e1400217 	ldw	r5,8(fp)
  101e68:	e1000317 	ldw	r4,12(fp)
  101e6c:	e0c00417 	ldw	r3,16(fp)
  101e70:	e0800517 	ldw	r2,20(fp)
  101e74:	500d883a 	mov	r6,r10
  101e78:	e1bffb05 	stb	r6,-20(fp)
  101e7c:	480d883a 	mov	r6,r9
  101e80:	e1bffa05 	stb	r6,-24(fp)
  101e84:	400d883a 	mov	r6,r8
  101e88:	e1bff905 	stb	r6,-28(fp)
  101e8c:	380d883a 	mov	r6,r7
  101e90:	e1bff805 	stb	r6,-32(fp)
  101e94:	e17ff705 	stb	r5,-36(fp)
  101e98:	e13ff605 	stb	r4,-40(fp)
  101e9c:	e0fff50d 	sth	r3,-44(fp)
  101ea0:	e0bff40d 	sth	r2,-48(fp)
 BOOL direction = FALSE;        //request direction, IN or OUT
  101ea4:	e03fff15 	stw	zero,-4(fp)
 BYTE datastage = 1; //request data stage present or absent
  101ea8:	00800044 	movi	r2,1
  101eac:	e0bffec5 	stb	r2,-5(fp)
 BYTE rcode;
 SETUP_PKT setup_pkt;
    if( dataptr == NULL ) {
  101eb0:	e0800617 	ldw	r2,24(fp)
  101eb4:	1000011e 	bne	r2,zero,101ebc <XferCtrlReq+0x74>
        datastage = 0;
  101eb8:	e03ffec5 	stb	zero,-5(fp)
    }
    MAXreg_wr( rPERADDR, addr );                    //set peripheral address
  101ebc:	e0bffb03 	ldbu	r2,-20(fp)
  101ec0:	100b883a 	mov	r5,r2
  101ec4:	01003804 	movi	r4,224
  101ec8:	01016dc0 	call	1016dc <MAXreg_wr>
    /* fill in setup packet */
    if( bmReqType & 0x80 ) {
  101ecc:	e0bff903 	ldbu	r2,-28(fp)
  101ed0:	10803fcc 	andi	r2,r2,255
  101ed4:	1080201c 	xori	r2,r2,128
  101ed8:	10bfe004 	addi	r2,r2,-128
  101edc:	1000020e 	bge	r2,zero,101ee8 <XferCtrlReq+0xa0>
        direction = TRUE;                   		//determine request direction
  101ee0:	00800044 	movi	r2,1
  101ee4:	e0bfff15 	stw	r2,-4(fp)
    }
    /* fill in setup packet */
    setup_pkt.ReqType_u.bmRequestType = bmReqType;
  101ee8:	e0bff903 	ldbu	r2,-28(fp)
  101eec:	e0bffc85 	stb	r2,-14(fp)
    setup_pkt.bRequest = bRequest;
  101ef0:	e0bff803 	ldbu	r2,-32(fp)
  101ef4:	e0bffcc5 	stb	r2,-13(fp)
    setup_pkt.wVal_u.wValueLo = wValLo;
  101ef8:	e0bff703 	ldbu	r2,-36(fp)
  101efc:	e0bffd05 	stb	r2,-12(fp)
    setup_pkt.wVal_u.wValueHi = wValHi;
  101f00:	e0bff603 	ldbu	r2,-40(fp)
  101f04:	e0bffd45 	stb	r2,-11(fp)
    setup_pkt.wIndex = wInd;
  101f08:	e0bff50b 	ldhu	r2,-44(fp)
  101f0c:	e0bffd8d 	sth	r2,-10(fp)
    setup_pkt.wLength = nbytes;
  101f10:	e0bff40b 	ldhu	r2,-48(fp)
  101f14:	e0bffe0d 	sth	r2,-8(fp)
    MAXbytes_wr( rSUDFIFO, 8, (BYTE *)&setup_pkt );     //transfer to setup packet FIFO
  101f18:	e0bffc84 	addi	r2,fp,-14
  101f1c:	100d883a 	mov	r6,r2
  101f20:	01400204 	movi	r5,8
  101f24:	01000804 	movi	r4,32
  101f28:	01017ac0 	call	1017ac <MAXbytes_wr>
    rcode = XferDispatchPkt( tokSETUP, ep );            //dispatch packet
  101f2c:	e0bffa03 	ldbu	r2,-24(fp)
  101f30:	100b883a 	mov	r5,r2
  101f34:	01000404 	movi	r4,16
  101f38:	01021080 	call	102108 <XferDispatchPkt>
  101f3c:	e0bffe85 	stb	r2,-6(fp)
    if( rcode ) {                                       //return HRSLT if not zero
  101f40:	e0bffe83 	ldbu	r2,-6(fp)
  101f44:	10000226 	beq	r2,zero,101f50 <XferCtrlReq+0x108>
        return( rcode );
  101f48:	e0bffe83 	ldbu	r2,-6(fp)
  101f4c:	00000e06 	br	101f88 <XferCtrlReq+0x140>
    }
    rcode = ctrl_xfers[ datastage ]( addr, ep, nbytes, dataptr, direction );    //call data stage or no data stage transfer
  101f50:	e0bffec3 	ldbu	r2,-5(fp)
  101f54:	100690ba 	slli	r3,r2,2
  101f58:	d0a00404 	addi	r2,gp,-32752
  101f5c:	1885883a 	add	r2,r3,r2
  101f60:	10800017 	ldw	r2,0(r2)
  101f64:	e13ffb03 	ldbu	r4,-20(fp)
  101f68:	e17ffa03 	ldbu	r5,-24(fp)
  101f6c:	e1bff40b 	ldhu	r6,-48(fp)
  101f70:	e0ffff17 	ldw	r3,-4(fp)
  101f74:	d8c00015 	stw	r3,0(sp)
  101f78:	e1c00617 	ldw	r7,24(fp)
  101f7c:	103ee83a 	callr	r2
  101f80:	e0bffe85 	stb	r2,-6(fp)
    return( rcode );
  101f84:	e0bffe83 	ldbu	r2,-6(fp)
}
  101f88:	e037883a 	mov	sp,fp
  101f8c:	dfc00117 	ldw	ra,4(sp)
  101f90:	df000017 	ldw	fp,0(sp)
  101f94:	dec00204 	addi	sp,sp,8
  101f98:	f800283a 	ret

00101f9c <XferCtrlData>:
/* Control transfer with data stage */
BYTE XferCtrlData( BYTE addr, BYTE ep, WORD nbytes, BYTE* dataptr, BOOL direction )
{
  101f9c:	defff804 	addi	sp,sp,-32
  101fa0:	dfc00715 	stw	ra,28(sp)
  101fa4:	df000615 	stw	fp,24(sp)
  101fa8:	df000604 	addi	fp,sp,24
  101fac:	2005883a 	mov	r2,r4
  101fb0:	2809883a 	mov	r4,r5
  101fb4:	3007883a 	mov	r3,r6
  101fb8:	e1fffb15 	stw	r7,-20(fp)
  101fbc:	e0bffe05 	stb	r2,-8(fp)
  101fc0:	2005883a 	mov	r2,r4
  101fc4:	e0bffd05 	stb	r2,-12(fp)
  101fc8:	1805883a 	mov	r2,r3
  101fcc:	e0bffc0d 	sth	r2,-16(fp)
  BYTE rcode;

    //MAXreg_wr( rHCTL, bmRCVTOG1 );       //set toggle to DATA1
    if( direction ) {   //IN transfer
  101fd0:	e0800217 	ldw	r2,8(fp)
  101fd4:	10002626 	beq	r2,zero,102070 <XferCtrlData+0xd4>
        devtable[ addr ].epinfo[ ep ].rcvToggle = bmRCVTOG1;
  101fd8:	e0bffe03 	ldbu	r2,-8(fp)
  101fdc:	100690fa 	slli	r3,r2,3
  101fe0:	00800074 	movhi	r2,1
  101fe4:	1885883a 	add	r2,r3,r2
  101fe8:	10c57517 	ldw	r3,5588(r2)
  101fec:	e0bffd03 	ldbu	r2,-12(fp)
  101ff0:	100490fa 	slli	r2,r2,3
  101ff4:	1885883a 	add	r2,r3,r2
  101ff8:	00c00804 	movi	r3,32
  101ffc:	10c00185 	stb	r3,6(r2)
        rcode = XferInTransfer( addr, ep, nbytes, dataptr, devtable[ addr ].epinfo[ ep ].MaxPktSize );
  102000:	e13ffe03 	ldbu	r4,-8(fp)
  102004:	e17ffd03 	ldbu	r5,-12(fp)
  102008:	e1bffc0b 	ldhu	r6,-16(fp)
  10200c:	e0bffe03 	ldbu	r2,-8(fp)
  102010:	100690fa 	slli	r3,r2,3
  102014:	00800074 	movhi	r2,1
  102018:	1885883a 	add	r2,r3,r2
  10201c:	10c57517 	ldw	r3,5588(r2)
  102020:	e0bffd03 	ldbu	r2,-12(fp)
  102024:	100490fa 	slli	r2,r2,3
  102028:	1885883a 	add	r2,r3,r2
  10202c:	1080008b 	ldhu	r2,2(r2)
  102030:	10803fcc 	andi	r2,r2,255
  102034:	d8800015 	stw	r2,0(sp)
  102038:	e1fffb17 	ldw	r7,-20(fp)
  10203c:	01022880 	call	102288 <XferInTransfer>
  102040:	e0bfffc5 	stb	r2,-1(fp)
        if( rcode ) {
  102044:	e0bfffc3 	ldbu	r2,-1(fp)
  102048:	10000226 	beq	r2,zero,102054 <XferCtrlData+0xb8>
        return( rcode );
  10204c:	e0bfffc3 	ldbu	r2,-1(fp)
  102050:	00000806 	br	102074 <XferCtrlData+0xd8>
        }
        rcode = XferDispatchPkt( tokOUTHS, ep );
  102054:	e0bffd03 	ldbu	r2,-12(fp)
  102058:	100b883a 	mov	r5,r2
  10205c:	01002804 	movi	r4,160
  102060:	01021080 	call	102108 <XferDispatchPkt>
  102064:	e0bfffc5 	stb	r2,-1(fp)
        return( rcode );
  102068:	e0bfffc3 	ldbu	r2,-1(fp)
  10206c:	00000106 	br	102074 <XferCtrlData+0xd8>
    }
    else {              //OUT not implemented
        return( 0xff );
  102070:	00bfffc4 	movi	r2,-1
    }
}
  102074:	e037883a 	mov	sp,fp
  102078:	dfc00117 	ldw	ra,4(sp)
  10207c:	df000017 	ldw	fp,0(sp)
  102080:	dec00204 	addi	sp,sp,8
  102084:	f800283a 	ret

00102088 <XferCtrlND>:
/* Control transfer with status stage and no data stage */
BYTE XferCtrlND( BYTE addr, BYTE ep, WORD nbytes, BYTE* dataptr, BOOL direction )
{
  102088:	defff904 	addi	sp,sp,-28
  10208c:	dfc00615 	stw	ra,24(sp)
  102090:	df000515 	stw	fp,20(sp)
  102094:	df000504 	addi	fp,sp,20
  102098:	2005883a 	mov	r2,r4
  10209c:	2809883a 	mov	r4,r5
  1020a0:	3007883a 	mov	r3,r6
  1020a4:	e1fffb15 	stw	r7,-20(fp)
  1020a8:	e0bffe05 	stb	r2,-8(fp)
  1020ac:	2005883a 	mov	r2,r4
  1020b0:	e0bffd05 	stb	r2,-12(fp)
  1020b4:	1805883a 	mov	r2,r3
  1020b8:	e0bffc0d 	sth	r2,-16(fp)
  BYTE rcode;
    if( direction ) { //GET
  1020bc:	e0800217 	ldw	r2,8(fp)
  1020c0:	10000626 	beq	r2,zero,1020dc <XferCtrlND+0x54>
        rcode = XferDispatchPkt( tokOUTHS, ep );
  1020c4:	e0bffd03 	ldbu	r2,-12(fp)
  1020c8:	100b883a 	mov	r5,r2
  1020cc:	01002804 	movi	r4,160
  1020d0:	01021080 	call	102108 <XferDispatchPkt>
  1020d4:	e0bfffc5 	stb	r2,-1(fp)
  1020d8:	00000506 	br	1020f0 <XferCtrlND+0x68>
    }
    else {
        rcode = XferDispatchPkt( tokINHS, ep );
  1020dc:	e0bffd03 	ldbu	r2,-12(fp)
  1020e0:	100b883a 	mov	r5,r2
  1020e4:	01002004 	movi	r4,128
  1020e8:	01021080 	call	102108 <XferDispatchPkt>
  1020ec:	e0bfffc5 	stb	r2,-1(fp)
    }
    return( rcode );
  1020f0:	e0bfffc3 	ldbu	r2,-1(fp)
}
  1020f4:	e037883a 	mov	sp,fp
  1020f8:	dfc00117 	ldw	ra,4(sp)
  1020fc:	df000017 	ldw	fp,0(sp)
  102100:	dec00204 	addi	sp,sp,8
  102104:	f800283a 	ret

00102108 <XferDispatchPkt>:
/* Result code: 0 success, nonzero = error condition                                                */
/* If NAK, tries to re-send up to USB_NAK_LIMIT times                                               */
/* If bus timeout, re-sends up to USB_RETRY_LIMIT times                                             */
/* return codes 0x00-0x0f are HRSLT( 0x00 being success ), 0xff means timeout                       */
BYTE XferDispatchPkt( BYTE token, BYTE ep )
{
  102108:	defff904 	addi	sp,sp,-28
  10210c:	dfc00615 	stw	ra,24(sp)
  102110:	df000515 	stw	fp,20(sp)
  102114:	df000504 	addi	fp,sp,20
  102118:	2005883a 	mov	r2,r4
  10211c:	2807883a 	mov	r3,r5
  102120:	e0bffc05 	stb	r2,-16(fp)
  102124:	1805883a 	mov	r2,r3
  102128:	e0bffb05 	stb	r2,-20(fp)
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
  10212c:	d0a02117 	ldw	r2,-32636(gp)
 DWORD timeout = (alt_nticks()*1000)/alt_ticks_per_second() + USB_XFER_TIMEOUT;
  102130:	0140fa04 	movi	r5,1000
  102134:	1009883a 	mov	r4,r2
  102138:	0102e940 	call	102e94 <__mulsi3>
  10213c:	1007883a 	mov	r3,r2
  return _alt_tick_rate;
  102140:	d0a02017 	ldw	r2,-32640(gp)
  102144:	100b883a 	mov	r5,r2
  102148:	1809883a 	mov	r4,r3
  10214c:	0102dd40 	call	102dd4 <__udivsi3>
  102150:	1084e204 	addi	r2,r2,5000
  102154:	e0bffe15 	stw	r2,-8(fp)
 BYTE tmpdata;
 BYTE rcode;
 char retry_count = 0;
  102158:	e03fff85 	stb	zero,-2(fp)
 BYTE nak_count = 0;
  10215c:	e03fff45 	stb	zero,-3(fp)

    while( 1 ) {
        MAXreg_wr( rHXFR, ( token|ep ));            //launch the transfer
  102160:	e0fffc03 	ldbu	r3,-16(fp)
  102164:	e0bffb03 	ldbu	r2,-20(fp)
  102168:	1884b03a 	or	r2,r3,r2
  10216c:	10803fcc 	andi	r2,r2,255
  102170:	100b883a 	mov	r5,r2
  102174:	01003c04 	movi	r4,240
  102178:	01016dc0 	call	1016dc <MAXreg_wr>
        rcode = 0xff;
  10217c:	00bfffc4 	movi	r2,-1
  102180:	e0bfffc5 	stb	r2,-1(fp)
        while( (alt_nticks()*1000)/alt_ticks_per_second() < timeout ) {
  102184:	00000d06 	br	1021bc <XferDispatchPkt+0xb4>
            tmpdata = MAXreg_rd( rHIRQ );
  102188:	01003204 	movi	r4,200
  10218c:	01018880 	call	101888 <MAXreg_rd>
  102190:	e0bffdc5 	stb	r2,-9(fp)
            if( tmpdata & bmHXFRDNIRQ ) {
  102194:	e0bffdc3 	ldbu	r2,-9(fp)
  102198:	10803fcc 	andi	r2,r2,255
  10219c:	1080201c 	xori	r2,r2,128
  1021a0:	10bfe004 	addi	r2,r2,-128
  1021a4:	1000050e 	bge	r2,zero,1021bc <XferDispatchPkt+0xb4>
                MAXreg_wr( rHIRQ, bmHXFRDNIRQ );    //clear the interrupt
  1021a8:	01402004 	movi	r5,128
  1021ac:	01003204 	movi	r4,200
  1021b0:	01016dc0 	call	1016dc <MAXreg_wr>
                rcode = 0x00;
  1021b4:	e03fffc5 	stb	zero,-1(fp)
                break;
  1021b8:	00000c06 	br	1021ec <XferDispatchPkt+0xe4>
  return _alt_nticks;
  1021bc:	d0a02117 	ldw	r2,-32636(gp)
        while( (alt_nticks()*1000)/alt_ticks_per_second() < timeout ) {
  1021c0:	0140fa04 	movi	r5,1000
  1021c4:	1009883a 	mov	r4,r2
  1021c8:	0102e940 	call	102e94 <__mulsi3>
  1021cc:	1007883a 	mov	r3,r2
  return _alt_tick_rate;
  1021d0:	d0a02017 	ldw	r2,-32640(gp)
  1021d4:	100b883a 	mov	r5,r2
  1021d8:	1809883a 	mov	r4,r3
  1021dc:	0102dd40 	call	102dd4 <__udivsi3>
  1021e0:	1007883a 	mov	r3,r2
  1021e4:	e0bffe17 	ldw	r2,-8(fp)
  1021e8:	18bfe736 	bltu	r3,r2,102188 <XferDispatchPkt+0x80>
            }
        }
        if( rcode != 0x00 ) {               //exit if timeout
  1021ec:	e0bfffc3 	ldbu	r2,-1(fp)
  1021f0:	10000226 	beq	r2,zero,1021fc <XferDispatchPkt+0xf4>
            return( rcode );
  1021f4:	e0bfffc3 	ldbu	r2,-1(fp)
  1021f8:	00001e06 	br	102274 <XferDispatchPkt+0x16c>
        }
        rcode = ( MAXreg_rd( rHRSL ) & 0x0f );
  1021fc:	01003e04 	movi	r4,248
  102200:	01018880 	call	101888 <MAXreg_rd>
  102204:	108003cc 	andi	r2,r2,15
  102208:	e0bfffc5 	stb	r2,-1(fp)
        if( rcode == hrNAK ) {
  10220c:	e0bfffc3 	ldbu	r2,-1(fp)
  102210:	10800118 	cmpnei	r2,r2,4
  102214:	1000071e 	bne	r2,zero,102234 <XferDispatchPkt+0x12c>
            nak_count++;
  102218:	e0bfff43 	ldbu	r2,-3(fp)
  10221c:	10800044 	addi	r2,r2,1
  102220:	e0bfff45 	stb	r2,-3(fp)
            if( nak_count == USB_NAK_LIMIT ) {
  102224:	e0bfff43 	ldbu	r2,-3(fp)
  102228:	10803218 	cmpnei	r2,r2,200
  10222c:	10000b1e 	bne	r2,zero,10225c <XferDispatchPkt+0x154>
                break;
  102230:	00000f06 	br	102270 <XferDispatchPkt+0x168>
            }
            else {
                continue;
            }
        }
        if( rcode == hrTIMEOUT ) {
  102234:	e0bfffc3 	ldbu	r2,-1(fp)
  102238:	10800398 	cmpnei	r2,r2,14
  10223c:	1000091e 	bne	r2,zero,102264 <XferDispatchPkt+0x15c>
            retry_count++;
  102240:	e0bfff83 	ldbu	r2,-2(fp)
  102244:	10800044 	addi	r2,r2,1
  102248:	e0bfff85 	stb	r2,-2(fp)
            if( retry_count == USB_RETRY_LIMIT ) {
  10224c:	e0bfff87 	ldb	r2,-2(fp)
  102250:	108000d8 	cmpnei	r2,r2,3
  102254:	10000526 	beq	r2,zero,10226c <XferDispatchPkt+0x164>
                break;
            }
            else {
                continue;
  102258:	00000106 	br	102260 <XferDispatchPkt+0x158>
                continue;
  10225c:	0001883a 	nop
        MAXreg_wr( rHXFR, ( token|ep ));            //launch the transfer
  102260:	003fbf06 	br	102160 <XferDispatchPkt+0x58>
            }
        }
        else break;
  102264:	0001883a 	nop
  102268:	00000106 	br	102270 <XferDispatchPkt+0x168>
                break;
  10226c:	0001883a 	nop
    }//while( 1 )
    return( rcode );
  102270:	e0bfffc3 	ldbu	r2,-1(fp)
}
  102274:	e037883a 	mov	sp,fp
  102278:	dfc00117 	ldw	ra,4(sp)
  10227c:	df000017 	ldw	fp,0(sp)
  102280:	dec00204 	addi	sp,sp,8
  102284:	f800283a 	ret

00102288 <XferInTransfer>:
/* IN transfer to arbitrary endpoint. Assumes PERADDR is set. Handles multiple packets if necessary. Transfers 'nbytes' bytes.
    Keep sending INs and writes data to memory area pointed by 'data' */
/* rcode 0 if no errors. rcode 01-0f is relayed from prvXferDispatchPkt(). Rcode f0 means RCVDAVIRQ error,
            fe USB xfer timeout */
BYTE XferInTransfer( BYTE addr/* not sure if it's necessary */, BYTE ep, WORD nbytes, BYTE* data, BYTE maxpktsize )
{
  102288:	defff804 	addi	sp,sp,-32
  10228c:	dfc00715 	stw	ra,28(sp)
  102290:	df000615 	stw	fp,24(sp)
  102294:	df000604 	addi	fp,sp,24
  102298:	2007883a 	mov	r3,r4
  10229c:	3009883a 	mov	r4,r6
  1022a0:	e1fffb15 	stw	r7,-20(fp)
  1022a4:	e0800217 	ldw	r2,8(fp)
  1022a8:	e0fffe05 	stb	r3,-8(fp)
  1022ac:	2807883a 	mov	r3,r5
  1022b0:	e0fffd05 	stb	r3,-12(fp)
  1022b4:	2007883a 	mov	r3,r4
  1022b8:	e0fffc0d 	sth	r3,-16(fp)
  1022bc:	e0bffa05 	stb	r2,-24(fp)
 BYTE rcode;
 BYTE i;
 BYTE tmpbyte;
 BYTE pktsize;
 WORD xfrlen = 0;
  1022c0:	e03fff8d 	sth	zero,-2(fp)
    MAXreg_wr( rHCTL, devtable[ addr ].epinfo[ ep ].rcvToggle );    //set toggle value
  1022c4:	e0bffe03 	ldbu	r2,-8(fp)
  1022c8:	100690fa 	slli	r3,r2,3
  1022cc:	00800074 	movhi	r2,1
  1022d0:	1885883a 	add	r2,r3,r2
  1022d4:	10c57517 	ldw	r3,5588(r2)
  1022d8:	e0bffd03 	ldbu	r2,-12(fp)
  1022dc:	100490fa 	slli	r2,r2,3
  1022e0:	1885883a 	add	r2,r3,r2
  1022e4:	10800183 	ldbu	r2,6(r2)
  1022e8:	10803fcc 	andi	r2,r2,255
  1022ec:	100b883a 	mov	r5,r2
  1022f0:	01003a04 	movi	r4,232
  1022f4:	01016dc0 	call	1016dc <MAXreg_wr>
    while( 1 ) { // use a 'return' to exit this loop
        rcode = XferDispatchPkt( tokIN, ep );           //IN packet to EP-'endpoint'. Function takes care of NAKS.
  1022f8:	e0bffd03 	ldbu	r2,-12(fp)
  1022fc:	100b883a 	mov	r5,r2
  102300:	0009883a 	mov	r4,zero
  102304:	01021080 	call	102108 <XferDispatchPkt>
  102308:	e0bfff45 	stb	r2,-3(fp)
        if( rcode ) {
  10230c:	e0bfff43 	ldbu	r2,-3(fp)
  102310:	10000226 	beq	r2,zero,10231c <XferInTransfer+0x94>
            return( rcode );                            //should be 0, indicating ACK. Else return error code.
  102314:	e0bfff43 	ldbu	r2,-3(fp)
  102318:	00003806 	br	1023fc <XferInTransfer+0x174>
        }
        /* check for RCVDAVIRQ and generate error if not present */
        /* the only case when absence of RCVDAVIRQ makes sense is when toggle error occurred. Need to add handling for that */
        if(( MAXreg_rd( rHIRQ ) & bmRCVDAVIRQ ) == 0 ) {
  10231c:	01003204 	movi	r4,200
  102320:	01018880 	call	101888 <MAXreg_rd>
  102324:	10803fcc 	andi	r2,r2,255
  102328:	1080010c 	andi	r2,r2,4
  10232c:	1000021e 	bne	r2,zero,102338 <XferInTransfer+0xb0>
            return ( 0xf0 );                            //receive error
  102330:	00bffc04 	movi	r2,-16
  102334:	00003106 	br	1023fc <XferInTransfer+0x174>
        }
        pktsize = MAXreg_rd( rRCVBC );                  //number of received bytes
  102338:	01000c04 	movi	r4,48
  10233c:	01018880 	call	101888 <MAXreg_rd>
  102340:	e0bfff05 	stb	r2,-4(fp)
        //printf ("pktsize: %d\n", pktsize);
        data = MAXbytes_rd( rRCVFIFO, pktsize, data );
  102344:	e0bfff03 	ldbu	r2,-4(fp)
  102348:	e1bffb17 	ldw	r6,-20(fp)
  10234c:	100b883a 	mov	r5,r2
  102350:	01000204 	movi	r4,8
  102354:	01019440 	call	101944 <MAXbytes_rd>
  102358:	e0bffb15 	stw	r2,-20(fp)
        MAXreg_wr( rHIRQ, bmRCVDAVIRQ );                // Clear the IRQ & free the buffer
  10235c:	01400104 	movi	r5,4
  102360:	01003204 	movi	r4,200
  102364:	01016dc0 	call	1016dc <MAXreg_wr>
        xfrlen += pktsize;                              // add this packet's byte count to total transfer length
  102368:	e0bfff03 	ldbu	r2,-4(fp)
  10236c:	e0ffff8b 	ldhu	r3,-2(fp)
  102370:	1885883a 	add	r2,r3,r2
  102374:	e0bfff8d 	sth	r2,-2(fp)
        /* The transfer is complete under two conditions:           */
        /* 1. The device sent a short packet (L.T. maxPacketSize)   */
        /* 2. 'nbytes' have been transferred.                       */
        if (( pktsize < maxpktsize ) || (xfrlen >= nbytes )) {    // have we transferred 'nbytes' bytes?
  102378:	e0ffff03 	ldbu	r3,-4(fp)
  10237c:	e0bffa03 	ldbu	r2,-24(fp)
  102380:	18800336 	bltu	r3,r2,102390 <XferInTransfer+0x108>
  102384:	e0ffff8b 	ldhu	r3,-2(fp)
  102388:	e0bffc0b 	ldhu	r2,-16(fp)
  10238c:	18bfda36 	bltu	r3,r2,1022f8 <XferInTransfer+0x70>
            if( MAXreg_rd( rHRSL ) & bmRCVTOGRD ) {                 //save toggle value
  102390:	01003e04 	movi	r4,248
  102394:	01018880 	call	101888 <MAXreg_rd>
  102398:	10803fcc 	andi	r2,r2,255
  10239c:	1080040c 	andi	r2,r2,16
  1023a0:	10000b26 	beq	r2,zero,1023d0 <XferInTransfer+0x148>
                devtable[ addr ].epinfo[ ep ].rcvToggle = bmRCVTOG1;
  1023a4:	e0bffe03 	ldbu	r2,-8(fp)
  1023a8:	100690fa 	slli	r3,r2,3
  1023ac:	00800074 	movhi	r2,1
  1023b0:	1885883a 	add	r2,r3,r2
  1023b4:	10c57517 	ldw	r3,5588(r2)
  1023b8:	e0bffd03 	ldbu	r2,-12(fp)
  1023bc:	100490fa 	slli	r2,r2,3
  1023c0:	1885883a 	add	r2,r3,r2
  1023c4:	00c00804 	movi	r3,32
  1023c8:	10c00185 	stb	r3,6(r2)
  1023cc:	00000a06 	br	1023f8 <XferInTransfer+0x170>
            }
            else {
                devtable[ addr ].epinfo[ ep ].rcvToggle = bmRCVTOG0;
  1023d0:	e0bffe03 	ldbu	r2,-8(fp)
  1023d4:	100690fa 	slli	r3,r2,3
  1023d8:	00800074 	movhi	r2,1
  1023dc:	1885883a 	add	r2,r3,r2
  1023e0:	10c57517 	ldw	r3,5588(r2)
  1023e4:	e0bffd03 	ldbu	r2,-12(fp)
  1023e8:	100490fa 	slli	r2,r2,3
  1023ec:	1885883a 	add	r2,r3,r2
  1023f0:	00c00404 	movi	r3,16
  1023f4:	10c00185 	stb	r3,6(r2)
            }
            return( 0 );
  1023f8:	0005883a 	mov	r2,zero
        }
  }//while( 1 )
}
  1023fc:	e037883a 	mov	sp,fp
  102400:	dfc00117 	ldw	ra,4(sp)
  102404:	df000017 	ldw	fp,0(sp)
  102408:	dec00204 	addi	sp,sp,8
  10240c:	f800283a 	ret

00102410 <USB_init>:
/* initialization of USB data structures */
void USB_init( void )
{
  102410:	defffe04 	addi	sp,sp,-8
  102414:	df000115 	stw	fp,4(sp)
  102418:	df000104 	addi	fp,sp,4
  BYTE i;
    for( i = 0; i < ( USB_NUMDEVICES + 1 ); i++ ) {
  10241c:	e03fffc5 	stb	zero,-1(fp)
  102420:	00000d06 	br	102458 <USB_init+0x48>
        devtable[ i ].epinfo = NULL;       //clear device table
  102424:	e0bfffc3 	ldbu	r2,-1(fp)
  102428:	100690fa 	slli	r3,r2,3
  10242c:	00800074 	movhi	r2,1
  102430:	1885883a 	add	r2,r3,r2
  102434:	10057515 	stw	zero,5588(r2)
        devtable[ i ].devclass = 0;
  102438:	e0bfffc3 	ldbu	r2,-1(fp)
  10243c:	100690fa 	slli	r3,r2,3
  102440:	00800074 	movhi	r2,1
  102444:	1885883a 	add	r2,r3,r2
  102448:	10057605 	stb	zero,5592(r2)
    for( i = 0; i < ( USB_NUMDEVICES + 1 ); i++ ) {
  10244c:	e0bfffc3 	ldbu	r2,-1(fp)
  102450:	10800044 	addi	r2,r2,1
  102454:	e0bfffc5 	stb	r2,-1(fp)
  102458:	e0bfffc3 	ldbu	r2,-1(fp)
  10245c:	10800270 	cmpltui	r2,r2,9
  102460:	103ff01e 	bne	r2,zero,102424 <USB_init+0x14>
    }
    devtable[ 0 ].epinfo = &dev0ep;  //set single ep for uninitialized device
  102464:	d0e01704 	addi	r3,gp,-32676
  102468:	00800074 	movhi	r2,1
  10246c:	10c57515 	stw	r3,5588(r2)
    dev0ep.MaxPktSize = 0;
  102470:	d020178d 	sth	zero,-32674(gp)
    dev0ep.sndToggle = bmSNDTOG0;   //set DATA0/1 toggles to 0
  102474:	00801004 	movi	r2,64
  102478:	d0a01845 	stb	r2,-32671(gp)
    dev0ep.rcvToggle = bmRCVTOG0;
  10247c:	00800404 	movi	r2,16
  102480:	d0a01885 	stb	r2,-32670(gp)
}
  102484:	0001883a 	nop
  102488:	e037883a 	mov	sp,fp
  10248c:	df000017 	ldw	fp,0(sp)
  102490:	dec00104 	addi	sp,sp,4
  102494:	f800283a 	ret

00102498 <USB_Task>:
/* error codes: 01-0f HRSLT        */
/* ff - unsupported device         */
/* fe - no address available       */
/* fd - no client driver available */
void USB_Task( void )
{
  102498:	deffb204 	addi	sp,sp,-312
  10249c:	dfc04d15 	stw	ra,308(sp)
  1024a0:	df004c15 	stw	fp,304(sp)
  1024a4:	dc004b15 	stw	r16,300(sp)
  1024a8:	df004c04 	addi	fp,sp,304
 USB_DEVICE_DESCRIPTOR buf;

 BYTE rcode, tmpdata;
 BYTE i;

    switch( usb_task_state & USB_STATE_MASK ) {
  1024ac:	d0a00603 	ldbu	r2,-32744(gp)
  1024b0:	10803fcc 	andi	r2,r2,255
  1024b4:	10803c0c 	andi	r2,r2,240
  1024b8:	10c00820 	cmpeqi	r3,r2,32
  1024bc:	18010e1e 	bne	r3,zero,1028f8 <USB_Task+0x460>
  1024c0:	10c00848 	cmpgei	r3,r2,33
  1024c4:	1800041e 	bne	r3,zero,1024d8 <USB_Task+0x40>
  1024c8:	10000a26 	beq	r2,zero,1024f4 <USB_Task+0x5c>
  1024cc:	10800420 	cmpeqi	r2,r2,16
  1024d0:	10001a1e 	bne	r2,zero,10253c <USB_Task+0xa4>
        case( USB_STATE_ERROR ):
            //vTaskDelay( LED_RATE ); //stay here if error
            break;//( USB_STATE_ERROR )
        default:
            //Should never get here
            break;
  1024d4:	00017506 	br	102aac <USB_Task+0x614>
    switch( usb_task_state & USB_STATE_MASK ) {
  1024d8:	10c01020 	cmpeqi	r3,r2,64
  1024dc:	1801681e 	bne	r3,zero,102a80 <USB_Task+0x5e8>
  1024e0:	10c03fe0 	cmpeqi	r3,r2,255
  1024e4:	1801681e 	bne	r3,zero,102a88 <USB_Task+0x5f0>
  1024e8:	10800c20 	cmpeqi	r2,r2,48
  1024ec:	10013d1e 	bne	r2,zero,1029e4 <USB_Task+0x54c>
            break;
  1024f0:	00016e06 	br	102aac <USB_Task+0x614>
            switch( usb_task_state ) {
  1024f4:	d0a00603 	ldbu	r2,-32744(gp)
  1024f8:	10803fcc 	andi	r2,r2,255
  1024fc:	10c000e0 	cmpeqi	r3,r2,3
  102500:	1800081e 	bne	r3,zero,102524 <USB_Task+0x8c>
  102504:	10c00120 	cmpeqi	r3,r2,4
  102508:	18000a1e 	bne	r3,zero,102534 <USB_Task+0x9c>
  10250c:	10800058 	cmpnei	r2,r2,1
  102510:	10015f1e 	bne	r2,zero,102a90 <USB_Task+0x5f8>
                    USB_init();
  102514:	01024100 	call	102410 <USB_init>
                    usb_task_state = USB_DETACHED_SUBSTATE_WAIT_FOR_DEVICE;
  102518:	008000c4 	movi	r2,3
  10251c:	d0a00605 	stb	r2,-32744(gp)
                    break;
  102520:	00000506 	br	102538 <USB_Task+0xa0>
                    MAXreg_wr(rHCTL,bmSAMPLEBUS);
  102524:	01400104 	movi	r5,4
  102528:	01003a04 	movi	r4,232
  10252c:	01016dc0 	call	1016dc <MAXreg_wr>
                    break;
  102530:	00000106 	br	102538 <USB_Task+0xa0>
                    break;
  102534:	0001883a 	nop
            break;//( USB_STATE_DETACHED ):
  102538:	00015506 	br	102a90 <USB_Task+0x5f8>
            switch( usb_task_state ) {
  10253c:	d0a00603 	ldbu	r2,-32744(gp)
  102540:	10803fcc 	andi	r2,r2,255
  102544:	10bffc04 	addi	r2,r2,-16
  102548:	10c001a8 	cmpgeui	r3,r2,6
  10254c:	1801521e 	bne	r3,zero,102a98 <USB_Task+0x600>
  102550:	100690ba 	slli	r3,r2,2
  102554:	00800434 	movhi	r2,16
  102558:	1885883a 	add	r2,r3,r2
  10255c:	10895917 	ldw	r2,9572(r2)
  102560:	1000683a 	jmp	r2
  102564:	0010257c 	xorhi	zero,zero,16533
  102568:	001025b4 	movhi	zero,16534
  10256c:	001025f0 	cmpltui	zero,zero,16535
  102570:	00102614 	movui	zero,16536
  102574:	00102654 	movui	zero,16537
  102578:	00102668 	cmpgeui	zero,zero,16537
  return _alt_nticks;
  10257c:	d0a02117 	ldw	r2,-32636(gp)
                    usb_delay = (alt_nticks()*1000)/alt_ticks_per_second() + 200;           //initial settle 200ms
  102580:	0140fa04 	movi	r5,1000
  102584:	1009883a 	mov	r4,r2
  102588:	0102e940 	call	102e94 <__mulsi3>
  10258c:	1007883a 	mov	r3,r2
  return _alt_tick_rate;
  102590:	d0a02017 	ldw	r2,-32640(gp)
  102594:	100b883a 	mov	r5,r2
  102598:	1809883a 	mov	r4,r3
  10259c:	0102dd40 	call	102dd4 <__udivsi3>
  1025a0:	10803204 	addi	r2,r2,200
  1025a4:	d0a01a15 	stw	r2,-32664(gp)
                    usb_task_state = USB_ATTACHED_SUBSTATE_SETTLE;
  1025a8:	00800444 	movi	r2,17
  1025ac:	d0a00605 	stb	r2,-32744(gp)
                    break;//case( USB_STATE_ATTACHED )
  1025b0:	0000d006 	br	1028f4 <USB_Task+0x45c>
  return _alt_nticks;
  1025b4:	d0a02117 	ldw	r2,-32636(gp)
                    if( (alt_nticks()*1000)/alt_ticks_per_second() > usb_delay ) {
  1025b8:	0140fa04 	movi	r5,1000
  1025bc:	1009883a 	mov	r4,r2
  1025c0:	0102e940 	call	102e94 <__mulsi3>
  1025c4:	1007883a 	mov	r3,r2
  return _alt_tick_rate;
  1025c8:	d0a02017 	ldw	r2,-32640(gp)
  1025cc:	100b883a 	mov	r5,r2
  1025d0:	1809883a 	mov	r4,r3
  1025d4:	0102dd40 	call	102dd4 <__udivsi3>
  1025d8:	1007883a 	mov	r3,r2
  1025dc:	d0a01a17 	ldw	r2,-32664(gp)
  1025e0:	10c0c12e 	bgeu	r2,r3,1028e8 <USB_Task+0x450>
                        usb_task_state = USB_ATTACHED_SUBSTATE_RESET_DEVICE;
  1025e4:	00800484 	movi	r2,18
  1025e8:	d0a00605 	stb	r2,-32744(gp)
                    break;//case( USB_ATTACHED_SUBSTATE_SETTLE )
  1025ec:	0000be06 	br	1028e8 <USB_Task+0x450>
                    MAXreg_wr( rHIRQ, bmBUSEVENTIRQ );                               //clear bus event IRQ
  1025f0:	01400044 	movi	r5,1
  1025f4:	01003204 	movi	r4,200
  1025f8:	01016dc0 	call	1016dc <MAXreg_wr>
                    MAXreg_wr( rHCTL, bmBUSRST );                                    //issue bus reset
  1025fc:	01400044 	movi	r5,1
  102600:	01003a04 	movi	r4,232
  102604:	01016dc0 	call	1016dc <MAXreg_wr>
                    usb_task_state = USB_ATTACHED_SUBSTATE_WAIT_RESET_COMPLETE;
  102608:	008004c4 	movi	r2,19
  10260c:	d0a00605 	stb	r2,-32744(gp)
                    break;//case( USB_ATTACHED_SUBSTATE_RESET_DEVICE )
  102610:	0000b806 	br	1028f4 <USB_Task+0x45c>
                    if(( MAXreg_rd( rHCTL ) & bmBUSRST ) == 0 ) {
  102614:	01003a04 	movi	r4,232
  102618:	01018880 	call	101888 <MAXreg_rd>
  10261c:	10803fcc 	andi	r2,r2,255
  102620:	1080004c 	andi	r2,r2,1
  102624:	1000b21e 	bne	r2,zero,1028f0 <USB_Task+0x458>
                        tmpdata = MAXreg_rd( rMODE ) | bmSOFKAENAB;                 //start SOF generation
  102628:	01003604 	movi	r4,216
  10262c:	01018880 	call	101888 <MAXreg_rd>
  102630:	10800214 	ori	r2,r2,8
  102634:	e0bffe85 	stb	r2,-6(fp)
                        MAXreg_wr( rMODE, tmpdata );
  102638:	e0bffe83 	ldbu	r2,-6(fp)
  10263c:	100b883a 	mov	r5,r2
  102640:	01003604 	movi	r4,216
  102644:	01016dc0 	call	1016dc <MAXreg_wr>
                        usb_task_state = USB_ATTACHED_SUBSTATE_WAIT_SOF;
  102648:	00800504 	movi	r2,20
  10264c:	d0a00605 	stb	r2,-32744(gp)
                    break;//case( USB_ATTACHED_SUBSTATE_WAIT_RESET_COMPLETE )
  102650:	0000a706 	br	1028f0 <USB_Task+0x458>
                    if( MAXreg_rd( rHIRQ ) | bmFRAMEIRQ ) {                     //when first SOF received we can continue
  102654:	01003204 	movi	r4,200
  102658:	01018880 	call	101888 <MAXreg_rd>
                        usb_task_state = USB_ATTACHED_SUBSTATE_GET_DEVICE_DESCRIPTOR_SIZE;
  10265c:	00800544 	movi	r2,21
  102660:	d0a00605 	stb	r2,-32744(gp)
                    break;//case( USB_ATTACHED_SUBSTATE_WAIT_SOF )
  102664:	0000a306 	br	1028f4 <USB_Task+0x45c>
                    devtable[ 0 ].epinfo->MaxPktSize = 0x0008;             //fill max packet size with minimum allowed
  102668:	00800074 	movhi	r2,1
  10266c:	10857517 	ldw	r2,5588(r2)
  102670:	00c00204 	movi	r3,8
  102674:	10c0008d 	sth	r3,2(r2)
                	rcode = XferGetDevDescr( 0, 0, 8, (BYTE *)&buf );       //get device descriptor size
  102678:	e0bff984 	addi	r2,fp,-26
  10267c:	d8800415 	stw	r2,16(sp)
  102680:	00800204 	movi	r2,8
  102684:	d8800315 	stw	r2,12(sp)
  102688:	d8000215 	stw	zero,8(sp)
  10268c:	00800044 	movi	r2,1
  102690:	d8800115 	stw	r2,4(sp)
  102694:	d8000015 	stw	zero,0(sp)
  102698:	01c00184 	movi	r7,6
  10269c:	01802004 	movi	r6,128
  1026a0:	000b883a 	mov	r5,zero
  1026a4:	0009883a 	mov	r4,zero
  1026a8:	0101e480 	call	101e48 <XferCtrlReq>
  1026ac:	e0bffe45 	stb	r2,-7(fp)
                    if( rcode == 0 ) {
  1026b0:	e0bffe43 	ldbu	r2,-7(fp)
  1026b4:	1000851e 	bne	r2,zero,1028cc <USB_Task+0x434>
                        devtable[ 0 ].epinfo->MaxPktSize = buf.bMaxPacketSize0;
  1026b8:	e0fffb43 	ldbu	r3,-19(fp)
  1026bc:	00800074 	movhi	r2,1
  1026c0:	10857517 	ldw	r2,5588(r2)
  1026c4:	18c03fcc 	andi	r3,r3,255
  1026c8:	10c0008d 	sth	r3,2(r2)
                        rcode = XferGetDevDescr( 0, 0, buf.bLength, (BYTE *)&buf );     //get full descriptor
  1026cc:	e0bff983 	ldbu	r2,-26(fp)
  1026d0:	10803fcc 	andi	r2,r2,255
  1026d4:	e0fff984 	addi	r3,fp,-26
  1026d8:	d8c00415 	stw	r3,16(sp)
  1026dc:	d8800315 	stw	r2,12(sp)
  1026e0:	d8000215 	stw	zero,8(sp)
  1026e4:	00800044 	movi	r2,1
  1026e8:	d8800115 	stw	r2,4(sp)
  1026ec:	d8000015 	stw	zero,0(sp)
  1026f0:	01c00184 	movi	r7,6
  1026f4:	01802004 	movi	r6,128
  1026f8:	000b883a 	mov	r5,zero
  1026fc:	0009883a 	mov	r4,zero
  102700:	0101e480 	call	101e48 <XferCtrlReq>
  102704:	e0bffe45 	stb	r2,-7(fp)
                        if (buf.iManufacturer != 0)
  102708:	e0bffd03 	ldbu	r2,-12(fp)
  10270c:	10803fcc 	andi	r2,r2,255
  102710:	10003426 	beq	r2,zero,1027e4 <USB_Task+0x34c>
                			rcode = XferGetStrDescr( 0, 0, 2, buf.iManufacturer, LANG_EN_US, (BYTE *)&strDesc);
  102714:	e0bffd03 	ldbu	r2,-12(fp)
  102718:	10803fcc 	andi	r2,r2,255
  10271c:	e0ffb984 	addi	r3,fp,-282
  102720:	d8c00415 	stw	r3,16(sp)
  102724:	00c00084 	movi	r3,2
  102728:	d8c00315 	stw	r3,12(sp)
  10272c:	00c10244 	movi	r3,1033
  102730:	d8c00215 	stw	r3,8(sp)
  102734:	00c000c4 	movi	r3,3
  102738:	d8c00115 	stw	r3,4(sp)
  10273c:	d8800015 	stw	r2,0(sp)
  102740:	01c00184 	movi	r7,6
  102744:	01802004 	movi	r6,128
  102748:	000b883a 	mov	r5,zero
  10274c:	0009883a 	mov	r4,zero
  102750:	0101e480 	call	101e48 <XferCtrlReq>
  102754:	e0bffe45 	stb	r2,-7(fp)
                			rcode = XferGetStrDescr( 0, 0, strDesc.bLength, buf.iManufacturer, LANG_EN_US, (BYTE *)&strDesc);
  102758:	e0bffd03 	ldbu	r2,-12(fp)
  10275c:	10803fcc 	andi	r2,r2,255
  102760:	e0ffb983 	ldbu	r3,-282(fp)
  102764:	18c03fcc 	andi	r3,r3,255
  102768:	e13fb984 	addi	r4,fp,-282
  10276c:	d9000415 	stw	r4,16(sp)
  102770:	d8c00315 	stw	r3,12(sp)
  102774:	00c10244 	movi	r3,1033
  102778:	d8c00215 	stw	r3,8(sp)
  10277c:	00c000c4 	movi	r3,3
  102780:	d8c00115 	stw	r3,4(sp)
  102784:	d8800015 	stw	r2,0(sp)
  102788:	01c00184 	movi	r7,6
  10278c:	01802004 	movi	r6,128
  102790:	000b883a 	mov	r5,zero
  102794:	0009883a 	mov	r4,zero
  102798:	0101e480 	call	101e48 <XferCtrlReq>
  10279c:	e0bffe45 	stb	r2,-7(fp)
                			printf ("Mfgr string(%i): %s\n", buf.iManufacturer, ConvUTF8ToStr(strDesc.bString, (strDesc.bLength>>1)-1));
  1027a0:	e0bffd03 	ldbu	r2,-12(fp)
  1027a4:	14003fcc 	andi	r16,r2,255
  1027a8:	e0bfb983 	ldbu	r2,-282(fp)
  1027ac:	10803fcc 	andi	r2,r2,255
  1027b0:	1004d07a 	srli	r2,r2,1
  1027b4:	10bfffc4 	addi	r2,r2,-1
  1027b8:	10c03fcc 	andi	r3,r2,255
  1027bc:	e0bfb984 	addi	r2,fp,-282
  1027c0:	10800084 	addi	r2,r2,2
  1027c4:	180b883a 	mov	r5,r3
  1027c8:	1009883a 	mov	r4,r2
  1027cc:	0102c580 	call	102c58 <ConvUTF8ToStr>
  1027d0:	100d883a 	mov	r6,r2
  1027d4:	800b883a 	mov	r5,r16
  1027d8:	01000434 	movhi	r4,16
  1027dc:	211adc04 	addi	r4,r4,27504
  1027e0:	0102f200 	call	102f20 <printf>
                		if (buf.iProduct != 0)
  1027e4:	e0bffd43 	ldbu	r2,-11(fp)
  1027e8:	10803fcc 	andi	r2,r2,255
  1027ec:	10003426 	beq	r2,zero,1028c0 <USB_Task+0x428>
                        	rcode = XferGetStrDescr( 0, 0, 2, buf.iProduct, LANG_EN_US, (BYTE *)&strDesc);
  1027f0:	e0bffd43 	ldbu	r2,-11(fp)
  1027f4:	10803fcc 	andi	r2,r2,255
  1027f8:	e0ffb984 	addi	r3,fp,-282
  1027fc:	d8c00415 	stw	r3,16(sp)
  102800:	00c00084 	movi	r3,2
  102804:	d8c00315 	stw	r3,12(sp)
  102808:	00c10244 	movi	r3,1033
  10280c:	d8c00215 	stw	r3,8(sp)
  102810:	00c000c4 	movi	r3,3
  102814:	d8c00115 	stw	r3,4(sp)
  102818:	d8800015 	stw	r2,0(sp)
  10281c:	01c00184 	movi	r7,6
  102820:	01802004 	movi	r6,128
  102824:	000b883a 	mov	r5,zero
  102828:	0009883a 	mov	r4,zero
  10282c:	0101e480 	call	101e48 <XferCtrlReq>
  102830:	e0bffe45 	stb	r2,-7(fp)
                			rcode = XferGetStrDescr( 0, 0, strDesc.bLength, buf.iProduct, LANG_EN_US, (BYTE *)&strDesc);
  102834:	e0bffd43 	ldbu	r2,-11(fp)
  102838:	10803fcc 	andi	r2,r2,255
  10283c:	e0ffb983 	ldbu	r3,-282(fp)
  102840:	18c03fcc 	andi	r3,r3,255
  102844:	e13fb984 	addi	r4,fp,-282
  102848:	d9000415 	stw	r4,16(sp)
  10284c:	d8c00315 	stw	r3,12(sp)
  102850:	00c10244 	movi	r3,1033
  102854:	d8c00215 	stw	r3,8(sp)
  102858:	00c000c4 	movi	r3,3
  10285c:	d8c00115 	stw	r3,4(sp)
  102860:	d8800015 	stw	r2,0(sp)
  102864:	01c00184 	movi	r7,6
  102868:	01802004 	movi	r6,128
  10286c:	000b883a 	mov	r5,zero
  102870:	0009883a 	mov	r4,zero
  102874:	0101e480 	call	101e48 <XferCtrlReq>
  102878:	e0bffe45 	stb	r2,-7(fp)
                			printf ("Product string(%i): %s\n", buf.iProduct, ConvUTF8ToStr(strDesc.bString, (strDesc.bLength>>1)-1));
  10287c:	e0bffd43 	ldbu	r2,-11(fp)
  102880:	14003fcc 	andi	r16,r2,255
  102884:	e0bfb983 	ldbu	r2,-282(fp)
  102888:	10803fcc 	andi	r2,r2,255
  10288c:	1004d07a 	srli	r2,r2,1
  102890:	10bfffc4 	addi	r2,r2,-1
  102894:	10c03fcc 	andi	r3,r2,255
  102898:	e0bfb984 	addi	r2,fp,-282
  10289c:	10800084 	addi	r2,r2,2
  1028a0:	180b883a 	mov	r5,r3
  1028a4:	1009883a 	mov	r4,r2
  1028a8:	0102c580 	call	102c58 <ConvUTF8ToStr>
  1028ac:	100d883a 	mov	r6,r2
  1028b0:	800b883a 	mov	r5,r16
  1028b4:	01000434 	movhi	r4,16
  1028b8:	211ae204 	addi	r4,r4,27528
  1028bc:	0102f200 	call	102f20 <printf>
                        usb_task_state = USB_STATE_ADDRESSING;
  1028c0:	00800804 	movi	r2,32
  1028c4:	d0a00605 	stb	r2,-32744(gp)
                    break;//case( USB_ATTACHED_SUBSTATE_GET_DEVICE_DESCRIPTOR_SIZE ):
  1028c8:	00000a06 	br	1028f4 <USB_Task+0x45c>
                        usb_error = rcode;
  1028cc:	e0bffe43 	ldbu	r2,-7(fp)
  1028d0:	d0a01b45 	stb	r2,-32659(gp)
                        last_usb_task_state = usb_task_state;
  1028d4:	d0a00603 	ldbu	r2,-32744(gp)
  1028d8:	d0a01905 	stb	r2,-32668(gp)
                        usb_task_state = USB_STATE_ERROR;
  1028dc:	00bfffc4 	movi	r2,-1
  1028e0:	d0a00605 	stb	r2,-32744(gp)
                    break;//case( USB_ATTACHED_SUBSTATE_GET_DEVICE_DESCRIPTOR_SIZE ):
  1028e4:	00000306 	br	1028f4 <USB_Task+0x45c>
                    break;//case( USB_ATTACHED_SUBSTATE_SETTLE )
  1028e8:	0001883a 	nop
  1028ec:	00006a06 	br	102a98 <USB_Task+0x600>
                    break;//case( USB_ATTACHED_SUBSTATE_WAIT_RESET_COMPLETE )
  1028f0:	0001883a 	nop
            break;//case ( USB_STATE_ATTACHED )
  1028f4:	00006806 	br	102a98 <USB_Task+0x600>
            for( i = 1; i < USB_NUMDEVICES; i++ ) {
  1028f8:	00800044 	movi	r2,1
  1028fc:	e0bffec5 	stb	r2,-5(fp)
  102900:	00002a06 	br	1029ac <USB_Task+0x514>
                if( devtable[ i ].epinfo == NULL ) {
  102904:	e0bffec3 	ldbu	r2,-5(fp)
  102908:	100690fa 	slli	r3,r2,3
  10290c:	00800074 	movhi	r2,1
  102910:	1885883a 	add	r2,r3,r2
  102914:	10857517 	ldw	r2,5588(r2)
  102918:	1000211e 	bne	r2,zero,1029a0 <USB_Task+0x508>
                    devtable[ i ].epinfo = devtable[ 0 ].epinfo;        //set correct MaxPktSize
  10291c:	e0bffec3 	ldbu	r2,-5(fp)
  102920:	00c00074 	movhi	r3,1
  102924:	18c57517 	ldw	r3,5588(r3)
  102928:	100890fa 	slli	r4,r2,3
  10292c:	00800074 	movhi	r2,1
  102930:	2085883a 	add	r2,r4,r2
  102934:	10c57515 	stw	r3,5588(r2)
                    rcode = XferSetAddr( 0, 0, i );
  102938:	e0bffec3 	ldbu	r2,-5(fp)
  10293c:	d8000415 	stw	zero,16(sp)
  102940:	d8000315 	stw	zero,12(sp)
  102944:	d8000215 	stw	zero,8(sp)
  102948:	d8000115 	stw	zero,4(sp)
  10294c:	d8800015 	stw	r2,0(sp)
  102950:	01c00144 	movi	r7,5
  102954:	000d883a 	mov	r6,zero
  102958:	000b883a 	mov	r5,zero
  10295c:	0009883a 	mov	r4,zero
  102960:	0101e480 	call	101e48 <XferCtrlReq>
  102964:	e0bffe45 	stb	r2,-7(fp)
                    if( rcode == 0 ) {
  102968:	e0bffe43 	ldbu	r2,-7(fp)
  10296c:	1000051e 	bne	r2,zero,102984 <USB_Task+0x4ec>
                        tmp_addr = i;
  102970:	e0bffec3 	ldbu	r2,-5(fp)
  102974:	d0a01b05 	stb	r2,-32660(gp)
                        usb_task_state = USB_STATE_CONFIGURING;
  102978:	00800c04 	movi	r2,48
  10297c:	d0a00605 	stb	r2,-32744(gp)
                    break;  //break if address assigned or error occurred during address assignment attempt
  102980:	00000d06 	br	1029b8 <USB_Task+0x520>
                        usb_error = rcode;          //set address error
  102984:	e0bffe43 	ldbu	r2,-7(fp)
  102988:	d0a01b45 	stb	r2,-32659(gp)
                        last_usb_task_state = usb_task_state;
  10298c:	d0a00603 	ldbu	r2,-32744(gp)
  102990:	d0a01905 	stb	r2,-32668(gp)
                        usb_task_state = USB_STATE_ERROR;
  102994:	00bfffc4 	movi	r2,-1
  102998:	d0a00605 	stb	r2,-32744(gp)
                    break;  //break if address assigned or error occurred during address assignment attempt
  10299c:	00000606 	br	1029b8 <USB_Task+0x520>
            for( i = 1; i < USB_NUMDEVICES; i++ ) {
  1029a0:	e0bffec3 	ldbu	r2,-5(fp)
  1029a4:	10800044 	addi	r2,r2,1
  1029a8:	e0bffec5 	stb	r2,-5(fp)
  1029ac:	e0bffec3 	ldbu	r2,-5(fp)
  1029b0:	10800230 	cmpltui	r2,r2,8
  1029b4:	103fd31e 	bne	r2,zero,102904 <USB_Task+0x46c>
            if( usb_task_state == USB_STATE_ADDRESSING ) {
  1029b8:	d0a00603 	ldbu	r2,-32744(gp)
  1029bc:	10803fcc 	andi	r2,r2,255
  1029c0:	10800818 	cmpnei	r2,r2,32
  1029c4:	1000361e 	bne	r2,zero,102aa0 <USB_Task+0x608>
                usb_error = 0xfe;
  1029c8:	00bfff84 	movi	r2,-2
  1029cc:	d0a01b45 	stb	r2,-32659(gp)
                last_usb_task_state = usb_task_state;
  1029d0:	d0a00603 	ldbu	r2,-32744(gp)
  1029d4:	d0a01905 	stb	r2,-32668(gp)
                usb_task_state = USB_STATE_ERROR;
  1029d8:	00bfffc4 	movi	r2,-1
  1029dc:	d0a00605 	stb	r2,-32744(gp)
            break;//case ( USB_STATE_ADDRESSING )
  1029e0:	00002f06 	br	102aa0 <USB_Task+0x608>
            for( i = 0; i < USB_NUMCLASSES; i++ ) {
  1029e4:	e03ffec5 	stb	zero,-5(fp)
  1029e8:	00001706 	br	102a48 <USB_Task+0x5b0>
                rcode = ClientDriverTable[ i ].Initialize( tmp_addr, 0 );
  1029ec:	e0fffec3 	ldbu	r3,-5(fp)
  1029f0:	1805883a 	mov	r2,r3
  1029f4:	1085883a 	add	r2,r2,r2
  1029f8:	10c5883a 	add	r2,r2,r3
  1029fc:	100490ba 	slli	r2,r2,2
  102a00:	00c00074 	movhi	r3,1
  102a04:	10c7883a 	add	r3,r2,r3
  102a08:	18800017 	ldw	r2,0(r3)
  102a0c:	d0e01b03 	ldbu	r3,-32660(gp)
  102a10:	18c03fcc 	andi	r3,r3,255
  102a14:	000b883a 	mov	r5,zero
  102a18:	1809883a 	mov	r4,r3
  102a1c:	103ee83a 	callr	r2
  102a20:	e0bffe45 	stb	r2,-7(fp)
                if( rcode == TRUE ) {
  102a24:	e0bffe43 	ldbu	r2,-7(fp)
  102a28:	10800058 	cmpnei	r2,r2,1
  102a2c:	1000031e 	bne	r2,zero,102a3c <USB_Task+0x5a4>
			        usb_task_state = USB_STATE_RUNNING;
  102a30:	00801004 	movi	r2,64
  102a34:	d0a00605 	stb	r2,-32744(gp)
                    break;
  102a38:	00000606 	br	102a54 <USB_Task+0x5bc>
            for( i = 0; i < USB_NUMCLASSES; i++ ) {
  102a3c:	e0bffec3 	ldbu	r2,-5(fp)
  102a40:	10800044 	addi	r2,r2,1
  102a44:	e0bffec5 	stb	r2,-5(fp)
  102a48:	e0bffec3 	ldbu	r2,-5(fp)
  102a4c:	10800130 	cmpltui	r2,r2,4
  102a50:	103fe61e 	bne	r2,zero,1029ec <USB_Task+0x554>
            if( usb_task_state == USB_STATE_CONFIGURING ) {
  102a54:	d0a00603 	ldbu	r2,-32744(gp)
  102a58:	10803fcc 	andi	r2,r2,255
  102a5c:	10800c18 	cmpnei	r2,r2,48
  102a60:	1000111e 	bne	r2,zero,102aa8 <USB_Task+0x610>
                usb_error = 0xfd;
  102a64:	00bfff44 	movi	r2,-3
  102a68:	d0a01b45 	stb	r2,-32659(gp)
                last_usb_task_state = usb_task_state;
  102a6c:	d0a00603 	ldbu	r2,-32744(gp)
  102a70:	d0a01905 	stb	r2,-32668(gp)
                usb_task_state = USB_STATE_ERROR;
  102a74:	00bfffc4 	movi	r2,-1
  102a78:	d0a00605 	stb	r2,-32744(gp)
            break;//( USB_STATE_CONFIGURING )
  102a7c:	00000a06 	br	102aa8 <USB_Task+0x610>
            break;//( USB_STATE_RUNNING )
  102a80:	0001883a 	nop
  102a84:	00000906 	br	102aac <USB_Task+0x614>
            break;//( USB_STATE_ERROR )
  102a88:	0001883a 	nop
  102a8c:	00000706 	br	102aac <USB_Task+0x614>
            break;//( USB_STATE_DETACHED ):
  102a90:	0001883a 	nop
  102a94:	00000506 	br	102aac <USB_Task+0x614>
            break;//case ( USB_STATE_ATTACHED )
  102a98:	0001883a 	nop
  102a9c:	00000306 	br	102aac <USB_Task+0x614>
            break;//case ( USB_STATE_ADDRESSING )
  102aa0:	0001883a 	nop
  102aa4:	00000106 	br	102aac <USB_Task+0x614>
            break;//( USB_STATE_CONFIGURING )
  102aa8:	0001883a 	nop
    }//switch( usb_task_state & STATE_MASK )
}
  102aac:	0001883a 	nop
  102ab0:	e6ffff04 	addi	sp,fp,-4
  102ab4:	dfc00217 	ldw	ra,8(sp)
  102ab8:	df000117 	ldw	fp,4(sp)
  102abc:	dc000017 	ldw	r16,0(sp)
  102ac0:	dec00304 	addi	sp,sp,12
  102ac4:	f800283a 	ret

00102ac8 <MSDProbe>:

//place-holders for MSD (mass-storage device) drivers, we don't have them ported.
//returns TRUE if device is successfully identified and configured, otherwise returns FALSE
BOOL MSDProbe( BYTE addr, DWORD flags )
{
  102ac8:	defffd04 	addi	sp,sp,-12
  102acc:	df000215 	stw	fp,8(sp)
  102ad0:	df000204 	addi	fp,sp,8
  102ad4:	2005883a 	mov	r2,r4
  102ad8:	e17ffe15 	stw	r5,-8(fp)
  102adc:	e0bfff05 	stb	r2,-4(fp)
    return( FALSE );
  102ae0:	0005883a 	mov	r2,zero
}
  102ae4:	e037883a 	mov	sp,fp
  102ae8:	df000017 	ldw	fp,0(sp)
  102aec:	dec00104 	addi	sp,sp,4
  102af0:	f800283a 	ret

00102af4 <MSDEventHandler>:

BOOL MSDEventHandler( BYTE address, BYTE event, void *data, DWORD size )
{
  102af4:	defffb04 	addi	sp,sp,-20
  102af8:	df000415 	stw	fp,16(sp)
  102afc:	df000404 	addi	fp,sp,16
  102b00:	2005883a 	mov	r2,r4
  102b04:	2807883a 	mov	r3,r5
  102b08:	e1bffd15 	stw	r6,-12(fp)
  102b0c:	e1fffc15 	stw	r7,-16(fp)
  102b10:	e0bfff05 	stb	r2,-4(fp)
  102b14:	1805883a 	mov	r2,r3
  102b18:	e0bffe05 	stb	r2,-8(fp)

	return( FALSE );
  102b1c:	0005883a 	mov	r2,zero

}
  102b20:	e037883a 	mov	sp,fp
  102b24:	df000017 	ldw	fp,0(sp)
  102b28:	dec00104 	addi	sp,sp,4
  102b2c:	f800283a 	ret

00102b30 <CDCProbe>:
//CDC (communication device class also not supported)
BOOL CDCProbe( BYTE address, DWORD flags )
{
  102b30:	defffd04 	addi	sp,sp,-12
  102b34:	df000215 	stw	fp,8(sp)
  102b38:	df000204 	addi	fp,sp,8
  102b3c:	2005883a 	mov	r2,r4
  102b40:	e17ffe15 	stw	r5,-8(fp)
  102b44:	e0bfff05 	stb	r2,-4(fp)

	return( FALSE );
  102b48:	0005883a 	mov	r2,zero

}
  102b4c:	e037883a 	mov	sp,fp
  102b50:	df000017 	ldw	fp,0(sp)
  102b54:	dec00104 	addi	sp,sp,4
  102b58:	f800283a 	ret

00102b5c <CDCEventHandler>:

BOOL CDCEventHandler( BYTE address, BYTE event, void *data, DWORD size )
{
  102b5c:	defffb04 	addi	sp,sp,-20
  102b60:	df000415 	stw	fp,16(sp)
  102b64:	df000404 	addi	fp,sp,16
  102b68:	2005883a 	mov	r2,r4
  102b6c:	2807883a 	mov	r3,r5
  102b70:	e1bffd15 	stw	r6,-12(fp)
  102b74:	e1fffc15 	stw	r7,-16(fp)
  102b78:	e0bfff05 	stb	r2,-4(fp)
  102b7c:	1805883a 	mov	r2,r3
  102b80:	e0bffe05 	stb	r2,-8(fp)
	return( FALSE );
  102b84:	0005883a 	mov	r2,zero
}
  102b88:	e037883a 	mov	sp,fp
  102b8c:	df000017 	ldw	fp,0(sp)
  102b90:	dec00104 	addi	sp,sp,4
  102b94:	f800283a 	ret

00102b98 <DummyProbe>:

BOOL DummyProbe( BYTE address , DWORD flags )
{
  102b98:	defffd04 	addi	sp,sp,-12
  102b9c:	df000215 	stw	fp,8(sp)
  102ba0:	df000204 	addi	fp,sp,8
  102ba4:	2005883a 	mov	r2,r4
  102ba8:	e17ffe15 	stw	r5,-8(fp)
  102bac:	e0bfff05 	stb	r2,-4(fp)
	return( FALSE );
  102bb0:	0005883a 	mov	r2,zero
}
  102bb4:	e037883a 	mov	sp,fp
  102bb8:	df000017 	ldw	fp,0(sp)
  102bbc:	dec00104 	addi	sp,sp,4
  102bc0:	f800283a 	ret

00102bc4 <DummyEventHandler>:

BOOL DummyEventHandler( BYTE address, BYTE event, void *data, DWORD size )
{
  102bc4:	defffb04 	addi	sp,sp,-20
  102bc8:	df000415 	stw	fp,16(sp)
  102bcc:	df000404 	addi	fp,sp,16
  102bd0:	2005883a 	mov	r2,r4
  102bd4:	2807883a 	mov	r3,r5
  102bd8:	e1bffd15 	stw	r6,-12(fp)
  102bdc:	e1fffc15 	stw	r7,-16(fp)
  102be0:	e0bfff05 	stb	r2,-4(fp)
  102be4:	1805883a 	mov	r2,r3
  102be8:	e0bffe05 	stb	r2,-8(fp)
	return( FALSE );
  102bec:	0005883a 	mov	r2,zero
}
  102bf0:	e037883a 	mov	sp,fp
  102bf4:	df000017 	ldw	fp,0(sp)
  102bf8:	dec00104 	addi	sp,sp,4
  102bfc:	f800283a 	ret

00102c00 <GetUsbTaskState>:
/* Function to access usb_task_state variable from outside */
BYTE GetUsbTaskState( void )
{
  102c00:	deffff04 	addi	sp,sp,-4
  102c04:	df000015 	stw	fp,0(sp)
  102c08:	d839883a 	mov	fp,sp
    return( usb_task_state );
  102c0c:	d0a00603 	ldbu	r2,-32744(gp)
}
  102c10:	e037883a 	mov	sp,fp
  102c14:	df000017 	ldw	fp,0(sp)
  102c18:	dec00104 	addi	sp,sp,4
  102c1c:	f800283a 	ret

00102c20 <GetDevtable>:
/* Function to access devtable[] from outside */
DEV_RECORD* GetDevtable( BYTE index )
{
  102c20:	defffe04 	addi	sp,sp,-8
  102c24:	df000115 	stw	fp,4(sp)
  102c28:	df000104 	addi	fp,sp,4
  102c2c:	2005883a 	mov	r2,r4
  102c30:	e0bfff05 	stb	r2,-4(fp)
    return( &devtable[ index ] );
  102c34:	e0bfff03 	ldbu	r2,-4(fp)
  102c38:	100690fa 	slli	r3,r2,3
  102c3c:	00800074 	movhi	r2,1
  102c40:	10857504 	addi	r2,r2,5588
  102c44:	1885883a 	add	r2,r3,r2
}
  102c48:	e037883a 	mov	sp,fp
  102c4c:	df000017 	ldw	fp,0(sp)
  102c50:	dec00104 	addi	sp,sp,4
  102c54:	f800283a 	ret

00102c58 <ConvUTF8ToStr>:

char* ConvUTF8ToStr(BYTE* utf8, BYTE length)
{
  102c58:	defffc04 	addi	sp,sp,-16
  102c5c:	df000315 	stw	fp,12(sp)
  102c60:	df000304 	addi	fp,sp,12
  102c64:	e13ffe15 	stw	r4,-8(fp)
  102c68:	2805883a 	mov	r2,r5
  102c6c:	e0bffd05 	stb	r2,-12(fp)
	BYTE i;
	for (i = 0; i < length; i++)
  102c70:	e03fffc5 	stb	zero,-1(fp)
  102c74:	00000d06 	br	102cac <ConvUTF8ToStr+0x54>
	{
		utf8[i] = utf8[2*i];
  102c78:	e0bfffc3 	ldbu	r2,-1(fp)
  102c7c:	1085883a 	add	r2,r2,r2
  102c80:	1007883a 	mov	r3,r2
  102c84:	e0bffe17 	ldw	r2,-8(fp)
  102c88:	10c7883a 	add	r3,r2,r3
  102c8c:	e0bfffc3 	ldbu	r2,-1(fp)
  102c90:	e13ffe17 	ldw	r4,-8(fp)
  102c94:	2085883a 	add	r2,r4,r2
  102c98:	18c00003 	ldbu	r3,0(r3)
  102c9c:	10c00005 	stb	r3,0(r2)
	for (i = 0; i < length; i++)
  102ca0:	e0bfffc3 	ldbu	r2,-1(fp)
  102ca4:	10800044 	addi	r2,r2,1
  102ca8:	e0bfffc5 	stb	r2,-1(fp)
  102cac:	e0ffffc3 	ldbu	r3,-1(fp)
  102cb0:	e0bffd03 	ldbu	r2,-12(fp)
  102cb4:	18bff036 	bltu	r3,r2,102c78 <ConvUTF8ToStr+0x20>
	}
	utf8[length] = 0x00;
  102cb8:	e0bffd03 	ldbu	r2,-12(fp)
  102cbc:	e0fffe17 	ldw	r3,-8(fp)
  102cc0:	1885883a 	add	r2,r3,r2
  102cc4:	10000005 	stb	zero,0(r2)
	return (char*)utf8;
  102cc8:	e0bffe17 	ldw	r2,-8(fp)
}
  102ccc:	e037883a 	mov	sp,fp
  102cd0:	df000017 	ldw	fp,0(sp)
  102cd4:	dec00104 	addi	sp,sp,4
  102cd8:	f800283a 	ret

00102cdc <__divsi3>:
  102cdc:	20001a16 	blt	r4,zero,102d48 <__divsi3+0x6c>
  102ce0:	000f883a 	mov	r7,zero
  102ce4:	2800020e 	bge	r5,zero,102cf0 <__divsi3+0x14>
  102ce8:	014bc83a 	sub	r5,zero,r5
  102cec:	39c0005c 	xori	r7,r7,1
  102cf0:	200d883a 	mov	r6,r4
  102cf4:	00c00044 	movi	r3,1
  102cf8:	2900092e 	bgeu	r5,r4,102d20 <__divsi3+0x44>
  102cfc:	00800804 	movi	r2,32
  102d00:	00c00044 	movi	r3,1
  102d04:	00000106 	br	102d0c <__divsi3+0x30>
  102d08:	10001226 	beq	r2,zero,102d54 <__divsi3+0x78>
  102d0c:	294b883a 	add	r5,r5,r5
  102d10:	10bfffc4 	addi	r2,r2,-1
  102d14:	18c7883a 	add	r3,r3,r3
  102d18:	293ffb36 	bltu	r5,r4,102d08 <__divsi3+0x2c>
  102d1c:	18000d26 	beq	r3,zero,102d54 <__divsi3+0x78>
  102d20:	0005883a 	mov	r2,zero
  102d24:	31400236 	bltu	r6,r5,102d30 <__divsi3+0x54>
  102d28:	314dc83a 	sub	r6,r6,r5
  102d2c:	10c4b03a 	or	r2,r2,r3
  102d30:	1806d07a 	srli	r3,r3,1
  102d34:	280ad07a 	srli	r5,r5,1
  102d38:	183ffa1e 	bne	r3,zero,102d24 <__divsi3+0x48>
  102d3c:	38000126 	beq	r7,zero,102d44 <__divsi3+0x68>
  102d40:	0085c83a 	sub	r2,zero,r2
  102d44:	f800283a 	ret
  102d48:	0109c83a 	sub	r4,zero,r4
  102d4c:	01c00044 	movi	r7,1
  102d50:	003fe406 	br	102ce4 <__divsi3+0x8>
  102d54:	0005883a 	mov	r2,zero
  102d58:	003ff806 	br	102d3c <__divsi3+0x60>

00102d5c <__modsi3>:
  102d5c:	20001a16 	blt	r4,zero,102dc8 <__modsi3+0x6c>
  102d60:	000f883a 	mov	r7,zero
  102d64:	2005883a 	mov	r2,r4
  102d68:	2800010e 	bge	r5,zero,102d70 <__modsi3+0x14>
  102d6c:	014bc83a 	sub	r5,zero,r5
  102d70:	00c00044 	movi	r3,1
  102d74:	2900092e 	bgeu	r5,r4,102d9c <__modsi3+0x40>
  102d78:	01800804 	movi	r6,32
  102d7c:	00c00044 	movi	r3,1
  102d80:	00000106 	br	102d88 <__modsi3+0x2c>
  102d84:	30000d26 	beq	r6,zero,102dbc <__modsi3+0x60>
  102d88:	294b883a 	add	r5,r5,r5
  102d8c:	31bfffc4 	addi	r6,r6,-1
  102d90:	18c7883a 	add	r3,r3,r3
  102d94:	293ffb36 	bltu	r5,r4,102d84 <__modsi3+0x28>
  102d98:	18000826 	beq	r3,zero,102dbc <__modsi3+0x60>
  102d9c:	1806d07a 	srli	r3,r3,1
  102da0:	11400136 	bltu	r2,r5,102da8 <__modsi3+0x4c>
  102da4:	1145c83a 	sub	r2,r2,r5
  102da8:	280ad07a 	srli	r5,r5,1
  102dac:	183ffb1e 	bne	r3,zero,102d9c <__modsi3+0x40>
  102db0:	38000126 	beq	r7,zero,102db8 <__modsi3+0x5c>
  102db4:	0085c83a 	sub	r2,zero,r2
  102db8:	f800283a 	ret
  102dbc:	2005883a 	mov	r2,r4
  102dc0:	383ffd26 	beq	r7,zero,102db8 <__modsi3+0x5c>
  102dc4:	003ffb06 	br	102db4 <__modsi3+0x58>
  102dc8:	0109c83a 	sub	r4,zero,r4
  102dcc:	01c00044 	movi	r7,1
  102dd0:	003fe406 	br	102d64 <__modsi3+0x8>

00102dd4 <__udivsi3>:
  102dd4:	200d883a 	mov	r6,r4
  102dd8:	2900152e 	bgeu	r5,r4,102e30 <__udivsi3+0x5c>
  102ddc:	28001416 	blt	r5,zero,102e30 <__udivsi3+0x5c>
  102de0:	00800804 	movi	r2,32
  102de4:	00c00044 	movi	r3,1
  102de8:	00000206 	br	102df4 <__udivsi3+0x20>
  102dec:	10000e26 	beq	r2,zero,102e28 <__udivsi3+0x54>
  102df0:	28000516 	blt	r5,zero,102e08 <__udivsi3+0x34>
  102df4:	294b883a 	add	r5,r5,r5
  102df8:	10bfffc4 	addi	r2,r2,-1
  102dfc:	18c7883a 	add	r3,r3,r3
  102e00:	293ffa36 	bltu	r5,r4,102dec <__udivsi3+0x18>
  102e04:	18000826 	beq	r3,zero,102e28 <__udivsi3+0x54>
  102e08:	0005883a 	mov	r2,zero
  102e0c:	31400236 	bltu	r6,r5,102e18 <__udivsi3+0x44>
  102e10:	314dc83a 	sub	r6,r6,r5
  102e14:	10c4b03a 	or	r2,r2,r3
  102e18:	1806d07a 	srli	r3,r3,1
  102e1c:	280ad07a 	srli	r5,r5,1
  102e20:	183ffa1e 	bne	r3,zero,102e0c <__udivsi3+0x38>
  102e24:	f800283a 	ret
  102e28:	0005883a 	mov	r2,zero
  102e2c:	f800283a 	ret
  102e30:	00c00044 	movi	r3,1
  102e34:	003ff406 	br	102e08 <__udivsi3+0x34>

00102e38 <__umodsi3>:
  102e38:	2005883a 	mov	r2,r4
  102e3c:	2900132e 	bgeu	r5,r4,102e8c <__umodsi3+0x54>
  102e40:	28001216 	blt	r5,zero,102e8c <__umodsi3+0x54>
  102e44:	01800804 	movi	r6,32
  102e48:	00c00044 	movi	r3,1
  102e4c:	00000206 	br	102e58 <__umodsi3+0x20>
  102e50:	30000c26 	beq	r6,zero,102e84 <__umodsi3+0x4c>
  102e54:	28000516 	blt	r5,zero,102e6c <__umodsi3+0x34>
  102e58:	294b883a 	add	r5,r5,r5
  102e5c:	31bfffc4 	addi	r6,r6,-1
  102e60:	18c7883a 	add	r3,r3,r3
  102e64:	293ffa36 	bltu	r5,r4,102e50 <__umodsi3+0x18>
  102e68:	18000626 	beq	r3,zero,102e84 <__umodsi3+0x4c>
  102e6c:	1806d07a 	srli	r3,r3,1
  102e70:	11400136 	bltu	r2,r5,102e78 <__umodsi3+0x40>
  102e74:	1145c83a 	sub	r2,r2,r5
  102e78:	280ad07a 	srli	r5,r5,1
  102e7c:	183ffb1e 	bne	r3,zero,102e6c <__umodsi3+0x34>
  102e80:	f800283a 	ret
  102e84:	2005883a 	mov	r2,r4
  102e88:	f800283a 	ret
  102e8c:	00c00044 	movi	r3,1
  102e90:	003ff606 	br	102e6c <__umodsi3+0x34>

00102e94 <__mulsi3>:
  102e94:	0005883a 	mov	r2,zero
  102e98:	20000726 	beq	r4,zero,102eb8 <__mulsi3+0x24>
  102e9c:	20c0004c 	andi	r3,r4,1
  102ea0:	2008d07a 	srli	r4,r4,1
  102ea4:	18000126 	beq	r3,zero,102eac <__mulsi3+0x18>
  102ea8:	1145883a 	add	r2,r2,r5
  102eac:	294b883a 	add	r5,r5,r5
  102eb0:	203ffa1e 	bne	r4,zero,102e9c <__mulsi3+0x8>
  102eb4:	f800283a 	ret
  102eb8:	f800283a 	ret

00102ebc <memcpy>:
  102ebc:	2005883a 	mov	r2,r4
  102ec0:	0007883a 	mov	r3,zero
  102ec4:	30c0011e 	bne	r6,r3,102ecc <memcpy+0x10>
  102ec8:	f800283a 	ret
  102ecc:	28cf883a 	add	r7,r5,r3
  102ed0:	39c00003 	ldbu	r7,0(r7)
  102ed4:	10c9883a 	add	r4,r2,r3
  102ed8:	18c00044 	addi	r3,r3,1
  102edc:	21c00005 	stb	r7,0(r4)
  102ee0:	003ff806 	br	102ec4 <memcpy+0x8>

00102ee4 <_printf_r>:
  102ee4:	defffd04 	addi	sp,sp,-12
  102ee8:	dfc00015 	stw	ra,0(sp)
  102eec:	d9800115 	stw	r6,4(sp)
  102ef0:	d9c00215 	stw	r7,8(sp)
  102ef4:	21800217 	ldw	r6,8(r4)
  102ef8:	00800434 	movhi	r2,16
  102efc:	108d7604 	addi	r2,r2,13784
  102f00:	30800115 	stw	r2,4(r6)
  102f04:	280d883a 	mov	r6,r5
  102f08:	21400217 	ldw	r5,8(r4)
  102f0c:	d9c00104 	addi	r7,sp,4
  102f10:	01030a80 	call	1030a8 <___vfprintf_internal_r>
  102f14:	dfc00017 	ldw	ra,0(sp)
  102f18:	dec00304 	addi	sp,sp,12
  102f1c:	f800283a 	ret

00102f20 <printf>:
  102f20:	defffc04 	addi	sp,sp,-16
  102f24:	dfc00015 	stw	ra,0(sp)
  102f28:	d9400115 	stw	r5,4(sp)
  102f2c:	d9800215 	stw	r6,8(sp)
  102f30:	d9c00315 	stw	r7,12(sp)
  102f34:	00800074 	movhi	r2,1
  102f38:	10c50f17 	ldw	r3,5180(r2)
  102f3c:	00800434 	movhi	r2,16
  102f40:	108d7604 	addi	r2,r2,13784
  102f44:	19400217 	ldw	r5,8(r3)
  102f48:	d9800104 	addi	r6,sp,4
  102f4c:	28800115 	stw	r2,4(r5)
  102f50:	200b883a 	mov	r5,r4
  102f54:	19000217 	ldw	r4,8(r3)
  102f58:	01035c00 	call	1035c0 <__vfprintf_internal>
  102f5c:	dfc00017 	ldw	ra,0(sp)
  102f60:	dec00404 	addi	sp,sp,16
  102f64:	f800283a 	ret

00102f68 <_putchar_r>:
  102f68:	21800217 	ldw	r6,8(r4)
  102f6c:	01036d01 	jmpi	1036d0 <_putc_r>

00102f70 <putchar>:
  102f70:	00800074 	movhi	r2,1
  102f74:	10850f17 	ldw	r2,5180(r2)
  102f78:	200b883a 	mov	r5,r4
  102f7c:	11800217 	ldw	r6,8(r2)
  102f80:	00800074 	movhi	r2,1
  102f84:	11050f17 	ldw	r4,5180(r2)
  102f88:	01036d01 	jmpi	1036d0 <_putc_r>

00102f8c <_puts_r>:
  102f8c:	defffd04 	addi	sp,sp,-12
  102f90:	dc000015 	stw	r16,0(sp)
  102f94:	2021883a 	mov	r16,r4
  102f98:	2809883a 	mov	r4,r5
  102f9c:	dfc00215 	stw	ra,8(sp)
  102fa0:	dc400115 	stw	r17,4(sp)
  102fa4:	2823883a 	mov	r17,r5
  102fa8:	01030200 	call	103020 <strlen>
  102fac:	81400217 	ldw	r5,8(r16)
  102fb0:	00c00434 	movhi	r3,16
  102fb4:	18cd7604 	addi	r3,r3,13784
  102fb8:	28c00115 	stw	r3,4(r5)
  102fbc:	100f883a 	mov	r7,r2
  102fc0:	880d883a 	mov	r6,r17
  102fc4:	8009883a 	mov	r4,r16
  102fc8:	01035d80 	call	1035d8 <__sfvwrite_small_dev>
  102fcc:	10ffffe0 	cmpeqi	r3,r2,-1
  102fd0:	18000a1e 	bne	r3,zero,102ffc <_puts_r+0x70>
  102fd4:	80800217 	ldw	r2,8(r16)
  102fd8:	81400217 	ldw	r5,8(r16)
  102fdc:	01800434 	movhi	r6,16
  102fe0:	10800117 	ldw	r2,4(r2)
  102fe4:	01c00044 	movi	r7,1
  102fe8:	319ae804 	addi	r6,r6,27552
  102fec:	8009883a 	mov	r4,r16
  102ff0:	103ee83a 	callr	r2
  102ff4:	10bfffe0 	cmpeqi	r2,r2,-1
  102ff8:	0085c83a 	sub	r2,zero,r2
  102ffc:	dfc00217 	ldw	ra,8(sp)
  103000:	dc400117 	ldw	r17,4(sp)
  103004:	dc000017 	ldw	r16,0(sp)
  103008:	dec00304 	addi	sp,sp,12
  10300c:	f800283a 	ret

00103010 <puts>:
  103010:	00800074 	movhi	r2,1
  103014:	200b883a 	mov	r5,r4
  103018:	11050f17 	ldw	r4,5180(r2)
  10301c:	0102f8c1 	jmpi	102f8c <_puts_r>

00103020 <strlen>:
  103020:	2005883a 	mov	r2,r4
  103024:	10c00007 	ldb	r3,0(r2)
  103028:	1800021e 	bne	r3,zero,103034 <strlen+0x14>
  10302c:	1105c83a 	sub	r2,r2,r4
  103030:	f800283a 	ret
  103034:	10800044 	addi	r2,r2,1
  103038:	003ffa06 	br	103024 <strlen+0x4>

0010303c <print_repeat>:
  10303c:	defffb04 	addi	sp,sp,-20
  103040:	dc800315 	stw	r18,12(sp)
  103044:	dc400215 	stw	r17,8(sp)
  103048:	dc000115 	stw	r16,4(sp)
  10304c:	dfc00415 	stw	ra,16(sp)
  103050:	2025883a 	mov	r18,r4
  103054:	2823883a 	mov	r17,r5
  103058:	d9800005 	stb	r6,0(sp)
  10305c:	3821883a 	mov	r16,r7
  103060:	04000716 	blt	zero,r16,103080 <print_repeat+0x44>
  103064:	0005883a 	mov	r2,zero
  103068:	dfc00417 	ldw	ra,16(sp)
  10306c:	dc800317 	ldw	r18,12(sp)
  103070:	dc400217 	ldw	r17,8(sp)
  103074:	dc000117 	ldw	r16,4(sp)
  103078:	dec00504 	addi	sp,sp,20
  10307c:	f800283a 	ret
  103080:	88800117 	ldw	r2,4(r17)
  103084:	01c00044 	movi	r7,1
  103088:	d80d883a 	mov	r6,sp
  10308c:	880b883a 	mov	r5,r17
  103090:	9009883a 	mov	r4,r18
  103094:	103ee83a 	callr	r2
  103098:	843fffc4 	addi	r16,r16,-1
  10309c:	103ff026 	beq	r2,zero,103060 <print_repeat+0x24>
  1030a0:	00bfffc4 	movi	r2,-1
  1030a4:	003ff006 	br	103068 <print_repeat+0x2c>

001030a8 <___vfprintf_internal_r>:
  1030a8:	deffe604 	addi	sp,sp,-104
  1030ac:	df001815 	stw	fp,96(sp)
  1030b0:	ddc01715 	stw	r23,92(sp)
  1030b4:	dd801615 	stw	r22,88(sp)
  1030b8:	dd001415 	stw	r20,80(sp)
  1030bc:	dcc01315 	stw	r19,76(sp)
  1030c0:	dc801215 	stw	r18,72(sp)
  1030c4:	dc401115 	stw	r17,68(sp)
  1030c8:	dc001015 	stw	r16,64(sp)
  1030cc:	dfc01915 	stw	ra,100(sp)
  1030d0:	dd401515 	stw	r21,84(sp)
  1030d4:	2021883a 	mov	r16,r4
  1030d8:	282d883a 	mov	r22,r5
  1030dc:	d9800515 	stw	r6,20(sp)
  1030e0:	382f883a 	mov	r23,r7
  1030e4:	0039883a 	mov	fp,zero
  1030e8:	d8000215 	stw	zero,8(sp)
  1030ec:	0027883a 	mov	r19,zero
  1030f0:	0029883a 	mov	r20,zero
  1030f4:	0025883a 	mov	r18,zero
  1030f8:	0023883a 	mov	r17,zero
  1030fc:	d8000115 	stw	zero,4(sp)
  103100:	d8000015 	stw	zero,0(sp)
  103104:	0005883a 	mov	r2,zero
  103108:	00000506 	br	103120 <___vfprintf_internal_r+0x78>
  10310c:	11800060 	cmpeqi	r6,r2,1
  103110:	3000331e 	bne	r6,zero,1031e0 <___vfprintf_internal_r+0x138>
  103114:	11800088 	cmpgei	r6,r2,2
  103118:	30000a1e 	bne	r6,zero,103144 <___vfprintf_internal_r+0x9c>
  10311c:	10001826 	beq	r2,zero,103180 <___vfprintf_internal_r+0xd8>
  103120:	d8c00517 	ldw	r3,20(sp)
  103124:	18c00044 	addi	r3,r3,1
  103128:	197fffc3 	ldbu	r5,-1(r3)
  10312c:	d8c00515 	stw	r3,20(sp)
  103130:	29003fcc 	andi	r4,r5,255
  103134:	2100201c 	xori	r4,r4,128
  103138:	213fe004 	addi	r4,r4,-128
  10313c:	203ff31e 	bne	r4,zero,10310c <___vfprintf_internal_r+0x64>
  103140:	00001a06 	br	1031ac <___vfprintf_internal_r+0x104>
  103144:	118000a0 	cmpeqi	r6,r2,2
  103148:	3000291e 	bne	r6,zero,1031f0 <___vfprintf_internal_r+0x148>
  10314c:	118000e0 	cmpeqi	r6,r2,3
  103150:	303ff326 	beq	r6,zero,103120 <___vfprintf_internal_r+0x78>
  103154:	297ff404 	addi	r5,r5,-48
  103158:	29403fcc 	andi	r5,r5,255
  10315c:	298002a8 	cmpgeui	r6,r5,10
  103160:	3000391e 	bne	r6,zero,103248 <___vfprintf_internal_r+0x1a0>
  103164:	913fffe0 	cmpeqi	r4,r18,-1
  103168:	2000351e 	bne	r4,zero,103240 <___vfprintf_internal_r+0x198>
  10316c:	900890ba 	slli	r4,r18,2
  103170:	24a5883a 	add	r18,r4,r18
  103174:	9024907a 	slli	r18,r18,1
  103178:	2ca5883a 	add	r18,r5,r18
  10317c:	003fe806 	br	103120 <___vfprintf_internal_r+0x78>
  103180:	21000960 	cmpeqi	r4,r4,37
  103184:	2000fe1e 	bne	r4,zero,103580 <___vfprintf_internal_r+0x4d8>
  103188:	b0800117 	ldw	r2,4(r22)
  10318c:	d9400805 	stb	r5,32(sp)
  103190:	01c00044 	movi	r7,1
  103194:	d9800804 	addi	r6,sp,32
  103198:	b00b883a 	mov	r5,r22
  10319c:	8009883a 	mov	r4,r16
  1031a0:	103ee83a 	callr	r2
  1031a4:	10001e26 	beq	r2,zero,103220 <___vfprintf_internal_r+0x178>
  1031a8:	073fffc4 	movi	fp,-1
  1031ac:	e005883a 	mov	r2,fp
  1031b0:	dfc01917 	ldw	ra,100(sp)
  1031b4:	df001817 	ldw	fp,96(sp)
  1031b8:	ddc01717 	ldw	r23,92(sp)
  1031bc:	dd801617 	ldw	r22,88(sp)
  1031c0:	dd401517 	ldw	r21,84(sp)
  1031c4:	dd001417 	ldw	r20,80(sp)
  1031c8:	dcc01317 	ldw	r19,76(sp)
  1031cc:	dc801217 	ldw	r18,72(sp)
  1031d0:	dc401117 	ldw	r17,68(sp)
  1031d4:	dc001017 	ldw	r16,64(sp)
  1031d8:	dec01a04 	addi	sp,sp,104
  1031dc:	f800283a 	ret
  1031e0:	20800c20 	cmpeqi	r2,r4,48
  1031e4:	1000ef1e 	bne	r2,zero,1035a4 <___vfprintf_internal_r+0x4fc>
  1031e8:	20800958 	cmpnei	r2,r4,37
  1031ec:	103fe626 	beq	r2,zero,103188 <___vfprintf_internal_r+0xe0>
  1031f0:	29bff404 	addi	r6,r5,-48
  1031f4:	31803fcc 	andi	r6,r6,255
  1031f8:	308002a8 	cmpgeui	r2,r6,10
  1031fc:	10000c1e 	bne	r2,zero,103230 <___vfprintf_internal_r+0x188>
  103200:	88bfffe0 	cmpeqi	r2,r17,-1
  103204:	1000081e 	bne	r2,zero,103228 <___vfprintf_internal_r+0x180>
  103208:	880490ba 	slli	r2,r17,2
  10320c:	1463883a 	add	r17,r2,r17
  103210:	8822907a 	slli	r17,r17,1
  103214:	3463883a 	add	r17,r6,r17
  103218:	00800084 	movi	r2,2
  10321c:	003fc006 	br	103120 <___vfprintf_internal_r+0x78>
  103220:	e7000044 	addi	fp,fp,1
  103224:	003fbe06 	br	103120 <___vfprintf_internal_r+0x78>
  103228:	0023883a 	mov	r17,zero
  10322c:	003ff906 	br	103214 <___vfprintf_internal_r+0x16c>
  103230:	20800ba0 	cmpeqi	r2,r4,46
  103234:	1000e01e 	bne	r2,zero,1035b8 <___vfprintf_internal_r+0x510>
  103238:	00800084 	movi	r2,2
  10323c:	003fc506 	br	103154 <___vfprintf_internal_r+0xac>
  103240:	0025883a 	mov	r18,zero
  103244:	003fcc06 	br	103178 <___vfprintf_internal_r+0xd0>
  103248:	20801b20 	cmpeqi	r2,r4,108
  10324c:	1000d81e 	bne	r2,zero,1035b0 <___vfprintf_internal_r+0x508>
  103250:	90bfffe0 	cmpeqi	r2,r18,-1
  103254:	10000e1e 	bne	r2,zero,103290 <___vfprintf_internal_r+0x1e8>
  103258:	d8000015 	stw	zero,0(sp)
  10325c:	20801a60 	cmpeqi	r2,r4,105
  103260:	1000201e 	bne	r2,zero,1032e4 <___vfprintf_internal_r+0x23c>
  103264:	20801a88 	cmpgei	r2,r4,106
  103268:	10000b1e 	bne	r2,zero,103298 <___vfprintf_internal_r+0x1f0>
  10326c:	208018e0 	cmpeqi	r2,r4,99
  103270:	1000911e 	bne	r2,zero,1034b8 <___vfprintf_internal_r+0x410>
  103274:	20801920 	cmpeqi	r2,r4,100
  103278:	10001a1e 	bne	r2,zero,1032e4 <___vfprintf_internal_r+0x23c>
  10327c:	21001620 	cmpeqi	r4,r4,88
  103280:	203fa026 	beq	r4,zero,103104 <___vfprintf_internal_r+0x5c>
  103284:	00800044 	movi	r2,1
  103288:	d8800215 	stw	r2,8(sp)
  10328c:	00001306 	br	1032dc <___vfprintf_internal_r+0x234>
  103290:	04800044 	movi	r18,1
  103294:	003ff106 	br	10325c <___vfprintf_internal_r+0x1b4>
  103298:	20801ce0 	cmpeqi	r2,r4,115
  10329c:	10009d1e 	bne	r2,zero,103514 <___vfprintf_internal_r+0x46c>
  1032a0:	20801d08 	cmpgei	r2,r4,116
  1032a4:	1000091e 	bne	r2,zero,1032cc <___vfprintf_internal_r+0x224>
  1032a8:	21001be0 	cmpeqi	r4,r4,111
  1032ac:	203f9526 	beq	r4,zero,103104 <___vfprintf_internal_r+0x5c>
  1032b0:	05000204 	movi	r20,8
  1032b4:	b8800104 	addi	r2,r23,4
  1032b8:	d8800415 	stw	r2,16(sp)
  1032bc:	bd400017 	ldw	r21,0(r23)
  1032c0:	0027883a 	mov	r19,zero
  1032c4:	0007883a 	mov	r3,zero
  1032c8:	00001006 	br	10330c <___vfprintf_internal_r+0x264>
  1032cc:	20801d60 	cmpeqi	r2,r4,117
  1032d0:	103ff81e 	bne	r2,zero,1032b4 <___vfprintf_internal_r+0x20c>
  1032d4:	21001e20 	cmpeqi	r4,r4,120
  1032d8:	203f8a26 	beq	r4,zero,103104 <___vfprintf_internal_r+0x5c>
  1032dc:	05000404 	movi	r20,16
  1032e0:	003ff406 	br	1032b4 <___vfprintf_internal_r+0x20c>
  1032e4:	b8800104 	addi	r2,r23,4
  1032e8:	d8800415 	stw	r2,16(sp)
  1032ec:	983ff126 	beq	r19,zero,1032b4 <___vfprintf_internal_r+0x20c>
  1032f0:	bd400017 	ldw	r21,0(r23)
  1032f4:	a8000216 	blt	r21,zero,103300 <___vfprintf_internal_r+0x258>
  1032f8:	04c00044 	movi	r19,1
  1032fc:	003ff106 	br	1032c4 <___vfprintf_internal_r+0x21c>
  103300:	056bc83a 	sub	r21,zero,r21
  103304:	04c00044 	movi	r19,1
  103308:	00c00044 	movi	r3,1
  10330c:	ddc00804 	addi	r23,sp,32
  103310:	b80d883a 	mov	r6,r23
  103314:	a8002e1e 	bne	r21,zero,1033d0 <___vfprintf_internal_r+0x328>
  103318:	b985c83a 	sub	r2,r23,r6
  10331c:	d8800315 	stw	r2,12(sp)
  103320:	9085c83a 	sub	r2,r18,r2
  103324:	0080090e 	bge	zero,r2,10334c <___vfprintf_internal_r+0x2a4>
  103328:	b885883a 	add	r2,r23,r2
  10332c:	d9001004 	addi	r4,sp,64
  103330:	b900042e 	bgeu	r23,r4,103344 <___vfprintf_internal_r+0x29c>
  103334:	bdc00044 	addi	r23,r23,1
  103338:	01000c04 	movi	r4,48
  10333c:	b93fffc5 	stb	r4,-1(r23)
  103340:	b8bffa1e 	bne	r23,r2,10332c <___vfprintf_internal_r+0x284>
  103344:	b985c83a 	sub	r2,r23,r6
  103348:	d8800315 	stw	r2,12(sp)
  10334c:	d8800317 	ldw	r2,12(sp)
  103350:	1895883a 	add	r10,r3,r2
  103354:	d8800017 	ldw	r2,0(sp)
  103358:	8aabc83a 	sub	r21,r17,r10
  10335c:	10003526 	beq	r2,zero,103434 <___vfprintf_internal_r+0x38c>
  103360:	18000a26 	beq	r3,zero,10338c <___vfprintf_internal_r+0x2e4>
  103364:	00800b44 	movi	r2,45
  103368:	d88007c5 	stb	r2,31(sp)
  10336c:	b0800117 	ldw	r2,4(r22)
  103370:	01c00044 	movi	r7,1
  103374:	d98007c4 	addi	r6,sp,31
  103378:	b00b883a 	mov	r5,r22
  10337c:	8009883a 	mov	r4,r16
  103380:	103ee83a 	callr	r2
  103384:	103f881e 	bne	r2,zero,1031a8 <___vfprintf_internal_r+0x100>
  103388:	e7000044 	addi	fp,fp,1
  10338c:	0540070e 	bge	zero,r21,1033ac <___vfprintf_internal_r+0x304>
  103390:	a80f883a 	mov	r7,r21
  103394:	01800c04 	movi	r6,48
  103398:	b00b883a 	mov	r5,r22
  10339c:	8009883a 	mov	r4,r16
  1033a0:	010303c0 	call	10303c <print_repeat>
  1033a4:	103f801e 	bne	r2,zero,1031a8 <___vfprintf_internal_r+0x100>
  1033a8:	e579883a 	add	fp,fp,r21
  1033ac:	d8800317 	ldw	r2,12(sp)
  1033b0:	e5f9883a 	add	fp,fp,r23
  1033b4:	15ebc83a 	sub	r21,r2,r23
  1033b8:	adc5883a 	add	r2,r21,r23
  1033bc:	e5c7c83a 	sub	r3,fp,r23
  1033c0:	00803216 	blt	zero,r2,10348c <___vfprintf_internal_r+0x3e4>
  1033c4:	ddc00417 	ldw	r23,16(sp)
  1033c8:	1839883a 	mov	fp,r3
  1033cc:	003f4d06 	br	103104 <___vfprintf_internal_r+0x5c>
  1033d0:	a00b883a 	mov	r5,r20
  1033d4:	a809883a 	mov	r4,r21
  1033d8:	d8c00615 	stw	r3,24(sp)
  1033dc:	0102dd40 	call	102dd4 <__udivsi3>
  1033e0:	1009883a 	mov	r4,r2
  1033e4:	a00b883a 	mov	r5,r20
  1033e8:	d8800315 	stw	r2,12(sp)
  1033ec:	0102e940 	call	102e94 <__mulsi3>
  1033f0:	a885c83a 	sub	r2,r21,r2
  1033f4:	11000288 	cmpgei	r4,r2,10
  1033f8:	d9c00317 	ldw	r7,12(sp)
  1033fc:	d8c00617 	ldw	r3,24(sp)
  103400:	d9800804 	addi	r6,sp,32
  103404:	2000051e 	bne	r4,zero,10341c <___vfprintf_internal_r+0x374>
  103408:	10800c04 	addi	r2,r2,48
  10340c:	bdc00044 	addi	r23,r23,1
  103410:	b8bfffc5 	stb	r2,-1(r23)
  103414:	382b883a 	mov	r21,r7
  103418:	003fbe06 	br	103314 <___vfprintf_internal_r+0x26c>
  10341c:	d9000217 	ldw	r4,8(sp)
  103420:	20000226 	beq	r4,zero,10342c <___vfprintf_internal_r+0x384>
  103424:	10800dc4 	addi	r2,r2,55
  103428:	003ff806 	br	10340c <___vfprintf_internal_r+0x364>
  10342c:	108015c4 	addi	r2,r2,87
  103430:	003ff606 	br	10340c <___vfprintf_internal_r+0x364>
  103434:	0540090e 	bge	zero,r21,10345c <___vfprintf_internal_r+0x3b4>
  103438:	a80f883a 	mov	r7,r21
  10343c:	01800804 	movi	r6,32
  103440:	b00b883a 	mov	r5,r22
  103444:	8009883a 	mov	r4,r16
  103448:	d8c00615 	stw	r3,24(sp)
  10344c:	010303c0 	call	10303c <print_repeat>
  103450:	103f551e 	bne	r2,zero,1031a8 <___vfprintf_internal_r+0x100>
  103454:	d8c00617 	ldw	r3,24(sp)
  103458:	e579883a 	add	fp,fp,r21
  10345c:	183fd326 	beq	r3,zero,1033ac <___vfprintf_internal_r+0x304>
  103460:	00800b44 	movi	r2,45
  103464:	d88007c5 	stb	r2,31(sp)
  103468:	b0800117 	ldw	r2,4(r22)
  10346c:	01c00044 	movi	r7,1
  103470:	d98007c4 	addi	r6,sp,31
  103474:	b00b883a 	mov	r5,r22
  103478:	8009883a 	mov	r4,r16
  10347c:	103ee83a 	callr	r2
  103480:	103f491e 	bne	r2,zero,1031a8 <___vfprintf_internal_r+0x100>
  103484:	e7000044 	addi	fp,fp,1
  103488:	003fc806 	br	1033ac <___vfprintf_internal_r+0x304>
  10348c:	bdffffc4 	addi	r23,r23,-1
  103490:	b8800003 	ldbu	r2,0(r23)
  103494:	01c00044 	movi	r7,1
  103498:	d98007c4 	addi	r6,sp,31
  10349c:	d88007c5 	stb	r2,31(sp)
  1034a0:	b0800117 	ldw	r2,4(r22)
  1034a4:	b00b883a 	mov	r5,r22
  1034a8:	8009883a 	mov	r4,r16
  1034ac:	103ee83a 	callr	r2
  1034b0:	103fc126 	beq	r2,zero,1033b8 <___vfprintf_internal_r+0x310>
  1034b4:	003f3c06 	br	1031a8 <___vfprintf_internal_r+0x100>
  1034b8:	88800090 	cmplti	r2,r17,2
  1034bc:	1000081e 	bne	r2,zero,1034e0 <___vfprintf_internal_r+0x438>
  1034c0:	8d7fffc4 	addi	r21,r17,-1
  1034c4:	a80f883a 	mov	r7,r21
  1034c8:	01800804 	movi	r6,32
  1034cc:	b00b883a 	mov	r5,r22
  1034d0:	8009883a 	mov	r4,r16
  1034d4:	010303c0 	call	10303c <print_repeat>
  1034d8:	103f331e 	bne	r2,zero,1031a8 <___vfprintf_internal_r+0x100>
  1034dc:	e579883a 	add	fp,fp,r21
  1034e0:	b8800017 	ldw	r2,0(r23)
  1034e4:	01c00044 	movi	r7,1
  1034e8:	d9800804 	addi	r6,sp,32
  1034ec:	d8800805 	stb	r2,32(sp)
  1034f0:	b0800117 	ldw	r2,4(r22)
  1034f4:	b00b883a 	mov	r5,r22
  1034f8:	8009883a 	mov	r4,r16
  1034fc:	bd400104 	addi	r21,r23,4
  103500:	103ee83a 	callr	r2
  103504:	103f281e 	bne	r2,zero,1031a8 <___vfprintf_internal_r+0x100>
  103508:	e7000044 	addi	fp,fp,1
  10350c:	a82f883a 	mov	r23,r21
  103510:	003f0306 	br	103120 <___vfprintf_internal_r+0x78>
  103514:	bd400017 	ldw	r21,0(r23)
  103518:	b8800104 	addi	r2,r23,4
  10351c:	d8800315 	stw	r2,12(sp)
  103520:	a809883a 	mov	r4,r21
  103524:	01030200 	call	103020 <strlen>
  103528:	8895c83a 	sub	r10,r17,r2
  10352c:	102f883a 	mov	r23,r2
  103530:	0280090e 	bge	zero,r10,103558 <___vfprintf_internal_r+0x4b0>
  103534:	500f883a 	mov	r7,r10
  103538:	01800804 	movi	r6,32
  10353c:	b00b883a 	mov	r5,r22
  103540:	8009883a 	mov	r4,r16
  103544:	da800415 	stw	r10,16(sp)
  103548:	010303c0 	call	10303c <print_repeat>
  10354c:	103f161e 	bne	r2,zero,1031a8 <___vfprintf_internal_r+0x100>
  103550:	da800417 	ldw	r10,16(sp)
  103554:	e2b9883a 	add	fp,fp,r10
  103558:	b0800117 	ldw	r2,4(r22)
  10355c:	b80f883a 	mov	r7,r23
  103560:	a80d883a 	mov	r6,r21
  103564:	b00b883a 	mov	r5,r22
  103568:	8009883a 	mov	r4,r16
  10356c:	103ee83a 	callr	r2
  103570:	103f0d1e 	bne	r2,zero,1031a8 <___vfprintf_internal_r+0x100>
  103574:	e5f9883a 	add	fp,fp,r23
  103578:	ddc00317 	ldw	r23,12(sp)
  10357c:	003ee806 	br	103120 <___vfprintf_internal_r+0x78>
  103580:	d8000215 	stw	zero,8(sp)
  103584:	d8000115 	stw	zero,4(sp)
  103588:	d8000015 	stw	zero,0(sp)
  10358c:	04c00044 	movi	r19,1
  103590:	05000284 	movi	r20,10
  103594:	04bfffc4 	movi	r18,-1
  103598:	047fffc4 	movi	r17,-1
  10359c:	00800044 	movi	r2,1
  1035a0:	003edf06 	br	103120 <___vfprintf_internal_r+0x78>
  1035a4:	00800044 	movi	r2,1
  1035a8:	d8800015 	stw	r2,0(sp)
  1035ac:	003f1a06 	br	103218 <___vfprintf_internal_r+0x170>
  1035b0:	00800044 	movi	r2,1
  1035b4:	d8800115 	stw	r2,4(sp)
  1035b8:	008000c4 	movi	r2,3
  1035bc:	003ed806 	br	103120 <___vfprintf_internal_r+0x78>

001035c0 <__vfprintf_internal>:
  1035c0:	00800074 	movhi	r2,1
  1035c4:	300f883a 	mov	r7,r6
  1035c8:	280d883a 	mov	r6,r5
  1035cc:	200b883a 	mov	r5,r4
  1035d0:	11050f17 	ldw	r4,5180(r2)
  1035d4:	01030a81 	jmpi	1030a8 <___vfprintf_internal_r>

001035d8 <__sfvwrite_small_dev>:
  1035d8:	2880000b 	ldhu	r2,0(r5)
  1035dc:	1080020c 	andi	r2,r2,8
  1035e0:	10002526 	beq	r2,zero,103678 <__sfvwrite_small_dev+0xa0>
  1035e4:	2880008f 	ldh	r2,2(r5)
  1035e8:	defffb04 	addi	sp,sp,-20
  1035ec:	dcc00315 	stw	r19,12(sp)
  1035f0:	dc800215 	stw	r18,8(sp)
  1035f4:	dc400115 	stw	r17,4(sp)
  1035f8:	dc000015 	stw	r16,0(sp)
  1035fc:	dfc00415 	stw	ra,16(sp)
  103600:	2027883a 	mov	r19,r4
  103604:	2821883a 	mov	r16,r5
  103608:	3025883a 	mov	r18,r6
  10360c:	3823883a 	mov	r17,r7
  103610:	1000100e 	bge	r2,zero,103654 <__sfvwrite_small_dev+0x7c>
  103614:	8080000b 	ldhu	r2,0(r16)
  103618:	10801014 	ori	r2,r2,64
  10361c:	8080000d 	sth	r2,0(r16)
  103620:	00bfffc4 	movi	r2,-1
  103624:	00000d06 	br	10365c <__sfvwrite_small_dev+0x84>
  103628:	88810050 	cmplti	r2,r17,1025
  10362c:	880f883a 	mov	r7,r17
  103630:	1000011e 	bne	r2,zero,103638 <__sfvwrite_small_dev+0x60>
  103634:	01c10004 	movi	r7,1024
  103638:	8140008f 	ldh	r5,2(r16)
  10363c:	900d883a 	mov	r6,r18
  103640:	9809883a 	mov	r4,r19
  103644:	01037240 	call	103724 <_write_r>
  103648:	00bff20e 	bge	zero,r2,103614 <__sfvwrite_small_dev+0x3c>
  10364c:	88a3c83a 	sub	r17,r17,r2
  103650:	90a5883a 	add	r18,r18,r2
  103654:	047ff416 	blt	zero,r17,103628 <__sfvwrite_small_dev+0x50>
  103658:	0005883a 	mov	r2,zero
  10365c:	dfc00417 	ldw	ra,16(sp)
  103660:	dcc00317 	ldw	r19,12(sp)
  103664:	dc800217 	ldw	r18,8(sp)
  103668:	dc400117 	ldw	r17,4(sp)
  10366c:	dc000017 	ldw	r16,0(sp)
  103670:	dec00504 	addi	sp,sp,20
  103674:	f800283a 	ret
  103678:	00bfffc4 	movi	r2,-1
  10367c:	f800283a 	ret

00103680 <putc>:
  103680:	defffd04 	addi	sp,sp,-12
  103684:	00800434 	movhi	r2,16
  103688:	dc000115 	stw	r16,4(sp)
  10368c:	dfc00215 	stw	ra,8(sp)
  103690:	108d7604 	addi	r2,r2,13784
  103694:	28800115 	stw	r2,4(r5)
  103698:	00800074 	movhi	r2,1
  10369c:	d90000c5 	stb	r4,3(sp)
  1036a0:	2021883a 	mov	r16,r4
  1036a4:	11050f17 	ldw	r4,5180(r2)
  1036a8:	01c00044 	movi	r7,1
  1036ac:	d98000c4 	addi	r6,sp,3
  1036b0:	01035d80 	call	1035d8 <__sfvwrite_small_dev>
  1036b4:	10ffffe0 	cmpeqi	r3,r2,-1
  1036b8:	1800011e 	bne	r3,zero,1036c0 <putc+0x40>
  1036bc:	8005883a 	mov	r2,r16
  1036c0:	dfc00217 	ldw	ra,8(sp)
  1036c4:	dc000117 	ldw	r16,4(sp)
  1036c8:	dec00304 	addi	sp,sp,12
  1036cc:	f800283a 	ret

001036d0 <_putc_r>:
  1036d0:	defffd04 	addi	sp,sp,-12
  1036d4:	00800434 	movhi	r2,16
  1036d8:	dc000115 	stw	r16,4(sp)
  1036dc:	dfc00215 	stw	ra,8(sp)
  1036e0:	108d7604 	addi	r2,r2,13784
  1036e4:	30800115 	stw	r2,4(r6)
  1036e8:	00800074 	movhi	r2,1
  1036ec:	11050f17 	ldw	r4,5180(r2)
  1036f0:	2821883a 	mov	r16,r5
  1036f4:	01c00044 	movi	r7,1
  1036f8:	300b883a 	mov	r5,r6
  1036fc:	d98000c4 	addi	r6,sp,3
  103700:	dc0000c5 	stb	r16,3(sp)
  103704:	01035d80 	call	1035d8 <__sfvwrite_small_dev>
  103708:	10ffffe0 	cmpeqi	r3,r2,-1
  10370c:	1800011e 	bne	r3,zero,103714 <_putc_r+0x44>
  103710:	8005883a 	mov	r2,r16
  103714:	dfc00217 	ldw	ra,8(sp)
  103718:	dc000117 	ldw	r16,4(sp)
  10371c:	dec00304 	addi	sp,sp,12
  103720:	f800283a 	ret

00103724 <_write_r>:
  103724:	defffe04 	addi	sp,sp,-8
  103728:	dc000015 	stw	r16,0(sp)
  10372c:	00800074 	movhi	r2,1
  103730:	2021883a 	mov	r16,r4
  103734:	2809883a 	mov	r4,r5
  103738:	300b883a 	mov	r5,r6
  10373c:	380d883a 	mov	r6,r7
  103740:	dfc00115 	stw	ra,4(sp)
  103744:	10052315 	stw	zero,5260(r2)
  103748:	01039f00 	call	1039f0 <write>
  10374c:	10ffffd8 	cmpnei	r3,r2,-1
  103750:	1800041e 	bne	r3,zero,103764 <_write_r+0x40>
  103754:	00c00074 	movhi	r3,1
  103758:	18c52317 	ldw	r3,5260(r3)
  10375c:	18000126 	beq	r3,zero,103764 <_write_r+0x40>
  103760:	80c00015 	stw	r3,0(r16)
  103764:	dfc00117 	ldw	ra,4(sp)
  103768:	dc000017 	ldw	r16,0(sp)
  10376c:	dec00204 	addi	sp,sp,8
  103770:	f800283a 	ret

00103774 <alt_main>:
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
  103774:	defffd04 	addi	sp,sp,-12
  103778:	dfc00215 	stw	ra,8(sp)
  10377c:	df000115 	stw	fp,4(sp)
  103780:	df000104 	addi	fp,sp,4
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
  103784:	0009883a 	mov	r4,zero
  103788:	0103b280 	call	103b28 <alt_irq_init>

  /* Initialize the operating system */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done alt_irq_init, calling alt_os_init.\r\n");
  ALT_OS_INIT();
  10378c:	0001883a 	nop
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done OS Init, calling alt_sem_create.\r\n");
  ALT_SEM_CREATE (&alt_fd_list_lock, 1);

  /* Initialize the device drivers/software components. */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling alt_sys_init.\r\n");
  alt_sys_init();
  103790:	0103b600 	call	103b60 <alt_sys_init>
   * devices be present (not equal to /dev/null) and if direct drivers
   * aren't being used.
   */

    ALT_LOG_PRINT_BOOT("[alt_main.c] Redirecting IO.\r\n");
    alt_io_redirect(ALT_STDOUT, ALT_STDIN, ALT_STDERR);
  103794:	01800434 	movhi	r6,16
  103798:	319ae904 	addi	r6,r6,27556
  10379c:	01400434 	movhi	r5,16
  1037a0:	295ae904 	addi	r5,r5,27556
  1037a4:	01000434 	movhi	r4,16
  1037a8:	211ae904 	addi	r4,r4,27556
  1037ac:	01061180 	call	106118 <alt_io_redirect>
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
#else
  result = main (alt_argc, alt_argv, alt_envp);
  1037b0:	d0a01d17 	ldw	r2,-32652(gp)
  1037b4:	d0e01e17 	ldw	r3,-32648(gp)
  1037b8:	d1201f17 	ldw	r4,-32644(gp)
  1037bc:	200d883a 	mov	r6,r4
  1037c0:	180b883a 	mov	r5,r3
  1037c4:	1009883a 	mov	r4,r2
  1037c8:	01007800 	call	100780 <main>
  1037cc:	e0bfff15 	stw	r2,-4(fp)
  close(STDOUT_FILENO);
  1037d0:	01000044 	movi	r4,1
  1037d4:	0105ae40 	call	105ae4 <close>
  exit (result);
  1037d8:	e13fff17 	ldw	r4,-4(fp)
  1037dc:	01067880 	call	106788 <exit>

001037e0 <alt_alarm_stop>:
 * alarms. Alternatively an alarm can unregister itself by returning zero when 
 * the alarm executes.
 */

void alt_alarm_stop (alt_alarm* alarm)
{
  1037e0:	defffa04 	addi	sp,sp,-24
  1037e4:	df000515 	stw	fp,20(sp)
  1037e8:	df000504 	addi	fp,sp,20
  1037ec:	e13ffb15 	stw	r4,-20(fp)
  NIOS2_READ_STATUS (context);
  1037f0:	0005303a 	rdctl	r2,status
  1037f4:	e0bffc15 	stw	r2,-16(fp)
  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  1037f8:	e0fffc17 	ldw	r3,-16(fp)
  1037fc:	00bfff84 	movi	r2,-2
  103800:	1884703a 	and	r2,r3,r2
  103804:	1001703a 	wrctl	status,r2
  return context;
  103808:	e0bffc17 	ldw	r2,-16(fp)
  alt_irq_context irq_context;

  irq_context = alt_irq_disable_all();
  10380c:	e0bfff15 	stw	r2,-4(fp)
  alt_llist_remove (&alarm->llist);
  103810:	e0bffb17 	ldw	r2,-20(fp)
  103814:	e0bffd15 	stw	r2,-12(fp)
 * input argument is the element to remove.
 */
     
static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_remove(alt_llist* entry)
{
  entry->next->previous = entry->previous;
  103818:	e0bffd17 	ldw	r2,-12(fp)
  10381c:	10800017 	ldw	r2,0(r2)
  103820:	e0fffd17 	ldw	r3,-12(fp)
  103824:	18c00117 	ldw	r3,4(r3)
  103828:	10c00115 	stw	r3,4(r2)
  entry->previous->next = entry->next;
  10382c:	e0bffd17 	ldw	r2,-12(fp)
  103830:	10800117 	ldw	r2,4(r2)
  103834:	e0fffd17 	ldw	r3,-12(fp)
  103838:	18c00017 	ldw	r3,0(r3)
  10383c:	10c00015 	stw	r3,0(r2)
  /* 
   * Set the entry to point to itself, so that any further calls to
   * alt_llist_remove() are harmless.
   */

  entry->previous = entry;
  103840:	e0bffd17 	ldw	r2,-12(fp)
  103844:	e0fffd17 	ldw	r3,-12(fp)
  103848:	10c00115 	stw	r3,4(r2)
  entry->next     = entry;
  10384c:	e0bffd17 	ldw	r2,-12(fp)
  103850:	e0fffd17 	ldw	r3,-12(fp)
  103854:	10c00015 	stw	r3,0(r2)
  103858:	e0bfff17 	ldw	r2,-4(fp)
  10385c:	e0bffe15 	stw	r2,-8(fp)
  NIOS2_WRITE_STATUS (context);
  103860:	e0bffe17 	ldw	r2,-8(fp)
  103864:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (irq_context);
}
  103868:	0001883a 	nop
  10386c:	e037883a 	mov	sp,fp
  103870:	df000017 	ldw	fp,0(sp)
  103874:	dec00104 	addi	sp,sp,4
  103878:	f800283a 	ret

0010387c <alt_tick>:
 * 
 * alt_tick() is expected to run at interrupt level.
 */

void alt_tick (void)
{
  10387c:	defffb04 	addi	sp,sp,-20
  103880:	dfc00415 	stw	ra,16(sp)
  103884:	df000315 	stw	fp,12(sp)
  103888:	df000304 	addi	fp,sp,12
  alt_alarm* next;
  alt_alarm* alarm = (alt_alarm*) alt_alarm_list.next;
  10388c:	d0a00917 	ldw	r2,-32732(gp)
  103890:	e0bfff15 	stw	r2,-4(fp)

  alt_u32    next_callback;

  /* update the tick counter */

  _alt_nticks++;
  103894:	d0a02117 	ldw	r2,-32636(gp)
  103898:	10800044 	addi	r2,r2,1
  10389c:	d0a02115 	stw	r2,-32636(gp)

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
  1038a0:	00002e06 	br	10395c <alt_tick+0xe0>
  {
    next = (alt_alarm*) alarm->llist.next;
  1038a4:	e0bfff17 	ldw	r2,-4(fp)
  1038a8:	10800017 	ldw	r2,0(r2)
  1038ac:	e0bffe15 	stw	r2,-8(fp)
    /* 
     * Upon the tick-counter rolling over it is safe to clear the 
     * roll-over flag; once the flag is cleared this (or subsequnt)
     * tick events are enabled to generate an alarm event. 
     */
    if ((alarm->rollover) && (_alt_nticks == 0))
  1038b0:	e0bfff17 	ldw	r2,-4(fp)
  1038b4:	10800403 	ldbu	r2,16(r2)
  1038b8:	10803fcc 	andi	r2,r2,255
  1038bc:	10000426 	beq	r2,zero,1038d0 <alt_tick+0x54>
  1038c0:	d0a02117 	ldw	r2,-32636(gp)
  1038c4:	1000021e 	bne	r2,zero,1038d0 <alt_tick+0x54>
    {
      alarm->rollover = 0;
  1038c8:	e0bfff17 	ldw	r2,-4(fp)
  1038cc:	10000405 	stb	zero,16(r2)
    }
    
    /* if the alarm period has expired, make the callback */    
    if ((alarm->time <= _alt_nticks) && (alarm->rollover == 0))
  1038d0:	e0bfff17 	ldw	r2,-4(fp)
  1038d4:	10800217 	ldw	r2,8(r2)
  1038d8:	d0e02117 	ldw	r3,-32636(gp)
  1038dc:	18801d36 	bltu	r3,r2,103954 <alt_tick+0xd8>
  1038e0:	e0bfff17 	ldw	r2,-4(fp)
  1038e4:	10800403 	ldbu	r2,16(r2)
  1038e8:	10803fcc 	andi	r2,r2,255
  1038ec:	1000191e 	bne	r2,zero,103954 <alt_tick+0xd8>
    {
      next_callback = alarm->callback (alarm->context);
  1038f0:	e0bfff17 	ldw	r2,-4(fp)
  1038f4:	10800317 	ldw	r2,12(r2)
  1038f8:	e0ffff17 	ldw	r3,-4(fp)
  1038fc:	18c00517 	ldw	r3,20(r3)
  103900:	1809883a 	mov	r4,r3
  103904:	103ee83a 	callr	r2
  103908:	e0bffd15 	stw	r2,-12(fp)

      /* deactivate the alarm if the return value is zero */

      if (next_callback == 0)
  10390c:	e0bffd17 	ldw	r2,-12(fp)
  103910:	1000031e 	bne	r2,zero,103920 <alt_tick+0xa4>
      {
        alt_alarm_stop (alarm);
  103914:	e13fff17 	ldw	r4,-4(fp)
  103918:	01037e00 	call	1037e0 <alt_alarm_stop>
  10391c:	00000d06 	br	103954 <alt_tick+0xd8>
      }
      else
      {
        alarm->time += next_callback;
  103920:	e0bfff17 	ldw	r2,-4(fp)
  103924:	10c00217 	ldw	r3,8(r2)
  103928:	e0bffd17 	ldw	r2,-12(fp)
  10392c:	1887883a 	add	r3,r3,r2
  103930:	e0bfff17 	ldw	r2,-4(fp)
  103934:	10c00215 	stw	r3,8(r2)
        /* 
         * If the desired alarm time causes a roll-over, set the rollover
         * flag. This will prevent the subsequent tick event from causing
         * an alarm too early.
         */
        if(alarm->time < _alt_nticks)
  103938:	e0bfff17 	ldw	r2,-4(fp)
  10393c:	10c00217 	ldw	r3,8(r2)
  103940:	d0a02117 	ldw	r2,-32636(gp)
  103944:	1880032e 	bgeu	r3,r2,103954 <alt_tick+0xd8>
        {
          alarm->rollover = 1;
  103948:	e0bfff17 	ldw	r2,-4(fp)
  10394c:	00c00044 	movi	r3,1
  103950:	10c00405 	stb	r3,16(r2)
        }
      }
    }
    alarm = next;
  103954:	e0bffe17 	ldw	r2,-8(fp)
  103958:	e0bfff15 	stw	r2,-4(fp)
  while (alarm != (alt_alarm*) &alt_alarm_list)
  10395c:	e0ffff17 	ldw	r3,-4(fp)
  103960:	d0a00904 	addi	r2,gp,-32732
  103964:	18bfcf1e 	bne	r3,r2,1038a4 <alt_tick+0x28>

  /* 
   * Update the operating system specific timer facilities.
   */

  ALT_OS_TIME_TICK();
  103968:	0001883a 	nop
}
  10396c:	0001883a 	nop
  103970:	e037883a 	mov	sp,fp
  103974:	dfc00117 	ldw	ra,4(sp)
  103978:	df000017 	ldw	fp,0(sp)
  10397c:	dec00204 	addi	sp,sp,8
  103980:	f800283a 	ret

00103984 <usleep>:
#if defined (__GNUC__) && __GNUC__ >= 4
int ALT_USLEEP (useconds_t us)
#else
unsigned int ALT_USLEEP (unsigned int us)
#endif
{
  103984:	defffd04 	addi	sp,sp,-12
  103988:	dfc00215 	stw	ra,8(sp)
  10398c:	df000115 	stw	fp,4(sp)
  103990:	df000104 	addi	fp,sp,4
  103994:	e13fff15 	stw	r4,-4(fp)
  return alt_busy_sleep(us);
  103998:	e13fff17 	ldw	r4,-4(fp)
  10399c:	01059500 	call	105950 <alt_busy_sleep>
}
  1039a0:	e037883a 	mov	sp,fp
  1039a4:	dfc00117 	ldw	ra,4(sp)
  1039a8:	df000017 	ldw	fp,0(sp)
  1039ac:	dec00204 	addi	sp,sp,8
  1039b0:	f800283a 	ret

001039b4 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
  1039b4:	defffe04 	addi	sp,sp,-8
  1039b8:	dfc00115 	stw	ra,4(sp)
  1039bc:	df000015 	stw	fp,0(sp)
  1039c0:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
  1039c4:	d0a01217 	ldw	r2,-32696(gp)
  1039c8:	10000326 	beq	r2,zero,1039d8 <alt_get_errno+0x24>
  1039cc:	d0a01217 	ldw	r2,-32696(gp)
  1039d0:	103ee83a 	callr	r2
  1039d4:	00000106 	br	1039dc <alt_get_errno+0x28>
  1039d8:	d0a01c04 	addi	r2,gp,-32656
}
  1039dc:	e037883a 	mov	sp,fp
  1039e0:	dfc00117 	ldw	ra,4(sp)
  1039e4:	df000017 	ldw	fp,0(sp)
  1039e8:	dec00204 	addi	sp,sp,8
  1039ec:	f800283a 	ret

001039f0 <write>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_WRITE (int file, const void *ptr, size_t len)
{
  1039f0:	defff904 	addi	sp,sp,-28
  1039f4:	dfc00615 	stw	ra,24(sp)
  1039f8:	df000515 	stw	fp,20(sp)
  1039fc:	df000504 	addi	fp,sp,20
  103a00:	e13ffd15 	stw	r4,-12(fp)
  103a04:	e17ffc15 	stw	r5,-16(fp)
  103a08:	e1bffb15 	stw	r6,-20(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
  103a0c:	e0bffd17 	ldw	r2,-12(fp)
  103a10:	10000916 	blt	r2,zero,103a38 <write+0x48>
  103a14:	e0fffd17 	ldw	r3,-12(fp)
  103a18:	1805883a 	mov	r2,r3
  103a1c:	1085883a 	add	r2,r2,r2
  103a20:	10c5883a 	add	r2,r2,r3
  103a24:	100490ba 	slli	r2,r2,2
  103a28:	00c00074 	movhi	r3,1
  103a2c:	18c4a704 	addi	r3,r3,4764
  103a30:	10c5883a 	add	r2,r2,r3
  103a34:	00000106 	br	103a3c <write+0x4c>
  103a38:	0005883a 	mov	r2,zero
  103a3c:	e0bfff15 	stw	r2,-4(fp)
  
  if (fd)
  103a40:	e0bfff17 	ldw	r2,-4(fp)
  103a44:	10002126 	beq	r2,zero,103acc <write+0xdc>
     * If the file has not been opened with write access, or if the driver does
     * not provide an implementation of write(), generate an error. Otherwise
     * call the drivers write() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_RDONLY) && fd->dev->write)
  103a48:	e0bfff17 	ldw	r2,-4(fp)
  103a4c:	10800217 	ldw	r2,8(r2)
  103a50:	108000cc 	andi	r2,r2,3
  103a54:	10001826 	beq	r2,zero,103ab8 <write+0xc8>
  103a58:	e0bfff17 	ldw	r2,-4(fp)
  103a5c:	10800017 	ldw	r2,0(r2)
  103a60:	10800617 	ldw	r2,24(r2)
  103a64:	10001426 	beq	r2,zero,103ab8 <write+0xc8>
    {
      
      /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */
      ALT_LOG_WRITE_FUNCTION(ptr,len);

      if ((rval = fd->dev->write(fd, ptr, len)) < 0)
  103a68:	e0bfff17 	ldw	r2,-4(fp)
  103a6c:	10800017 	ldw	r2,0(r2)
  103a70:	10800617 	ldw	r2,24(r2)
  103a74:	e0fffb17 	ldw	r3,-20(fp)
  103a78:	180d883a 	mov	r6,r3
  103a7c:	e17ffc17 	ldw	r5,-16(fp)
  103a80:	e13fff17 	ldw	r4,-4(fp)
  103a84:	103ee83a 	callr	r2
  103a88:	e0bffe15 	stw	r2,-8(fp)
  103a8c:	e0bffe17 	ldw	r2,-8(fp)
  103a90:	1000070e 	bge	r2,zero,103ab0 <write+0xc0>
      {
        ALT_ERRNO = -rval;
  103a94:	01039b40 	call	1039b4 <alt_get_errno>
  103a98:	1007883a 	mov	r3,r2
  103a9c:	e0bffe17 	ldw	r2,-8(fp)
  103aa0:	0085c83a 	sub	r2,zero,r2
  103aa4:	18800015 	stw	r2,0(r3)
        return -1;
  103aa8:	00bfffc4 	movi	r2,-1
  103aac:	00000c06 	br	103ae0 <write+0xf0>
      }
      return rval;
  103ab0:	e0bffe17 	ldw	r2,-8(fp)
  103ab4:	00000a06 	br	103ae0 <write+0xf0>
    }
    else
    {
      ALT_ERRNO = EACCES;
  103ab8:	01039b40 	call	1039b4 <alt_get_errno>
  103abc:	1007883a 	mov	r3,r2
  103ac0:	00800344 	movi	r2,13
  103ac4:	18800015 	stw	r2,0(r3)
  103ac8:	00000406 	br	103adc <write+0xec>
    }
  }
  else  
  {
    ALT_ERRNO = EBADFD;
  103acc:	01039b40 	call	1039b4 <alt_get_errno>
  103ad0:	1007883a 	mov	r3,r2
  103ad4:	00801444 	movi	r2,81
  103ad8:	18800015 	stw	r2,0(r3)
  }
  return -1;
  103adc:	00bfffc4 	movi	r2,-1
}
  103ae0:	e037883a 	mov	sp,fp
  103ae4:	dfc00117 	ldw	ra,4(sp)
  103ae8:	df000017 	ldw	fp,0(sp)
  103aec:	dec00204 	addi	sp,sp,8
  103af0:	f800283a 	ret

00103af4 <alt_dev_reg>:
 */

extern int alt_fs_reg  (alt_dev* dev); 

static ALT_INLINE int alt_dev_reg (alt_dev* dev)
{
  103af4:	defffd04 	addi	sp,sp,-12
  103af8:	dfc00215 	stw	ra,8(sp)
  103afc:	df000115 	stw	fp,4(sp)
  103b00:	df000104 	addi	fp,sp,4
  103b04:	e13fff15 	stw	r4,-4(fp)
  extern alt_llist alt_dev_list;

  return alt_dev_llist_insert ((alt_dev_llist*) dev, &alt_dev_list);
  103b08:	d1600f04 	addi	r5,gp,-32708
  103b0c:	e13fff17 	ldw	r4,-4(fp)
  103b10:	0105c500 	call	105c50 <alt_dev_llist_insert>
}
  103b14:	e037883a 	mov	sp,fp
  103b18:	dfc00117 	ldw	ra,4(sp)
  103b1c:	df000017 	ldw	fp,0(sp)
  103b20:	dec00204 	addi	sp,sp,8
  103b24:	f800283a 	ret

00103b28 <alt_irq_init>:
 * The "base" parameter is ignored and only
 * present for backwards-compatibility.
 */

void alt_irq_init ( const void* base )
{
  103b28:	defffd04 	addi	sp,sp,-12
  103b2c:	dfc00215 	stw	ra,8(sp)
  103b30:	df000115 	stw	fp,4(sp)
  103b34:	df000104 	addi	fp,sp,4
  103b38:	e13fff15 	stw	r4,-4(fp)
    ALTERA_NIOS2_GEN2_IRQ_INIT ( NIOS2_GEN2_0, nios2_gen2_0);
  103b3c:	010647c0 	call	10647c <altera_nios2_gen2_irq_init>
    NIOS2_WRITE_STATUS(NIOS2_STATUS_PIE_MSK
  103b40:	00800044 	movi	r2,1
  103b44:	1001703a 	wrctl	status,r2
    alt_irq_cpu_enable_interrupts();
}
  103b48:	0001883a 	nop
  103b4c:	e037883a 	mov	sp,fp
  103b50:	dfc00117 	ldw	ra,4(sp)
  103b54:	df000017 	ldw	fp,0(sp)
  103b58:	dec00204 	addi	sp,sp,8
  103b5c:	f800283a 	ret

00103b60 <alt_sys_init>:
 * Initialize the non-interrupt controller devices.
 * Called after alt_irq_init().
 */

void alt_sys_init( void )
{
  103b60:	defffe04 	addi	sp,sp,-8
  103b64:	dfc00115 	stw	ra,4(sp)
  103b68:	df000015 	stw	fp,0(sp)
  103b6c:	d839883a 	mov	fp,sp
    ALTERA_AVALON_TIMER_INIT ( TIMER_0, timer_0);
  103b70:	01c0fa04 	movi	r7,1000
  103b74:	01800084 	movi	r6,2
  103b78:	000b883a 	mov	r5,zero
  103b7c:	01002004 	movi	r4,128
  103b80:	01048a80 	call	1048a8 <alt_avalon_timer_sc_init>
    ALTERA_AVALON_JTAG_UART_INIT ( JTAG_UART_0, jtag_uart_0);
  103b84:	01800044 	movi	r6,1
  103b88:	000b883a 	mov	r5,zero
  103b8c:	01000074 	movhi	r4,1
  103b90:	21004f04 	addi	r4,r4,316
  103b94:	0103d340 	call	103d34 <altera_avalon_jtag_uart_init>
  103b98:	01000074 	movhi	r4,1
  103b9c:	21004504 	addi	r4,r4,276
  103ba0:	0103af40 	call	103af4 <alt_dev_reg>
    ALTERA_AVALON_SPI_INIT ( SPI_0, spi_0);
  103ba4:	0001883a 	nop
    ALTERA_AVALON_SYSID_QSYS_INIT ( SYSID_QSYS_0, sysid_qsys_0);
  103ba8:	0001883a 	nop
    ALTERA_ONCHIP_FLASH_INIT ( ONCHIP_FLASH_0, onchip_flash_0);
  103bac:	01000074 	movhi	r4,1
  103bb0:	21045d04 	addi	r4,r4,4468
  103bb4:	01051cc0 	call	1051cc <altera_onchip_flash_init>
}
  103bb8:	0001883a 	nop
  103bbc:	e037883a 	mov	sp,fp
  103bc0:	dfc00117 	ldw	ra,4(sp)
  103bc4:	df000017 	ldw	fp,0(sp)
  103bc8:	dec00204 	addi	sp,sp,8
  103bcc:	f800283a 	ret

00103bd0 <altera_avalon_jtag_uart_read_fd>:
 *
 */

int 
altera_avalon_jtag_uart_read_fd(alt_fd* fd, char* buffer, int space)
{
  103bd0:	defffa04 	addi	sp,sp,-24
  103bd4:	dfc00515 	stw	ra,20(sp)
  103bd8:	df000415 	stw	fp,16(sp)
  103bdc:	df000404 	addi	fp,sp,16
  103be0:	e13ffe15 	stw	r4,-8(fp)
  103be4:	e17ffd15 	stw	r5,-12(fp)
  103be8:	e1bffc15 	stw	r6,-16(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
  103bec:	e0bffe17 	ldw	r2,-8(fp)
  103bf0:	10800017 	ldw	r2,0(r2)
  103bf4:	e0bfff15 	stw	r2,-4(fp)

    return altera_avalon_jtag_uart_read(&dev->state, buffer, space,
  103bf8:	e0bfff17 	ldw	r2,-4(fp)
  103bfc:	10c00a04 	addi	r3,r2,40
  103c00:	e0bffe17 	ldw	r2,-8(fp)
  103c04:	10800217 	ldw	r2,8(r2)
  103c08:	100f883a 	mov	r7,r2
  103c0c:	e1bffc17 	ldw	r6,-16(fp)
  103c10:	e17ffd17 	ldw	r5,-12(fp)
  103c14:	1809883a 	mov	r4,r3
  103c18:	01041f40 	call	1041f4 <altera_avalon_jtag_uart_read>
      fd->fd_flags);
}
  103c1c:	e037883a 	mov	sp,fp
  103c20:	dfc00117 	ldw	ra,4(sp)
  103c24:	df000017 	ldw	fp,0(sp)
  103c28:	dec00204 	addi	sp,sp,8
  103c2c:	f800283a 	ret

00103c30 <altera_avalon_jtag_uart_write_fd>:

int 
altera_avalon_jtag_uart_write_fd(alt_fd* fd, const char* buffer, int space)
{
  103c30:	defffa04 	addi	sp,sp,-24
  103c34:	dfc00515 	stw	ra,20(sp)
  103c38:	df000415 	stw	fp,16(sp)
  103c3c:	df000404 	addi	fp,sp,16
  103c40:	e13ffe15 	stw	r4,-8(fp)
  103c44:	e17ffd15 	stw	r5,-12(fp)
  103c48:	e1bffc15 	stw	r6,-16(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
  103c4c:	e0bffe17 	ldw	r2,-8(fp)
  103c50:	10800017 	ldw	r2,0(r2)
  103c54:	e0bfff15 	stw	r2,-4(fp)

    return altera_avalon_jtag_uart_write(&dev->state, buffer, space,
  103c58:	e0bfff17 	ldw	r2,-4(fp)
  103c5c:	10c00a04 	addi	r3,r2,40
  103c60:	e0bffe17 	ldw	r2,-8(fp)
  103c64:	10800217 	ldw	r2,8(r2)
  103c68:	100f883a 	mov	r7,r2
  103c6c:	e1bffc17 	ldw	r6,-16(fp)
  103c70:	e17ffd17 	ldw	r5,-12(fp)
  103c74:	1809883a 	mov	r4,r3
  103c78:	01044100 	call	104410 <altera_avalon_jtag_uart_write>
      fd->fd_flags);
}
  103c7c:	e037883a 	mov	sp,fp
  103c80:	dfc00117 	ldw	ra,4(sp)
  103c84:	df000017 	ldw	fp,0(sp)
  103c88:	dec00204 	addi	sp,sp,8
  103c8c:	f800283a 	ret

00103c90 <altera_avalon_jtag_uart_close_fd>:

#ifndef ALTERA_AVALON_JTAG_UART_SMALL

int 
altera_avalon_jtag_uart_close_fd(alt_fd* fd)
{
  103c90:	defffc04 	addi	sp,sp,-16
  103c94:	dfc00315 	stw	ra,12(sp)
  103c98:	df000215 	stw	fp,8(sp)
  103c9c:	df000204 	addi	fp,sp,8
  103ca0:	e13ffe15 	stw	r4,-8(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
  103ca4:	e0bffe17 	ldw	r2,-8(fp)
  103ca8:	10800017 	ldw	r2,0(r2)
  103cac:	e0bfff15 	stw	r2,-4(fp)

    return altera_avalon_jtag_uart_close(&dev->state, fd->fd_flags);
  103cb0:	e0bfff17 	ldw	r2,-4(fp)
  103cb4:	10c00a04 	addi	r3,r2,40
  103cb8:	e0bffe17 	ldw	r2,-8(fp)
  103cbc:	10800217 	ldw	r2,8(r2)
  103cc0:	100b883a 	mov	r5,r2
  103cc4:	1809883a 	mov	r4,r3
  103cc8:	01040980 	call	104098 <altera_avalon_jtag_uart_close>
}
  103ccc:	e037883a 	mov	sp,fp
  103cd0:	dfc00117 	ldw	ra,4(sp)
  103cd4:	df000017 	ldw	fp,0(sp)
  103cd8:	dec00204 	addi	sp,sp,8
  103cdc:	f800283a 	ret

00103ce0 <altera_avalon_jtag_uart_ioctl_fd>:

int 
altera_avalon_jtag_uart_ioctl_fd(alt_fd* fd, int req, void* arg)
{
  103ce0:	defffa04 	addi	sp,sp,-24
  103ce4:	dfc00515 	stw	ra,20(sp)
  103ce8:	df000415 	stw	fp,16(sp)
  103cec:	df000404 	addi	fp,sp,16
  103cf0:	e13ffe15 	stw	r4,-8(fp)
  103cf4:	e17ffd15 	stw	r5,-12(fp)
  103cf8:	e1bffc15 	stw	r6,-16(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev;
  103cfc:	e0bffe17 	ldw	r2,-8(fp)
  103d00:	10800017 	ldw	r2,0(r2)
  103d04:	e0bfff15 	stw	r2,-4(fp)

    return altera_avalon_jtag_uart_ioctl(&dev->state, req, arg);
  103d08:	e0bfff17 	ldw	r2,-4(fp)
  103d0c:	10800a04 	addi	r2,r2,40
  103d10:	e1bffc17 	ldw	r6,-16(fp)
  103d14:	e17ffd17 	ldw	r5,-12(fp)
  103d18:	1009883a 	mov	r4,r2
  103d1c:	01041000 	call	104100 <altera_avalon_jtag_uart_ioctl>
}
  103d20:	e037883a 	mov	sp,fp
  103d24:	dfc00117 	ldw	ra,4(sp)
  103d28:	df000017 	ldw	fp,0(sp)
  103d2c:	dec00204 	addi	sp,sp,8
  103d30:	f800283a 	ret

00103d34 <altera_avalon_jtag_uart_init>:
 * Return 1 on sucessful IRQ register and 0 on failure.
 */

void altera_avalon_jtag_uart_init(altera_avalon_jtag_uart_state* sp, 
                                  int irq_controller_id, int irq)
{
  103d34:	defffa04 	addi	sp,sp,-24
  103d38:	dfc00515 	stw	ra,20(sp)
  103d3c:	df000415 	stw	fp,16(sp)
  103d40:	df000404 	addi	fp,sp,16
  103d44:	e13fff15 	stw	r4,-4(fp)
  103d48:	e17ffe15 	stw	r5,-8(fp)
  103d4c:	e1bffd15 	stw	r6,-12(fp)
  ALT_FLAG_CREATE(&sp->events, 0);
  ALT_SEM_CREATE(&sp->read_lock, 1);
  ALT_SEM_CREATE(&sp->write_lock, 1);

  /* enable read interrupts at the device */
  sp->irq_enable = ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
  103d50:	e0bfff17 	ldw	r2,-4(fp)
  103d54:	00c00044 	movi	r3,1
  103d58:	10c00815 	stw	r3,32(r2)

  IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable); 
  103d5c:	e0bfff17 	ldw	r2,-4(fp)
  103d60:	10800017 	ldw	r2,0(r2)
  103d64:	10800104 	addi	r2,r2,4
  103d68:	1007883a 	mov	r3,r2
  103d6c:	e0bfff17 	ldw	r2,-4(fp)
  103d70:	10800817 	ldw	r2,32(r2)
  103d74:	18800035 	stwio	r2,0(r3)
  
  /* register the interrupt handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, altera_avalon_jtag_uart_irq, 
  103d78:	e0bffe17 	ldw	r2,-8(fp)
  103d7c:	e0fffd17 	ldw	r3,-12(fp)
  103d80:	d8000015 	stw	zero,0(sp)
  103d84:	e1ffff17 	ldw	r7,-4(fp)
  103d88:	01800434 	movhi	r6,16
  103d8c:	318f7d04 	addi	r6,r6,15860
  103d90:	180b883a 	mov	r5,r3
  103d94:	1009883a 	mov	r4,r2
  103d98:	0105db00 	call	105db0 <alt_ic_isr_register>
#else
  alt_irq_register(irq, sp, altera_avalon_jtag_uart_irq);
#endif  

  /* Register an alarm to go off every second to check for presence of host */
  sp->host_inactive = 0;
  103d9c:	e0bfff17 	ldw	r2,-4(fp)
  103da0:	10000915 	stw	zero,36(r2)

  if (alt_alarm_start(&sp->alarm, alt_ticks_per_second(), 
  103da4:	e0bfff17 	ldw	r2,-4(fp)
  103da8:	10800204 	addi	r2,r2,8
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
  103dac:	d0e02017 	ldw	r3,-32640(gp)
  103db0:	e1ffff17 	ldw	r7,-4(fp)
  103db4:	01800434 	movhi	r6,16
  103db8:	318ffe04 	addi	r6,r6,16376
  103dbc:	180b883a 	mov	r5,r3
  103dc0:	1009883a 	mov	r4,r2
  103dc4:	01058240 	call	105824 <alt_alarm_start>
  103dc8:	1000040e 	bge	r2,zero,103ddc <altera_avalon_jtag_uart_init+0xa8>
    &altera_avalon_jtag_uart_timeout, sp) < 0)
  {
    /* If we can't set the alarm then record "don't know if host present" 
     * and behave as though the host is present.
     */
    sp->timeout = INT_MAX;
  103dcc:	e0ffff17 	ldw	r3,-4(fp)
  103dd0:	00a00034 	movhi	r2,32768
  103dd4:	10bfffc4 	addi	r2,r2,-1
  103dd8:	18800115 	stw	r2,4(r3)
  }

  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ALARM_REGISTER(sp, sp->base);
}
  103ddc:	0001883a 	nop
  103de0:	e037883a 	mov	sp,fp
  103de4:	dfc00117 	ldw	ra,4(sp)
  103de8:	df000017 	ldw	fp,0(sp)
  103dec:	dec00204 	addi	sp,sp,8
  103df0:	f800283a 	ret

00103df4 <altera_avalon_jtag_uart_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void altera_avalon_jtag_uart_irq(void* context)
#else
static void altera_avalon_jtag_uart_irq(void* context, alt_u32 id)
#endif
{
  103df4:	defff804 	addi	sp,sp,-32
  103df8:	df000715 	stw	fp,28(sp)
  103dfc:	df000704 	addi	fp,sp,28
  103e00:	e13ff915 	stw	r4,-28(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state*) context;
  103e04:	e0bff917 	ldw	r2,-28(fp)
  103e08:	e0bffd15 	stw	r2,-12(fp)
  unsigned int base = sp->base;
  103e0c:	e0bffd17 	ldw	r2,-12(fp)
  103e10:	10800017 	ldw	r2,0(r2)
  103e14:	e0bffc15 	stw	r2,-16(fp)
  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ISR_FUNCTION(base, sp);

  for ( ; ; )
  {
    unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
  103e18:	e0bffc17 	ldw	r2,-16(fp)
  103e1c:	10800104 	addi	r2,r2,4
  103e20:	10800037 	ldwio	r2,0(r2)
  103e24:	e0bffb15 	stw	r2,-20(fp)

    /* Return once nothing more to do */
    if ((control & (ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK | ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)) == 0)
  103e28:	e0bffb17 	ldw	r2,-20(fp)
  103e2c:	1080c00c 	andi	r2,r2,768
  103e30:	10006b26 	beq	r2,zero,103fe0 <altera_avalon_jtag_uart_irq+0x1ec>
      break;

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK)
  103e34:	e0bffb17 	ldw	r2,-20(fp)
  103e38:	1080400c 	andi	r2,r2,256
  103e3c:	10003426 	beq	r2,zero,103f10 <altera_avalon_jtag_uart_irq+0x11c>
    {
      /* process a read irq.  Start by assuming that there is data in the
       * receive FIFO (otherwise why would we have been interrupted?)
       */
      unsigned int data = 1 << ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_OFST;
  103e40:	00800074 	movhi	r2,1
  103e44:	e0bfff15 	stw	r2,-4(fp)
      for ( ; ; )
      {
        /* Check whether there is space in the buffer.  If not then we must not
         * read any characters from the buffer as they will be lost.
         */
        unsigned int next = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
  103e48:	e0bffd17 	ldw	r2,-12(fp)
  103e4c:	10800a17 	ldw	r2,40(r2)
  103e50:	10800044 	addi	r2,r2,1
  103e54:	1081ffcc 	andi	r2,r2,2047
  103e58:	e0bffa15 	stw	r2,-24(fp)
        if (next == sp->rx_out)
  103e5c:	e0bffd17 	ldw	r2,-12(fp)
  103e60:	10800b17 	ldw	r2,44(r2)
  103e64:	e0fffa17 	ldw	r3,-24(fp)
  103e68:	18801426 	beq	r3,r2,103ebc <altera_avalon_jtag_uart_irq+0xc8>
          break;

        /* Try to remove a character from the FIFO and find out whether there
         * are any more characters remaining.
         */
        data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
  103e6c:	e0bffc17 	ldw	r2,-16(fp)
  103e70:	10800037 	ldwio	r2,0(r2)
  103e74:	e0bfff15 	stw	r2,-4(fp)
        
        if ((data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK) == 0)
  103e78:	e0bfff17 	ldw	r2,-4(fp)
  103e7c:	10a0000c 	andi	r2,r2,32768
  103e80:	10001026 	beq	r2,zero,103ec4 <altera_avalon_jtag_uart_irq+0xd0>
          break;

        sp->rx_buf[sp->rx_in] = (data & ALTERA_AVALON_JTAG_UART_DATA_DATA_MSK) >> ALTERA_AVALON_JTAG_UART_DATA_DATA_OFST;
  103e84:	e0bffd17 	ldw	r2,-12(fp)
  103e88:	10800a17 	ldw	r2,40(r2)
  103e8c:	e0ffff17 	ldw	r3,-4(fp)
  103e90:	1809883a 	mov	r4,r3
  103e94:	e0fffd17 	ldw	r3,-12(fp)
  103e98:	1885883a 	add	r2,r3,r2
  103e9c:	11000e05 	stb	r4,56(r2)
        sp->rx_in = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
  103ea0:	e0bffd17 	ldw	r2,-12(fp)
  103ea4:	10800a17 	ldw	r2,40(r2)
  103ea8:	10800044 	addi	r2,r2,1
  103eac:	10c1ffcc 	andi	r3,r2,2047
  103eb0:	e0bffd17 	ldw	r2,-12(fp)
  103eb4:	10c00a15 	stw	r3,40(r2)
      {
  103eb8:	003fe306 	br	103e48 <altera_avalon_jtag_uart_irq+0x54>
          break;
  103ebc:	0001883a 	nop
  103ec0:	00000106 	br	103ec8 <altera_avalon_jtag_uart_irq+0xd4>
          break;
  103ec4:	0001883a 	nop

        /* Post an event to notify jtag_uart_read that a character has been read */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_READ_RDY, OS_FLAG_SET);
      }

      if (data & ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_MSK)
  103ec8:	e0bfff17 	ldw	r2,-4(fp)
  103ecc:	10bfffec 	andhi	r2,r2,65535
  103ed0:	10000f26 	beq	r2,zero,103f10 <altera_avalon_jtag_uart_irq+0x11c>
      {
        /* If there is still data available here then the buffer is full 
         * so turn off receive interrupts until some space becomes available.
         */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
  103ed4:	e0bffd17 	ldw	r2,-12(fp)
  103ed8:	10c00817 	ldw	r3,32(r2)
  103edc:	00bfff84 	movi	r2,-2
  103ee0:	1886703a 	and	r3,r3,r2
  103ee4:	e0bffd17 	ldw	r2,-12(fp)
  103ee8:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(base, sp->irq_enable);
  103eec:	e0bffc17 	ldw	r2,-16(fp)
  103ef0:	10800104 	addi	r2,r2,4
  103ef4:	1007883a 	mov	r3,r2
  103ef8:	e0bffd17 	ldw	r2,-12(fp)
  103efc:	10800817 	ldw	r2,32(r2)
  103f00:	18800035 	stwio	r2,0(r3)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
  103f04:	e0bffc17 	ldw	r2,-16(fp)
  103f08:	10800104 	addi	r2,r2,4
  103f0c:	10800037 	ldwio	r2,0(r2)
      }
    }

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
  103f10:	e0bffb17 	ldw	r2,-20(fp)
  103f14:	1080800c 	andi	r2,r2,512
  103f18:	103fbf26 	beq	r2,zero,103e18 <altera_avalon_jtag_uart_irq+0x24>
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;
  103f1c:	e0bffb17 	ldw	r2,-20(fp)
  103f20:	1004d43a 	srli	r2,r2,16
  103f24:	e0bffe15 	stw	r2,-8(fp)

      while (space > 0 && sp->tx_out != sp->tx_in)
  103f28:	00001306 	br	103f78 <altera_avalon_jtag_uart_irq+0x184>
      {
        IOWR_ALTERA_AVALON_JTAG_UART_DATA(base, sp->tx_buf[sp->tx_out]);
  103f2c:	e0bffc17 	ldw	r2,-16(fp)
  103f30:	e0fffd17 	ldw	r3,-12(fp)
  103f34:	18c00d17 	ldw	r3,52(r3)
  103f38:	e13ffd17 	ldw	r4,-12(fp)
  103f3c:	20c7883a 	add	r3,r4,r3
  103f40:	18c20e03 	ldbu	r3,2104(r3)
  103f44:	18c03fcc 	andi	r3,r3,255
  103f48:	18c0201c 	xori	r3,r3,128
  103f4c:	18ffe004 	addi	r3,r3,-128
  103f50:	10c00035 	stwio	r3,0(r2)

        sp->tx_out = (sp->tx_out + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
  103f54:	e0bffd17 	ldw	r2,-12(fp)
  103f58:	10800d17 	ldw	r2,52(r2)
  103f5c:	10800044 	addi	r2,r2,1
  103f60:	10c1ffcc 	andi	r3,r2,2047
  103f64:	e0bffd17 	ldw	r2,-12(fp)
  103f68:	10c00d15 	stw	r3,52(r2)

        /* Post an event to notify jtag_uart_write that a character has been written */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, OS_FLAG_SET);

        space--;
  103f6c:	e0bffe17 	ldw	r2,-8(fp)
  103f70:	10bfffc4 	addi	r2,r2,-1
  103f74:	e0bffe15 	stw	r2,-8(fp)
      while (space > 0 && sp->tx_out != sp->tx_in)
  103f78:	e0bffe17 	ldw	r2,-8(fp)
  103f7c:	10000526 	beq	r2,zero,103f94 <altera_avalon_jtag_uart_irq+0x1a0>
  103f80:	e0bffd17 	ldw	r2,-12(fp)
  103f84:	10c00d17 	ldw	r3,52(r2)
  103f88:	e0bffd17 	ldw	r2,-12(fp)
  103f8c:	10800c17 	ldw	r2,48(r2)
  103f90:	18bfe61e 	bne	r3,r2,103f2c <altera_avalon_jtag_uart_irq+0x138>
      }

      if (space > 0)
  103f94:	e0bffe17 	ldw	r2,-8(fp)
  103f98:	103f9f26 	beq	r2,zero,103e18 <altera_avalon_jtag_uart_irq+0x24>
      {
        /* If we don't have any more data available then turn off the TX interrupt */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
  103f9c:	e0bffd17 	ldw	r2,-12(fp)
  103fa0:	10c00817 	ldw	r3,32(r2)
  103fa4:	00bfff44 	movi	r2,-3
  103fa8:	1886703a 	and	r3,r3,r2
  103fac:	e0bffd17 	ldw	r2,-12(fp)
  103fb0:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
  103fb4:	e0bffd17 	ldw	r2,-12(fp)
  103fb8:	10800017 	ldw	r2,0(r2)
  103fbc:	10800104 	addi	r2,r2,4
  103fc0:	1007883a 	mov	r3,r2
  103fc4:	e0bffd17 	ldw	r2,-12(fp)
  103fc8:	10800817 	ldw	r2,32(r2)
  103fcc:	18800035 	stwio	r2,0(r3)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
  103fd0:	e0bffc17 	ldw	r2,-16(fp)
  103fd4:	10800104 	addi	r2,r2,4
  103fd8:	10800037 	ldwio	r2,0(r2)
  {
  103fdc:	003f8e06 	br	103e18 <altera_avalon_jtag_uart_irq+0x24>
      break;
  103fe0:	0001883a 	nop
      }
    }
  }
}
  103fe4:	0001883a 	nop
  103fe8:	e037883a 	mov	sp,fp
  103fec:	df000017 	ldw	fp,0(sp)
  103ff0:	dec00104 	addi	sp,sp,4
  103ff4:	f800283a 	ret

00103ff8 <altera_avalon_jtag_uart_timeout>:
 * Timeout routine is called every second
 */

static alt_u32 
altera_avalon_jtag_uart_timeout(void* context) 
{
  103ff8:	defffc04 	addi	sp,sp,-16
  103ffc:	df000315 	stw	fp,12(sp)
  104000:	df000304 	addi	fp,sp,12
  104004:	e13ffd15 	stw	r4,-12(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state *) context;
  104008:	e0bffd17 	ldw	r2,-12(fp)
  10400c:	e0bfff15 	stw	r2,-4(fp)

  unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base);
  104010:	e0bfff17 	ldw	r2,-4(fp)
  104014:	10800017 	ldw	r2,0(r2)
  104018:	10800104 	addi	r2,r2,4
  10401c:	10800037 	ldwio	r2,0(r2)
  104020:	e0bffe15 	stw	r2,-8(fp)

  if (control & ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK)
  104024:	e0bffe17 	ldw	r2,-8(fp)
  104028:	1081000c 	andi	r2,r2,1024
  10402c:	10000b26 	beq	r2,zero,10405c <altera_avalon_jtag_uart_timeout+0x64>
  {
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable | ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK);
  104030:	e0bfff17 	ldw	r2,-4(fp)
  104034:	10800017 	ldw	r2,0(r2)
  104038:	10800104 	addi	r2,r2,4
  10403c:	1007883a 	mov	r3,r2
  104040:	e0bfff17 	ldw	r2,-4(fp)
  104044:	10800817 	ldw	r2,32(r2)
  104048:	10810014 	ori	r2,r2,1024
  10404c:	18800035 	stwio	r2,0(r3)
    sp->host_inactive = 0;
  104050:	e0bfff17 	ldw	r2,-4(fp)
  104054:	10000915 	stw	zero,36(r2)
  104058:	00000a06 	br	104084 <altera_avalon_jtag_uart_timeout+0x8c>
  }
  else if (sp->host_inactive < INT_MAX - 2) {
  10405c:	e0bfff17 	ldw	r2,-4(fp)
  104060:	10c00917 	ldw	r3,36(r2)
  104064:	00a00034 	movhi	r2,32768
  104068:	10bfff04 	addi	r2,r2,-4
  10406c:	10c00536 	bltu	r2,r3,104084 <altera_avalon_jtag_uart_timeout+0x8c>
    sp->host_inactive++;
  104070:	e0bfff17 	ldw	r2,-4(fp)
  104074:	10800917 	ldw	r2,36(r2)
  104078:	10c00044 	addi	r3,r2,1
  10407c:	e0bfff17 	ldw	r2,-4(fp)
  104080:	10c00915 	stw	r3,36(r2)
  104084:	d0a02017 	ldw	r2,-32640(gp)
      ALT_FLAG_POST (sp->events, ALT_JTAG_UART_TIMEOUT, OS_FLAG_SET);
    }
  }

  return alt_ticks_per_second();
}
  104088:	e037883a 	mov	sp,fp
  10408c:	df000017 	ldw	fp,0(sp)
  104090:	dec00104 	addi	sp,sp,4
  104094:	f800283a 	ret

00104098 <altera_avalon_jtag_uart_close>:
 * The close routine is not implemented for the small driver; instead it will
 * map to null. This is because the small driver simply waits while characters
 * are transmitted; there is no interrupt-serviced buffer to empty 
 */
int altera_avalon_jtag_uart_close(altera_avalon_jtag_uart_state* sp, int flags)
{
  104098:	defffd04 	addi	sp,sp,-12
  10409c:	df000215 	stw	fp,8(sp)
  1040a0:	df000204 	addi	fp,sp,8
  1040a4:	e13fff15 	stw	r4,-4(fp)
  1040a8:	e17ffe15 	stw	r5,-8(fp)
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
  1040ac:	00000506 	br	1040c4 <altera_avalon_jtag_uart_close+0x2c>
    if (flags & O_NONBLOCK) {
  1040b0:	e0bffe17 	ldw	r2,-8(fp)
  1040b4:	1090000c 	andi	r2,r2,16384
  1040b8:	10000226 	beq	r2,zero,1040c4 <altera_avalon_jtag_uart_close+0x2c>
      return -EWOULDBLOCK; 
  1040bc:	00bffd44 	movi	r2,-11
  1040c0:	00000b06 	br	1040f0 <altera_avalon_jtag_uart_close+0x58>
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
  1040c4:	e0bfff17 	ldw	r2,-4(fp)
  1040c8:	10c00d17 	ldw	r3,52(r2)
  1040cc:	e0bfff17 	ldw	r2,-4(fp)
  1040d0:	10800c17 	ldw	r2,48(r2)
  1040d4:	18800526 	beq	r3,r2,1040ec <altera_avalon_jtag_uart_close+0x54>
  1040d8:	e0bfff17 	ldw	r2,-4(fp)
  1040dc:	10c00917 	ldw	r3,36(r2)
  1040e0:	e0bfff17 	ldw	r2,-4(fp)
  1040e4:	10800117 	ldw	r2,4(r2)
  1040e8:	18bff136 	bltu	r3,r2,1040b0 <altera_avalon_jtag_uart_close+0x18>
    }
  }

  return 0;
  1040ec:	0005883a 	mov	r2,zero
}
  1040f0:	e037883a 	mov	sp,fp
  1040f4:	df000017 	ldw	fp,0(sp)
  1040f8:	dec00104 	addi	sp,sp,4
  1040fc:	f800283a 	ret

00104100 <altera_avalon_jtag_uart_ioctl>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_ioctl(altera_avalon_jtag_uart_state* sp, int req,
  void* arg)
{
  104100:	defffa04 	addi	sp,sp,-24
  104104:	df000515 	stw	fp,20(sp)
  104108:	df000504 	addi	fp,sp,20
  10410c:	e13ffd15 	stw	r4,-12(fp)
  104110:	e17ffc15 	stw	r5,-16(fp)
  104114:	e1bffb15 	stw	r6,-20(fp)
  int rc = -ENOTTY;
  104118:	00bff9c4 	movi	r2,-25
  10411c:	e0bfff15 	stw	r2,-4(fp)

  switch (req)
  104120:	e0bffc17 	ldw	r2,-16(fp)
  104124:	109a8060 	cmpeqi	r2,r2,27137
  104128:	1000041e 	bne	r2,zero,10413c <altera_avalon_jtag_uart_ioctl+0x3c>
  10412c:	e0bffc17 	ldw	r2,-16(fp)
  104130:	109a80a0 	cmpeqi	r2,r2,27138
  104134:	1000181e 	bne	r2,zero,104198 <altera_avalon_jtag_uart_ioctl+0x98>
      rc = 0;
    }
    break;

  default:
    break;
  104138:	00002906 	br	1041e0 <altera_avalon_jtag_uart_ioctl+0xe0>
    if (sp->timeout != INT_MAX)
  10413c:	e0bffd17 	ldw	r2,-12(fp)
  104140:	10c00117 	ldw	r3,4(r2)
  104144:	00a00034 	movhi	r2,32768
  104148:	10bfffc4 	addi	r2,r2,-1
  10414c:	18802126 	beq	r3,r2,1041d4 <altera_avalon_jtag_uart_ioctl+0xd4>
      int timeout = *((int *)arg);
  104150:	e0bffb17 	ldw	r2,-20(fp)
  104154:	10800017 	ldw	r2,0(r2)
  104158:	e0bffe15 	stw	r2,-8(fp)
      sp->timeout = (timeout >= 2 && timeout < INT_MAX) ? timeout : INT_MAX - 1;
  10415c:	e0bffe17 	ldw	r2,-8(fp)
  104160:	10800090 	cmplti	r2,r2,2
  104164:	1000061e 	bne	r2,zero,104180 <altera_avalon_jtag_uart_ioctl+0x80>
  104168:	e0fffe17 	ldw	r3,-8(fp)
  10416c:	00a00034 	movhi	r2,32768
  104170:	10bfffc4 	addi	r2,r2,-1
  104174:	18800226 	beq	r3,r2,104180 <altera_avalon_jtag_uart_ioctl+0x80>
  104178:	e0bffe17 	ldw	r2,-8(fp)
  10417c:	00000206 	br	104188 <altera_avalon_jtag_uart_ioctl+0x88>
  104180:	00a00034 	movhi	r2,32768
  104184:	10bfff84 	addi	r2,r2,-2
  104188:	e0fffd17 	ldw	r3,-12(fp)
  10418c:	18800115 	stw	r2,4(r3)
      rc = 0;
  104190:	e03fff15 	stw	zero,-4(fp)
    break;
  104194:	00000f06 	br	1041d4 <altera_avalon_jtag_uart_ioctl+0xd4>
    if (sp->timeout != INT_MAX)
  104198:	e0bffd17 	ldw	r2,-12(fp)
  10419c:	10c00117 	ldw	r3,4(r2)
  1041a0:	00a00034 	movhi	r2,32768
  1041a4:	10bfffc4 	addi	r2,r2,-1
  1041a8:	18800c26 	beq	r3,r2,1041dc <altera_avalon_jtag_uart_ioctl+0xdc>
      *((int *)arg) = (sp->host_inactive < sp->timeout) ? 1 : 0;
  1041ac:	e0bffd17 	ldw	r2,-12(fp)
  1041b0:	10c00917 	ldw	r3,36(r2)
  1041b4:	e0bffd17 	ldw	r2,-12(fp)
  1041b8:	10800117 	ldw	r2,4(r2)
  1041bc:	1885803a 	cmpltu	r2,r3,r2
  1041c0:	10c03fcc 	andi	r3,r2,255
  1041c4:	e0bffb17 	ldw	r2,-20(fp)
  1041c8:	10c00015 	stw	r3,0(r2)
      rc = 0;
  1041cc:	e03fff15 	stw	zero,-4(fp)
    break;
  1041d0:	00000206 	br	1041dc <altera_avalon_jtag_uart_ioctl+0xdc>
    break;
  1041d4:	0001883a 	nop
  1041d8:	00000106 	br	1041e0 <altera_avalon_jtag_uart_ioctl+0xe0>
    break;
  1041dc:	0001883a 	nop
  }

  return rc;
  1041e0:	e0bfff17 	ldw	r2,-4(fp)
}
  1041e4:	e037883a 	mov	sp,fp
  1041e8:	df000017 	ldw	fp,0(sp)
  1041ec:	dec00104 	addi	sp,sp,4
  1041f0:	f800283a 	ret

001041f4 <altera_avalon_jtag_uart_read>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_read(altera_avalon_jtag_uart_state* sp, 
  char * buffer, int space, int flags)
{
  1041f4:	defff304 	addi	sp,sp,-52
  1041f8:	dfc00c15 	stw	ra,48(sp)
  1041fc:	df000b15 	stw	fp,44(sp)
  104200:	df000b04 	addi	fp,sp,44
  104204:	e13ff815 	stw	r4,-32(fp)
  104208:	e17ff715 	stw	r5,-36(fp)
  10420c:	e1bff615 	stw	r6,-40(fp)
  104210:	e1fff515 	stw	r7,-44(fp)
  char * ptr = buffer;
  104214:	e0bff717 	ldw	r2,-36(fp)
  104218:	e0bfff15 	stw	r2,-4(fp)
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);

  while (space > 0)
  10421c:	00004706 	br	10433c <altera_avalon_jtag_uart_read+0x148>
    unsigned int in, out;

    /* Read as much data as possible */
    do
    {
      in  = sp->rx_in;
  104220:	e0bff817 	ldw	r2,-32(fp)
  104224:	10800a17 	ldw	r2,40(r2)
  104228:	e0bffd15 	stw	r2,-12(fp)
      out = sp->rx_out;
  10422c:	e0bff817 	ldw	r2,-32(fp)
  104230:	10800b17 	ldw	r2,44(r2)
  104234:	e0bffc15 	stw	r2,-16(fp)

      if (in >= out)
  104238:	e0fffd17 	ldw	r3,-12(fp)
  10423c:	e0bffc17 	ldw	r2,-16(fp)
  104240:	18800536 	bltu	r3,r2,104258 <altera_avalon_jtag_uart_read+0x64>
        n = in - out;
  104244:	e0fffd17 	ldw	r3,-12(fp)
  104248:	e0bffc17 	ldw	r2,-16(fp)
  10424c:	1885c83a 	sub	r2,r3,r2
  104250:	e0bffe15 	stw	r2,-8(fp)
  104254:	00000406 	br	104268 <altera_avalon_jtag_uart_read+0x74>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - out;
  104258:	00c20004 	movi	r3,2048
  10425c:	e0bffc17 	ldw	r2,-16(fp)
  104260:	1885c83a 	sub	r2,r3,r2
  104264:	e0bffe15 	stw	r2,-8(fp)

      if (n == 0)
  104268:	e0bffe17 	ldw	r2,-8(fp)
  10426c:	10001e26 	beq	r2,zero,1042e8 <altera_avalon_jtag_uart_read+0xf4>
        break; /* No more data available */

      if (n > space)
  104270:	e0fff617 	ldw	r3,-40(fp)
  104274:	e0bffe17 	ldw	r2,-8(fp)
  104278:	1880022e 	bgeu	r3,r2,104284 <altera_avalon_jtag_uart_read+0x90>
        n = space;
  10427c:	e0bff617 	ldw	r2,-40(fp)
  104280:	e0bffe15 	stw	r2,-8(fp)

      memcpy(ptr, sp->rx_buf + out, n);
  104284:	e0bff817 	ldw	r2,-32(fp)
  104288:	10c00e04 	addi	r3,r2,56
  10428c:	e0bffc17 	ldw	r2,-16(fp)
  104290:	1885883a 	add	r2,r3,r2
  104294:	e1bffe17 	ldw	r6,-8(fp)
  104298:	100b883a 	mov	r5,r2
  10429c:	e13fff17 	ldw	r4,-4(fp)
  1042a0:	0102ebc0 	call	102ebc <memcpy>
      ptr   += n;
  1042a4:	e0ffff17 	ldw	r3,-4(fp)
  1042a8:	e0bffe17 	ldw	r2,-8(fp)
  1042ac:	1885883a 	add	r2,r3,r2
  1042b0:	e0bfff15 	stw	r2,-4(fp)
      space -= n;
  1042b4:	e0fff617 	ldw	r3,-40(fp)
  1042b8:	e0bffe17 	ldw	r2,-8(fp)
  1042bc:	1885c83a 	sub	r2,r3,r2
  1042c0:	e0bff615 	stw	r2,-40(fp)

      sp->rx_out = (out + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
  1042c4:	e0fffc17 	ldw	r3,-16(fp)
  1042c8:	e0bffe17 	ldw	r2,-8(fp)
  1042cc:	1885883a 	add	r2,r3,r2
  1042d0:	10c1ffcc 	andi	r3,r2,2047
  1042d4:	e0bff817 	ldw	r2,-32(fp)
  1042d8:	10c00b15 	stw	r3,44(r2)
    }
    while (space > 0);
  1042dc:	e0bff617 	ldw	r2,-40(fp)
  1042e0:	00bfcf16 	blt	zero,r2,104220 <altera_avalon_jtag_uart_read+0x2c>
  1042e4:	00000106 	br	1042ec <altera_avalon_jtag_uart_read+0xf8>
        break; /* No more data available */
  1042e8:	0001883a 	nop

    /* If we read any data then return it */
    if (ptr != buffer)
  1042ec:	e0ffff17 	ldw	r3,-4(fp)
  1042f0:	e0bff717 	ldw	r2,-36(fp)
  1042f4:	1880141e 	bne	r3,r2,104348 <altera_avalon_jtag_uart_read+0x154>
      break;

    /* If in non-blocking mode then return error */
    if (flags & O_NONBLOCK)
  1042f8:	e0bff517 	ldw	r2,-44(fp)
  1042fc:	1090000c 	andi	r2,r2,16384
  104300:	1000131e 	bne	r2,zero,104350 <altera_avalon_jtag_uart_read+0x15c>
      while (in == sp->rx_in && sp->host_inactive < sp->timeout)
        ;
    }
#else
    /* No OS: Always spin */
    while (in == sp->rx_in && sp->host_inactive < sp->timeout)
  104304:	0001883a 	nop
  104308:	e0bff817 	ldw	r2,-32(fp)
  10430c:	10800a17 	ldw	r2,40(r2)
  104310:	e0fffd17 	ldw	r3,-12(fp)
  104314:	1880051e 	bne	r3,r2,10432c <altera_avalon_jtag_uart_read+0x138>
  104318:	e0bff817 	ldw	r2,-32(fp)
  10431c:	10c00917 	ldw	r3,36(r2)
  104320:	e0bff817 	ldw	r2,-32(fp)
  104324:	10800117 	ldw	r2,4(r2)
  104328:	18bff736 	bltu	r3,r2,104308 <altera_avalon_jtag_uart_read+0x114>
      ;
#endif /* __ucosii__ */

    if (in == sp->rx_in)
  10432c:	e0bff817 	ldw	r2,-32(fp)
  104330:	10800a17 	ldw	r2,40(r2)
  104334:	e0fffd17 	ldw	r3,-12(fp)
  104338:	18800726 	beq	r3,r2,104358 <altera_avalon_jtag_uart_read+0x164>
  while (space > 0)
  10433c:	e0bff617 	ldw	r2,-40(fp)
  104340:	00bfb716 	blt	zero,r2,104220 <altera_avalon_jtag_uart_read+0x2c>
  104344:	00000506 	br	10435c <altera_avalon_jtag_uart_read+0x168>
      break;
  104348:	0001883a 	nop
  10434c:	00000306 	br	10435c <altera_avalon_jtag_uart_read+0x168>
      break;
  104350:	0001883a 	nop
  104354:	00000106 	br	10435c <altera_avalon_jtag_uart_read+0x168>
      break;
  104358:	0001883a 	nop
   * semaphore so that other threads can access the buffer.
   */

  ALT_SEM_POST (sp->read_lock);

  if (ptr != buffer)
  10435c:	e0ffff17 	ldw	r3,-4(fp)
  104360:	e0bff717 	ldw	r2,-36(fp)
  104364:	18801826 	beq	r3,r2,1043c8 <altera_avalon_jtag_uart_read+0x1d4>
  NIOS2_READ_STATUS (context);
  104368:	0005303a 	rdctl	r2,status
  10436c:	e0bff915 	stw	r2,-28(fp)
  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  104370:	e0fff917 	ldw	r3,-28(fp)
  104374:	00bfff84 	movi	r2,-2
  104378:	1884703a 	and	r2,r3,r2
  10437c:	1001703a 	wrctl	status,r2
  return context;
  104380:	e0bff917 	ldw	r2,-28(fp)
  {
    /* If we read any data then there is space in the buffer so enable interrupts */
    context = alt_irq_disable_all();
  104384:	e0bffb15 	stw	r2,-20(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
  104388:	e0bff817 	ldw	r2,-32(fp)
  10438c:	10800817 	ldw	r2,32(r2)
  104390:	10c00054 	ori	r3,r2,1
  104394:	e0bff817 	ldw	r2,-32(fp)
  104398:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
  10439c:	e0bff817 	ldw	r2,-32(fp)
  1043a0:	10800017 	ldw	r2,0(r2)
  1043a4:	10800104 	addi	r2,r2,4
  1043a8:	1007883a 	mov	r3,r2
  1043ac:	e0bff817 	ldw	r2,-32(fp)
  1043b0:	10800817 	ldw	r2,32(r2)
  1043b4:	18800035 	stwio	r2,0(r3)
  1043b8:	e0bffb17 	ldw	r2,-20(fp)
  1043bc:	e0bffa15 	stw	r2,-24(fp)
  NIOS2_WRITE_STATUS (context);
  1043c0:	e0bffa17 	ldw	r2,-24(fp)
  1043c4:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(context);
  }

  if (ptr != buffer)
  1043c8:	e0ffff17 	ldw	r3,-4(fp)
  1043cc:	e0bff717 	ldw	r2,-36(fp)
  1043d0:	18800426 	beq	r3,r2,1043e4 <altera_avalon_jtag_uart_read+0x1f0>
    return ptr - buffer;
  1043d4:	e0ffff17 	ldw	r3,-4(fp)
  1043d8:	e0bff717 	ldw	r2,-36(fp)
  1043dc:	1885c83a 	sub	r2,r3,r2
  1043e0:	00000606 	br	1043fc <altera_avalon_jtag_uart_read+0x208>
  else if (flags & O_NONBLOCK)
  1043e4:	e0bff517 	ldw	r2,-44(fp)
  1043e8:	1090000c 	andi	r2,r2,16384
  1043ec:	10000226 	beq	r2,zero,1043f8 <altera_avalon_jtag_uart_read+0x204>
    return -EWOULDBLOCK;
  1043f0:	00bffd44 	movi	r2,-11
  1043f4:	00000106 	br	1043fc <altera_avalon_jtag_uart_read+0x208>
  else
    return -EIO;
  1043f8:	00bffec4 	movi	r2,-5
}
  1043fc:	e037883a 	mov	sp,fp
  104400:	dfc00117 	ldw	ra,4(sp)
  104404:	df000017 	ldw	fp,0(sp)
  104408:	dec00204 	addi	sp,sp,8
  10440c:	f800283a 	ret

00104410 <altera_avalon_jtag_uart_write>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_write(altera_avalon_jtag_uart_state* sp, 
  const char * ptr, int count, int flags)
{
  104410:	defff304 	addi	sp,sp,-52
  104414:	dfc00c15 	stw	ra,48(sp)
  104418:	df000b15 	stw	fp,44(sp)
  10441c:	df000b04 	addi	fp,sp,44
  104420:	e13ff815 	stw	r4,-32(fp)
  104424:	e17ff715 	stw	r5,-36(fp)
  104428:	e1bff615 	stw	r6,-40(fp)
  10442c:	e1fff515 	stw	r7,-44(fp)
  /* Remove warning at optimisation level 03 by seting out to 0 */
  unsigned int in, out=0;
  104430:	e03fff15 	stw	zero,-4(fp)
  unsigned int n;
  alt_irq_context context;

  const char * start = ptr;
  104434:	e0bff717 	ldw	r2,-36(fp)
  104438:	e0bffd15 	stw	r2,-12(fp)
  ALT_SEM_PEND (sp->write_lock, 0);

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
  10443c:	00003706 	br	10451c <altera_avalon_jtag_uart_write+0x10c>
    {
      /* We need a stable value of the out pointer to calculate the space available */
      in  = sp->tx_in;
  104440:	e0bff817 	ldw	r2,-32(fp)
  104444:	10800c17 	ldw	r2,48(r2)
  104448:	e0bffc15 	stw	r2,-16(fp)
      out = sp->tx_out;
  10444c:	e0bff817 	ldw	r2,-32(fp)
  104450:	10800d17 	ldw	r2,52(r2)
  104454:	e0bfff15 	stw	r2,-4(fp)

      if (in < out)
  104458:	e0fffc17 	ldw	r3,-16(fp)
  10445c:	e0bfff17 	ldw	r2,-4(fp)
  104460:	1880062e 	bgeu	r3,r2,10447c <altera_avalon_jtag_uart_write+0x6c>
        n = out - 1 - in;
  104464:	e0ffff17 	ldw	r3,-4(fp)
  104468:	e0bffc17 	ldw	r2,-16(fp)
  10446c:	1885c83a 	sub	r2,r3,r2
  104470:	10bfffc4 	addi	r2,r2,-1
  104474:	e0bffe15 	stw	r2,-8(fp)
  104478:	00000b06 	br	1044a8 <altera_avalon_jtag_uart_write+0x98>
      else if (out > 0)
  10447c:	e0bfff17 	ldw	r2,-4(fp)
  104480:	10000526 	beq	r2,zero,104498 <altera_avalon_jtag_uart_write+0x88>
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - in;
  104484:	00c20004 	movi	r3,2048
  104488:	e0bffc17 	ldw	r2,-16(fp)
  10448c:	1885c83a 	sub	r2,r3,r2
  104490:	e0bffe15 	stw	r2,-8(fp)
  104494:	00000406 	br	1044a8 <altera_avalon_jtag_uart_write+0x98>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - 1 - in;
  104498:	00c1ffc4 	movi	r3,2047
  10449c:	e0bffc17 	ldw	r2,-16(fp)
  1044a0:	1885c83a 	sub	r2,r3,r2
  1044a4:	e0bffe15 	stw	r2,-8(fp)

      if (n == 0)
  1044a8:	e0bffe17 	ldw	r2,-8(fp)
  1044ac:	10001e26 	beq	r2,zero,104528 <altera_avalon_jtag_uart_write+0x118>
        break;

      if (n > count)
  1044b0:	e0fff617 	ldw	r3,-40(fp)
  1044b4:	e0bffe17 	ldw	r2,-8(fp)
  1044b8:	1880022e 	bgeu	r3,r2,1044c4 <altera_avalon_jtag_uart_write+0xb4>
        n = count;
  1044bc:	e0bff617 	ldw	r2,-40(fp)
  1044c0:	e0bffe15 	stw	r2,-8(fp)

      memcpy(sp->tx_buf + in, ptr, n);
  1044c4:	e0bff817 	ldw	r2,-32(fp)
  1044c8:	10c20e04 	addi	r3,r2,2104
  1044cc:	e0bffc17 	ldw	r2,-16(fp)
  1044d0:	1885883a 	add	r2,r3,r2
  1044d4:	e1bffe17 	ldw	r6,-8(fp)
  1044d8:	e17ff717 	ldw	r5,-36(fp)
  1044dc:	1009883a 	mov	r4,r2
  1044e0:	0102ebc0 	call	102ebc <memcpy>
      ptr   += n;
  1044e4:	e0fff717 	ldw	r3,-36(fp)
  1044e8:	e0bffe17 	ldw	r2,-8(fp)
  1044ec:	1885883a 	add	r2,r3,r2
  1044f0:	e0bff715 	stw	r2,-36(fp)
      count -= n;
  1044f4:	e0fff617 	ldw	r3,-40(fp)
  1044f8:	e0bffe17 	ldw	r2,-8(fp)
  1044fc:	1885c83a 	sub	r2,r3,r2
  104500:	e0bff615 	stw	r2,-40(fp)

      sp->tx_in = (in + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
  104504:	e0fffc17 	ldw	r3,-16(fp)
  104508:	e0bffe17 	ldw	r2,-8(fp)
  10450c:	1885883a 	add	r2,r3,r2
  104510:	10c1ffcc 	andi	r3,r2,2047
  104514:	e0bff817 	ldw	r2,-32(fp)
  104518:	10c00c15 	stw	r3,48(r2)
    while (count > 0)
  10451c:	e0bff617 	ldw	r2,-40(fp)
  104520:	00bfc716 	blt	zero,r2,104440 <altera_avalon_jtag_uart_write+0x30>
  104524:	00000106 	br	10452c <altera_avalon_jtag_uart_write+0x11c>
        break;
  104528:	0001883a 	nop
  NIOS2_READ_STATUS (context);
  10452c:	0005303a 	rdctl	r2,status
  104530:	e0bff915 	stw	r2,-28(fp)
  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  104534:	e0fff917 	ldw	r3,-28(fp)
  104538:	00bfff84 	movi	r2,-2
  10453c:	1884703a 	and	r2,r3,r2
  104540:	1001703a 	wrctl	status,r2
  return context;
  104544:	e0bff917 	ldw	r2,-28(fp)
     * to enable interrupts if there is no space left in the FIFO
     *
     * For now kick the interrupt routine every time to make it transmit 
     * the data 
     */
    context = alt_irq_disable_all();
  104548:	e0bffb15 	stw	r2,-20(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
  10454c:	e0bff817 	ldw	r2,-32(fp)
  104550:	10800817 	ldw	r2,32(r2)
  104554:	10c00094 	ori	r3,r2,2
  104558:	e0bff817 	ldw	r2,-32(fp)
  10455c:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
  104560:	e0bff817 	ldw	r2,-32(fp)
  104564:	10800017 	ldw	r2,0(r2)
  104568:	10800104 	addi	r2,r2,4
  10456c:	1007883a 	mov	r3,r2
  104570:	e0bff817 	ldw	r2,-32(fp)
  104574:	10800817 	ldw	r2,32(r2)
  104578:	18800035 	stwio	r2,0(r3)
  10457c:	e0bffb17 	ldw	r2,-20(fp)
  104580:	e0bffa15 	stw	r2,-24(fp)
  NIOS2_WRITE_STATUS (context);
  104584:	e0bffa17 	ldw	r2,-24(fp)
  104588:	1001703a 	wrctl	status,r2
    /* 
     * If there is any data left then either return now or block until 
     * some has been sent 
     */
    /* consider: test whether there is anything there while doing this and delay for at most 2s. */
    if (count > 0)
  10458c:	e0bff617 	ldw	r2,-40(fp)
  104590:	0080100e 	bge	zero,r2,1045d4 <altera_avalon_jtag_uart_write+0x1c4>
    {
      if (flags & O_NONBLOCK)
  104594:	e0bff517 	ldw	r2,-44(fp)
  104598:	1090000c 	andi	r2,r2,16384
  10459c:	1000101e 	bne	r2,zero,1045e0 <altera_avalon_jtag_uart_write+0x1d0>
      /*
       * No OS present: Always wait for data to be removed from buffer.  Once
       * the interrupt routine has removed some data then we will be able to
       * insert some more.
       */
      while (out == sp->tx_out && sp->host_inactive < sp->timeout)
  1045a0:	0001883a 	nop
  1045a4:	e0bff817 	ldw	r2,-32(fp)
  1045a8:	10800d17 	ldw	r2,52(r2)
  1045ac:	e0ffff17 	ldw	r3,-4(fp)
  1045b0:	1880051e 	bne	r3,r2,1045c8 <altera_avalon_jtag_uart_write+0x1b8>
  1045b4:	e0bff817 	ldw	r2,-32(fp)
  1045b8:	10c00917 	ldw	r3,36(r2)
  1045bc:	e0bff817 	ldw	r2,-32(fp)
  1045c0:	10800117 	ldw	r2,4(r2)
  1045c4:	18bff736 	bltu	r3,r2,1045a4 <altera_avalon_jtag_uart_write+0x194>
        ;
#endif /* __ucosii__ */

      if  (sp->host_inactive)
  1045c8:	e0bff817 	ldw	r2,-32(fp)
  1045cc:	10800917 	ldw	r2,36(r2)
  1045d0:	1000051e 	bne	r2,zero,1045e8 <altera_avalon_jtag_uart_write+0x1d8>
         break;
    }
  }
  while (count > 0);
  1045d4:	e0bff617 	ldw	r2,-40(fp)
  1045d8:	00bfd016 	blt	zero,r2,10451c <altera_avalon_jtag_uart_write+0x10c>
  1045dc:	00000306 	br	1045ec <altera_avalon_jtag_uart_write+0x1dc>
        break;
  1045e0:	0001883a 	nop
  1045e4:	00000106 	br	1045ec <altera_avalon_jtag_uart_write+0x1dc>
         break;
  1045e8:	0001883a 	nop
   * Now that access to the circular buffer is complete, release the write
   * semaphore so that other threads can access the buffer.
   */
  ALT_SEM_POST (sp->write_lock);

  if (ptr != start)
  1045ec:	e0fff717 	ldw	r3,-36(fp)
  1045f0:	e0bffd17 	ldw	r2,-12(fp)
  1045f4:	18800426 	beq	r3,r2,104608 <altera_avalon_jtag_uart_write+0x1f8>
    return ptr - start;
  1045f8:	e0fff717 	ldw	r3,-36(fp)
  1045fc:	e0bffd17 	ldw	r2,-12(fp)
  104600:	1885c83a 	sub	r2,r3,r2
  104604:	00000606 	br	104620 <altera_avalon_jtag_uart_write+0x210>
  else if (flags & O_NONBLOCK)
  104608:	e0bff517 	ldw	r2,-44(fp)
  10460c:	1090000c 	andi	r2,r2,16384
  104610:	10000226 	beq	r2,zero,10461c <altera_avalon_jtag_uart_write+0x20c>
    return -EWOULDBLOCK;
  104614:	00bffd44 	movi	r2,-11
  104618:	00000106 	br	104620 <altera_avalon_jtag_uart_write+0x210>
    sp->tx_out = sp->tx_in = 0;
    return ptr - start + count;
  }
#endif
  else
    return -EIO; /* Host not connected */
  10461c:	00bffec4 	movi	r2,-5
}
  104620:	e037883a 	mov	sp,fp
  104624:	dfc00117 	ldw	ra,4(sp)
  104628:	df000017 	ldw	fp,0(sp)
  10462c:	dec00204 	addi	sp,sp,8
  104630:	f800283a 	ret

00104634 <alt_avalon_spi_command>:

int alt_avalon_spi_command(alt_u32 base, alt_u32 slave,
                           alt_u32 write_length, const alt_u8 * write_data,
                           alt_u32 read_length, alt_u8 * read_data,
                           alt_u32 flags)
{
  104634:	defff404 	addi	sp,sp,-48
  104638:	df000b15 	stw	fp,44(sp)
  10463c:	df000b04 	addi	fp,sp,44
  104640:	e13ff815 	stw	r4,-32(fp)
  104644:	e17ff715 	stw	r5,-36(fp)
  104648:	e1bff615 	stw	r6,-40(fp)
  10464c:	e1fff515 	stw	r7,-44(fp)
  const alt_u8 * write_end = write_data + write_length;
  104650:	e0fff517 	ldw	r3,-44(fp)
  104654:	e0bff617 	ldw	r2,-40(fp)
  104658:	1885883a 	add	r2,r3,r2
  10465c:	e0bffc15 	stw	r2,-16(fp)
  alt_u8 * read_end = read_data + read_length;
  104660:	e0c00217 	ldw	r3,8(fp)
  104664:	e0800117 	ldw	r2,4(fp)
  104668:	1885883a 	add	r2,r3,r2
  10466c:	e0bffb15 	stw	r2,-20(fp)

  alt_u32 write_zeros = read_length;
  104670:	e0800117 	ldw	r2,4(fp)
  104674:	e0bfff15 	stw	r2,-4(fp)
  alt_u32 read_ignore = write_length;
  104678:	e0bff617 	ldw	r2,-40(fp)
  10467c:	e0bffe15 	stw	r2,-8(fp)

  /* We must not send more than two bytes to the target before it has
   * returned any as otherwise it will overflow. */
  /* Unfortunately the hardware does not seem to work with credits > 1,
   * leave it at 1 for now. */
  alt_32 credits = 1;
  104680:	00800044 	movi	r2,1
  104684:	e0bffd15 	stw	r2,-12(fp)
  /* Warning: this function is not currently safe if called in a multi-threaded
   * environment, something above must perform locking to make it safe if more
   * than one thread intends to use it.
   */

  IOWR_ALTERA_AVALON_SPI_SLAVE_SEL(base, 1 << slave);
  104688:	e0bff817 	ldw	r2,-32(fp)
  10468c:	10800504 	addi	r2,r2,20
  104690:	1009883a 	mov	r4,r2
  104694:	00c00044 	movi	r3,1
  104698:	e0bff717 	ldw	r2,-36(fp)
  10469c:	1884983a 	sll	r2,r3,r2
  1046a0:	20800035 	stwio	r2,0(r4)
  
  /* Set the SSO bit (force chipselect) only if the toggle flag is not set */
  if ((flags & ALT_AVALON_SPI_COMMAND_TOGGLE_SS_N) == 0) {
  1046a4:	e0800317 	ldw	r2,12(fp)
  1046a8:	1080008c 	andi	r2,r2,2
  1046ac:	1000051e 	bne	r2,zero,1046c4 <alt_avalon_spi_command+0x90>
    IOWR_ALTERA_AVALON_SPI_CONTROL(base, ALTERA_AVALON_SPI_CONTROL_SSO_MSK);
  1046b0:	e0bff817 	ldw	r2,-32(fp)
  1046b4:	10800304 	addi	r2,r2,12
  1046b8:	1007883a 	mov	r3,r2
  1046bc:	00810004 	movi	r2,1024
  1046c0:	18800035 	stwio	r2,0(r3)
  /*
   * Discard any stale data present in the RXDATA register, in case
   * previous communication was interrupted and stale data was left
   * behind.
   */
  IORD_ALTERA_AVALON_SPI_RXDATA(base);
  1046c4:	e0bff817 	ldw	r2,-32(fp)
  1046c8:	10800037 	ldwio	r2,0(r2)
  for ( ; ; )
  {
    
    do
    {
      status = IORD_ALTERA_AVALON_SPI_STATUS(base);
  1046cc:	e0bff817 	ldw	r2,-32(fp)
  1046d0:	10800204 	addi	r2,r2,8
  1046d4:	10800037 	ldwio	r2,0(r2)
  1046d8:	e0bffa15 	stw	r2,-24(fp)
    }
    while (((status & ALTERA_AVALON_SPI_STATUS_TRDY_MSK) == 0 || credits == 0) &&
  1046dc:	e0bffa17 	ldw	r2,-24(fp)
  1046e0:	1080100c 	andi	r2,r2,64
            (status & ALTERA_AVALON_SPI_STATUS_RRDY_MSK) == 0);
  1046e4:	10000226 	beq	r2,zero,1046f0 <alt_avalon_spi_command+0xbc>
    while (((status & ALTERA_AVALON_SPI_STATUS_TRDY_MSK) == 0 || credits == 0) &&
  1046e8:	e0bffd17 	ldw	r2,-12(fp)
  1046ec:	1000031e 	bne	r2,zero,1046fc <alt_avalon_spi_command+0xc8>
            (status & ALTERA_AVALON_SPI_STATUS_RRDY_MSK) == 0);
  1046f0:	e0bffa17 	ldw	r2,-24(fp)
  1046f4:	1080200c 	andi	r2,r2,128
    while (((status & ALTERA_AVALON_SPI_STATUS_TRDY_MSK) == 0 || credits == 0) &&
  1046f8:	103ff426 	beq	r2,zero,1046cc <alt_avalon_spi_command+0x98>

    if ((status & ALTERA_AVALON_SPI_STATUS_TRDY_MSK) != 0 && credits > 0)
  1046fc:	e0bffa17 	ldw	r2,-24(fp)
  104700:	1080100c 	andi	r2,r2,64
  104704:	10001e26 	beq	r2,zero,104780 <alt_avalon_spi_command+0x14c>
  104708:	e0bffd17 	ldw	r2,-12(fp)
  10470c:	00801c0e 	bge	zero,r2,104780 <alt_avalon_spi_command+0x14c>
    {
      credits--;
  104710:	e0bffd17 	ldw	r2,-12(fp)
  104714:	10bfffc4 	addi	r2,r2,-1
  104718:	e0bffd15 	stw	r2,-12(fp)

      if (write_data < write_end)
  10471c:	e0fff517 	ldw	r3,-44(fp)
  104720:	e0bffc17 	ldw	r2,-16(fp)
  104724:	18800a2e 	bgeu	r3,r2,104750 <alt_avalon_spi_command+0x11c>
        IOWR_ALTERA_AVALON_SPI_TXDATA(base, *write_data++);
  104728:	e0bff817 	ldw	r2,-32(fp)
  10472c:	10800104 	addi	r2,r2,4
  104730:	1009883a 	mov	r4,r2
  104734:	e0bff517 	ldw	r2,-44(fp)
  104738:	10c00044 	addi	r3,r2,1
  10473c:	e0fff515 	stw	r3,-44(fp)
  104740:	10800003 	ldbu	r2,0(r2)
  104744:	10803fcc 	andi	r2,r2,255
  104748:	20800035 	stwio	r2,0(r4)
  10474c:	00000c06 	br	104780 <alt_avalon_spi_command+0x14c>
      else if (write_zeros > 0)
  104750:	e0bfff17 	ldw	r2,-4(fp)
  104754:	10000826 	beq	r2,zero,104778 <alt_avalon_spi_command+0x144>
      {
        write_zeros--;
  104758:	e0bfff17 	ldw	r2,-4(fp)
  10475c:	10bfffc4 	addi	r2,r2,-1
  104760:	e0bfff15 	stw	r2,-4(fp)
        IOWR_ALTERA_AVALON_SPI_TXDATA(base, 0);
  104764:	e0bff817 	ldw	r2,-32(fp)
  104768:	10800104 	addi	r2,r2,4
  10476c:	0007883a 	mov	r3,zero
  104770:	10c00035 	stwio	r3,0(r2)
  104774:	00000206 	br	104780 <alt_avalon_spi_command+0x14c>
      }
      else
        credits = -1024;
  104778:	00bf0004 	movi	r2,-1024
  10477c:	e0bffd15 	stw	r2,-12(fp)
    };

    if ((status & ALTERA_AVALON_SPI_STATUS_RRDY_MSK) != 0)
  104780:	e0bffa17 	ldw	r2,-24(fp)
  104784:	1080200c 	andi	r2,r2,128
  104788:	103fd026 	beq	r2,zero,1046cc <alt_avalon_spi_command+0x98>
    {
      alt_u32 rxdata = IORD_ALTERA_AVALON_SPI_RXDATA(base);
  10478c:	e0bff817 	ldw	r2,-32(fp)
  104790:	10800037 	ldwio	r2,0(r2)
  104794:	e0bff915 	stw	r2,-28(fp)

      if (read_ignore > 0)
  104798:	e0bffe17 	ldw	r2,-8(fp)
  10479c:	10000426 	beq	r2,zero,1047b0 <alt_avalon_spi_command+0x17c>
        read_ignore--;
  1047a0:	e0bffe17 	ldw	r2,-8(fp)
  1047a4:	10bfffc4 	addi	r2,r2,-1
  1047a8:	e0bffe15 	stw	r2,-8(fp)
  1047ac:	00000506 	br	1047c4 <alt_avalon_spi_command+0x190>
      else
        *read_data++ = (alt_u8)rxdata;
  1047b0:	e0800217 	ldw	r2,8(fp)
  1047b4:	10c00044 	addi	r3,r2,1
  1047b8:	e0c00215 	stw	r3,8(fp)
  1047bc:	e0fff917 	ldw	r3,-28(fp)
  1047c0:	10c00005 	stb	r3,0(r2)
      credits++;
  1047c4:	e0bffd17 	ldw	r2,-12(fp)
  1047c8:	10800044 	addi	r2,r2,1
  1047cc:	e0bffd15 	stw	r2,-12(fp)

      if (read_ignore == 0 && read_data == read_end)
  1047d0:	e0bffe17 	ldw	r2,-8(fp)
  1047d4:	103fbd1e 	bne	r2,zero,1046cc <alt_avalon_spi_command+0x98>
  1047d8:	e0c00217 	ldw	r3,8(fp)
  1047dc:	e0bffb17 	ldw	r2,-20(fp)
  1047e0:	18bfba1e 	bne	r3,r2,1046cc <alt_avalon_spi_command+0x98>
  }

  /* Wait until the interface has finished transmitting */
  do
  {
    status = IORD_ALTERA_AVALON_SPI_STATUS(base);
  1047e4:	e0bff817 	ldw	r2,-32(fp)
  1047e8:	10800204 	addi	r2,r2,8
  1047ec:	10800037 	ldwio	r2,0(r2)
  1047f0:	e0bffa15 	stw	r2,-24(fp)
  }
  while ((status & ALTERA_AVALON_SPI_STATUS_TMT_MSK) == 0);
  1047f4:	e0bffa17 	ldw	r2,-24(fp)
  1047f8:	1080080c 	andi	r2,r2,32
  1047fc:	103ff926 	beq	r2,zero,1047e4 <alt_avalon_spi_command+0x1b0>

  /* Clear SSO (release chipselect) unless the caller is going to
   * keep using this chip
   */
  if ((flags & ALT_AVALON_SPI_COMMAND_MERGE) == 0)
  104800:	e0800317 	ldw	r2,12(fp)
  104804:	1080004c 	andi	r2,r2,1
  104808:	1000041e 	bne	r2,zero,10481c <alt_avalon_spi_command+0x1e8>
    IOWR_ALTERA_AVALON_SPI_CONTROL(base, 0);
  10480c:	e0bff817 	ldw	r2,-32(fp)
  104810:	10800304 	addi	r2,r2,12
  104814:	0007883a 	mov	r3,zero
  104818:	10c00035 	stwio	r3,0(r2)

  return read_length;
  10481c:	e0800117 	ldw	r2,4(fp)
}
  104820:	e037883a 	mov	sp,fp
  104824:	df000017 	ldw	fp,0(sp)
  104828:	dec00104 	addi	sp,sp,4
  10482c:	f800283a 	ret

00104830 <alt_avalon_timer_sc_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void alt_avalon_timer_sc_irq (void* base)
#else
static void alt_avalon_timer_sc_irq (void* base, alt_u32 id)
#endif
{
  104830:	defffa04 	addi	sp,sp,-24
  104834:	dfc00515 	stw	ra,20(sp)
  104838:	df000415 	stw	fp,16(sp)
  10483c:	df000404 	addi	fp,sp,16
  104840:	e13ffc15 	stw	r4,-16(fp)
  alt_irq_context cpu_sr;
  
  /* clear the interrupt */
  IOWR_ALTERA_AVALON_TIMER_STATUS (base, 0);
  104844:	0007883a 	mov	r3,zero
  104848:	e0bffc17 	ldw	r2,-16(fp)
  10484c:	10c00035 	stwio	r3,0(r2)
  /* 
   * Dummy read to ensure IRQ is negated before the ISR returns.
   * The control register is read because reading the status
   * register has side-effects per the register map documentation.
   */
  IORD_ALTERA_AVALON_TIMER_CONTROL (base);
  104850:	e0bffc17 	ldw	r2,-16(fp)
  104854:	10800104 	addi	r2,r2,4
  104858:	10800037 	ldwio	r2,0(r2)
  NIOS2_READ_STATUS (context);
  10485c:	0005303a 	rdctl	r2,status
  104860:	e0bffd15 	stw	r2,-12(fp)
  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  104864:	e0fffd17 	ldw	r3,-12(fp)
  104868:	00bfff84 	movi	r2,-2
  10486c:	1884703a 	and	r2,r3,r2
  104870:	1001703a 	wrctl	status,r2
  return context;
  104874:	e0bffd17 	ldw	r2,-12(fp)

  /* 
   * Notify the system of a clock tick. disable interrupts 
   * during this time to safely support ISR preemption
   */
  cpu_sr = alt_irq_disable_all();
  104878:	e0bfff15 	stw	r2,-4(fp)
  alt_tick ();
  10487c:	010387c0 	call	10387c <alt_tick>
  104880:	e0bfff17 	ldw	r2,-4(fp)
  104884:	e0bffe15 	stw	r2,-8(fp)
  NIOS2_WRITE_STATUS (context);
  104888:	e0bffe17 	ldw	r2,-8(fp)
  10488c:	1001703a 	wrctl	status,r2
  alt_irq_enable_all(cpu_sr);
}
  104890:	0001883a 	nop
  104894:	e037883a 	mov	sp,fp
  104898:	dfc00117 	ldw	ra,4(sp)
  10489c:	df000017 	ldw	fp,0(sp)
  1048a0:	dec00204 	addi	sp,sp,8
  1048a4:	f800283a 	ret

001048a8 <alt_avalon_timer_sc_init>:
 * auto-generated alt_sys_init() function.
 */

void alt_avalon_timer_sc_init (void* base, alt_u32 irq_controller_id, 
                                alt_u32 irq, alt_u32 freq)
{
  1048a8:	defff804 	addi	sp,sp,-32
  1048ac:	dfc00715 	stw	ra,28(sp)
  1048b0:	df000615 	stw	fp,24(sp)
  1048b4:	df000604 	addi	fp,sp,24
  1048b8:	e13ffe15 	stw	r4,-8(fp)
  1048bc:	e17ffd15 	stw	r5,-12(fp)
  1048c0:	e1bffc15 	stw	r6,-16(fp)
  1048c4:	e1fffb15 	stw	r7,-20(fp)
  1048c8:	e0bffb17 	ldw	r2,-20(fp)
  1048cc:	e0bfff15 	stw	r2,-4(fp)
 * in order to initialise the value of the clock frequency.
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sysclk_init (alt_u32 nticks)
{
  if (! _alt_tick_rate)
  1048d0:	d0a02017 	ldw	r2,-32640(gp)
  1048d4:	1000021e 	bne	r2,zero,1048e0 <alt_avalon_timer_sc_init+0x38>
  {
    _alt_tick_rate = nticks;
  1048d8:	e0bfff17 	ldw	r2,-4(fp)
  1048dc:	d0a02015 	stw	r2,-32640(gp)
  
  alt_sysclk_init (freq);
  
  /* set to free running mode */
  
  IOWR_ALTERA_AVALON_TIMER_CONTROL (base, 
  1048e0:	e0bffe17 	ldw	r2,-8(fp)
  1048e4:	10800104 	addi	r2,r2,4
  1048e8:	00c001c4 	movi	r3,7
  1048ec:	10c00035 	stwio	r3,0(r2)
            ALTERA_AVALON_TIMER_CONTROL_CONT_MSK |
            ALTERA_AVALON_TIMER_CONTROL_START_MSK);

  /* register the interrupt handler, and enable the interrupt */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, alt_avalon_timer_sc_irq, 
  1048f0:	d8000015 	stw	zero,0(sp)
  1048f4:	e1fffe17 	ldw	r7,-8(fp)
  1048f8:	01800434 	movhi	r6,16
  1048fc:	31920c04 	addi	r6,r6,18480
  104900:	e17ffc17 	ldw	r5,-16(fp)
  104904:	e13ffd17 	ldw	r4,-12(fp)
  104908:	0105db00 	call	105db0 <alt_ic_isr_register>
                      base, NULL);
#else
  alt_irq_register (irq, base, alt_avalon_timer_sc_irq);
#endif  
}
  10490c:	0001883a 	nop
  104910:	e037883a 	mov	sp,fp
  104914:	dfc00117 	ldw	ra,4(sp)
  104918:	df000017 	ldw	fp,0(sp)
  10491c:	dec00204 	addi	sp,sp,8
  104920:	f800283a 	ret

00104924 <alt_flash_device_register>:

typedef struct alt_flash_dev alt_flash_dev; 
typedef alt_flash_dev alt_flash_fd;

static ALT_INLINE int alt_flash_device_register( alt_flash_fd* fd)
{
  104924:	defffd04 	addi	sp,sp,-12
  104928:	dfc00215 	stw	ra,8(sp)
  10492c:	df000115 	stw	fp,4(sp)
  104930:	df000104 	addi	fp,sp,4
  104934:	e13fff15 	stw	r4,-4(fp)
  extern alt_llist alt_flash_dev_list;

  return alt_dev_llist_insert ((alt_dev_llist*) fd, &alt_flash_dev_list);
  104938:	d1601304 	addi	r5,gp,-32692
  10493c:	e13fff17 	ldw	r4,-4(fp)
  104940:	0105c500 	call	105c50 <alt_dev_llist_insert>
}
  104944:	e037883a 	mov	sp,fp
  104948:	dfc00117 	ldw	ra,4(sp)
  10494c:	df000017 	ldw	fp,0(sp)
  104950:	dec00204 	addi	sp,sp,8
  104954:	f800283a 	ret

00104958 <alt_onchip_flash_read>:
    alt_flash_dev *flash_info,
    int           offset,
    void          *dest_addr,
    int           length
)
{
  104958:	defff704 	addi	sp,sp,-36
  10495c:	dfc00815 	stw	ra,32(sp)
  104960:	df000715 	stw	fp,28(sp)
  104964:	df000704 	addi	fp,sp,28
  104968:	e13ffc15 	stw	r4,-16(fp)
  10496c:	e17ffb15 	stw	r5,-20(fp)
  104970:	e1bffa15 	stw	r6,-24(fp)
  104974:	e1fff915 	stw	r7,-28(fp)
    int ret_code = 0;
  104978:	e03fff15 	stw	zero,-4(fp)
    alt_onchip_flash_dev* flash = (alt_onchip_flash_dev*)flash_info;
  10497c:	e0bffc17 	ldw	r2,-16(fp)
  104980:	e0bffe15 	stw	r2,-8(fp)

    /* Make sure the input parameters is not outside of this device's range. */
    if ((offset >= flash->dev.length) || ((offset+length) > flash->dev.length)) {
  104984:	e0bffe17 	ldw	r2,-8(fp)
  104988:	10800b17 	ldw	r2,44(r2)
  10498c:	e0fffb17 	ldw	r3,-20(fp)
  104990:	1880060e 	bge	r3,r2,1049ac <alt_onchip_flash_read+0x54>
  104994:	e0fffb17 	ldw	r3,-20(fp)
  104998:	e0bff917 	ldw	r2,-28(fp)
  10499c:	1885883a 	add	r2,r3,r2
  1049a0:	e0fffe17 	ldw	r3,-8(fp)
  1049a4:	18c00b17 	ldw	r3,44(r3)
  1049a8:	1880020e 	bge	r3,r2,1049b4 <alt_onchip_flash_read+0x5c>
        return -EFAULT;
  1049ac:	00bffc84 	movi	r2,-14
  1049b0:	00001706 	br	104a10 <alt_onchip_flash_read+0xb8>
    }
    
    memcpy(dest_addr, (alt_u8*)flash->dev.base_addr+offset, length);
  1049b4:	e0bffe17 	ldw	r2,-8(fp)
  1049b8:	10c00a17 	ldw	r3,40(r2)
  1049bc:	e0bffb17 	ldw	r2,-20(fp)
  1049c0:	1885883a 	add	r2,r3,r2
  1049c4:	e0fff917 	ldw	r3,-28(fp)
  1049c8:	180d883a 	mov	r6,r3
  1049cc:	100b883a 	mov	r5,r2
  1049d0:	e13ffa17 	ldw	r4,-24(fp)
  1049d4:	0102ebc0 	call	102ebc <memcpy>

    if (NULL != flash->csr_base) {
  1049d8:	e0bffe17 	ldw	r2,-8(fp)
  1049dc:	10802f17 	ldw	r2,188(r2)
  1049e0:	10000a26 	beq	r2,zero,104a0c <alt_onchip_flash_read+0xb4>
        int read_status = IORD_ALTERA_ONCHIP_FLASH_STATUS(flash->csr_base) & ALTERA_ONCHIP_FLASH_STATUS_READ_MSK;
  1049e4:	e0bffe17 	ldw	r2,-8(fp)
  1049e8:	10802f17 	ldw	r2,188(r2)
  1049ec:	10800037 	ldwio	r2,0(r2)
  1049f0:	1080010c 	andi	r2,r2,4
  1049f4:	e0bffd15 	stw	r2,-12(fp)
        if (read_status != ALTERA_ONCHIP_FLASH_STATUS_READ_PASSED) {
  1049f8:	e0bffd17 	ldw	r2,-12(fp)
  1049fc:	10800120 	cmpeqi	r2,r2,4
  104a00:	1000021e 	bne	r2,zero,104a0c <alt_onchip_flash_read+0xb4>
            /* Read failed.  Return error.*/
            ret_code = -EIO;
  104a04:	00bffec4 	movi	r2,-5
  104a08:	e0bfff15 	stw	r2,-4(fp)
        }
    }
    return ret_code;
  104a0c:	e0bfff17 	ldw	r2,-4(fp)
}
  104a10:	e037883a 	mov	sp,fp
  104a14:	dfc00117 	ldw	ra,4(sp)
  104a18:	df000017 	ldw	fp,0(sp)
  104a1c:	dec00204 	addi	sp,sp,8
  104a20:	f800283a 	ret

00104a24 <alt_onchip_flash_get_info>:
(
    alt_flash_fd *fd,
    flash_region **info,
    int          *number_of_regions
)
{
  104a24:	defffa04 	addi	sp,sp,-24
  104a28:	df000515 	stw	fp,20(sp)
  104a2c:	df000504 	addi	fp,sp,20
  104a30:	e13ffd15 	stw	r4,-12(fp)
  104a34:	e17ffc15 	stw	r5,-16(fp)
  104a38:	e1bffb15 	stw	r6,-20(fp)
    int ret_code = 0;
  104a3c:	e03fff15 	stw	zero,-4(fp)

    alt_flash_dev* flash = (alt_flash_dev*)fd;
  104a40:	e0bffd17 	ldw	r2,-12(fp)
  104a44:	e0bffe15 	stw	r2,-8(fp)

    if (NULL != number_of_regions)
  104a48:	e0bffb17 	ldw	r2,-20(fp)
  104a4c:	10000426 	beq	r2,zero,104a60 <alt_onchip_flash_get_info+0x3c>
    {
        /* Pass the number of region to user */
        *number_of_regions = flash->number_of_regions;
  104a50:	e0bffe17 	ldw	r2,-8(fp)
  104a54:	10c00c17 	ldw	r3,48(r2)
  104a58:	e0bffb17 	ldw	r2,-20(fp)
  104a5c:	10c00015 	stw	r3,0(r2)
    }

    if (!flash->number_of_regions)
  104a60:	e0bffe17 	ldw	r2,-8(fp)
  104a64:	10800c17 	ldw	r2,48(r2)
  104a68:	1000031e 	bne	r2,zero,104a78 <alt_onchip_flash_get_info+0x54>
    {
        ret_code = -ENOMEM;
  104a6c:	00bffd04 	movi	r2,-12
  104a70:	e0bfff15 	stw	r2,-4(fp)
  104a74:	00000d06 	br	104aac <alt_onchip_flash_get_info+0x88>
    }
    else if (flash->number_of_regions > ALT_MAX_NUMBER_OF_FLASH_REGIONS)
  104a78:	e0bffe17 	ldw	r2,-8(fp)
  104a7c:	10800c17 	ldw	r2,48(r2)
  104a80:	10800250 	cmplti	r2,r2,9
  104a84:	1000031e 	bne	r2,zero,104a94 <alt_onchip_flash_get_info+0x70>
    {
        ret_code = -EFAULT;
  104a88:	00bffc84 	movi	r2,-14
  104a8c:	e0bfff15 	stw	r2,-4(fp)
  104a90:	00000606 	br	104aac <alt_onchip_flash_get_info+0x88>
    }
    else
    {
        if (NULL != info)
  104a94:	e0bffc17 	ldw	r2,-16(fp)
  104a98:	10000426 	beq	r2,zero,104aac <alt_onchip_flash_get_info+0x88>
        {
            /* Pass the table of erase blocks to user */
            *info = &flash->region_info[0];
  104a9c:	e0bffe17 	ldw	r2,-8(fp)
  104aa0:	10c00d04 	addi	r3,r2,52
  104aa4:	e0bffc17 	ldw	r2,-16(fp)
  104aa8:	10c00015 	stw	r3,0(r2)
        }
    }

    return ret_code;
  104aac:	e0bfff17 	ldw	r2,-4(fp)
}
  104ab0:	e037883a 	mov	sp,fp
  104ab4:	df000017 	ldw	fp,0(sp)
  104ab8:	dec00104 	addi	sp,sp,4
  104abc:	f800283a 	ret

00104ac0 <alt_onchip_flash_erase_block>:
int alt_onchip_flash_erase_block
(
    alt_flash_dev *flash_info,
    int           block_offset
)
{
  104ac0:	defff904 	addi	sp,sp,-28
  104ac4:	dfc00615 	stw	ra,24(sp)
  104ac8:	df000515 	stw	fp,20(sp)
  104acc:	df000504 	addi	fp,sp,20
  104ad0:	e13ffc15 	stw	r4,-16(fp)
  104ad4:	e17ffb15 	stw	r5,-20(fp)
    int ret_code = 0;
  104ad8:	e03fff15 	stw	zero,-4(fp)
    alt_onchip_flash_dev *flash = (alt_onchip_flash_dev*)flash_info;
  104adc:	e0bffc17 	ldw	r2,-16(fp)
  104ae0:	e0bffe15 	stw	r2,-8(fp)
    int page_address;

    /* Make sure the input parameters is not outside of this device's range. */
    if (block_offset >= flash->dev.length) {
  104ae4:	e0bffe17 	ldw	r2,-8(fp)
  104ae8:	10800b17 	ldw	r2,44(r2)
  104aec:	e0fffb17 	ldw	r3,-20(fp)
  104af0:	18800216 	blt	r3,r2,104afc <alt_onchip_flash_erase_block+0x3c>
        return -EFAULT;
  104af4:	00bffc84 	movi	r2,-14
  104af8:	00004606 	br	104c14 <alt_onchip_flash_erase_block+0x154>
    }

    /* Make sure IP support write and erase operation */
    if ((flash->csr_base == NULL) || (flash->is_read_only)) {
  104afc:	e0bffe17 	ldw	r2,-8(fp)
  104b00:	10802f17 	ldw	r2,188(r2)
  104b04:	10000326 	beq	r2,zero,104b14 <alt_onchip_flash_erase_block+0x54>
  104b08:	e0bffe17 	ldw	r2,-8(fp)
  104b0c:	10802e17 	ldw	r2,184(r2)
  104b10:	10000226 	beq	r2,zero,104b1c <alt_onchip_flash_erase_block+0x5c>
        return -ENODEV;
  104b14:	00bffb44 	movi	r2,-19
  104b18:	00003e06 	br	104c14 <alt_onchip_flash_erase_block+0x154>
    }

    /* The block_offset must be page size aligned */
    if ((block_offset & (flash->page_size - 1)) != 0)
  104b1c:	e0bffe17 	ldw	r2,-8(fp)
  104b20:	10803f17 	ldw	r2,252(r2)
  104b24:	10ffffc4 	addi	r3,r2,-1
  104b28:	e0bffb17 	ldw	r2,-20(fp)
  104b2c:	1884703a 	and	r2,r3,r2
  104b30:	10000226 	beq	r2,zero,104b3c <alt_onchip_flash_erase_block+0x7c>
    {
        /* The address is not aligned */
        return -EINVAL;
  104b34:	00bffa84 	movi	r2,-22
  104b38:	00003606 	br	104c14 <alt_onchip_flash_erase_block+0x154>
    }

    /* Wait until flash controller idle */
    ret_code = alt_onchip_flash_poll_for_status_to_go_idle(flash);
  104b3c:	e13ffe17 	ldw	r4,-8(fp)
  104b40:	010566c0 	call	10566c <alt_onchip_flash_poll_for_status_to_go_idle>
  104b44:	e0bfff15 	stw	r2,-4(fp)
    if (ret_code != 0)
  104b48:	e0bfff17 	ldw	r2,-4(fp)
  104b4c:	10000226 	beq	r2,zero,104b58 <alt_onchip_flash_erase_block+0x98>
    {
        return ret_code;
  104b50:	e0bfff17 	ldw	r2,-4(fp)
  104b54:	00002f06 	br	104c14 <alt_onchip_flash_erase_block+0x154>
    }

    /* Enable write and erase operation */
    ALTERA_ONCHIP_FLASH_ENABLE_WRITE_AND_ERASE_OPERATION(flash->csr_base);
  104b58:	e0bffe17 	ldw	r2,-8(fp)
  104b5c:	10802f17 	ldw	r2,188(r2)
  104b60:	10c00104 	addi	r3,r2,4
  104b64:	e0bffe17 	ldw	r2,-8(fp)
  104b68:	10802f17 	ldw	r2,188(r2)
  104b6c:	10800104 	addi	r2,r2,4
  104b70:	10800037 	ldwio	r2,0(r2)
  104b74:	113c002c 	andhi	r4,r2,61440
  104b78:	00802034 	movhi	r2,128
  104b7c:	10bfffc4 	addi	r2,r2,-1
  104b80:	2084b03a 	or	r2,r4,r2
  104b84:	18800035 	stwio	r2,0(r3)

    /* Calculate Page erase address, it is 32bit word addressing*/
    page_address = block_offset / 4;
  104b88:	e0bffb17 	ldw	r2,-20(fp)
  104b8c:	1000010e 	bge	r2,zero,104b94 <alt_onchip_flash_erase_block+0xd4>
  104b90:	108000c4 	addi	r2,r2,3
  104b94:	1005d0ba 	srai	r2,r2,2
  104b98:	e0bffd15 	stw	r2,-12(fp)

    /* Perform Page erase operation */
    ALTERA_ONCHIP_FLASH_PAGE_ERASE(flash->csr_base, page_address);
  104b9c:	e0bffe17 	ldw	r2,-8(fp)
  104ba0:	10802f17 	ldw	r2,188(r2)
  104ba4:	10800104 	addi	r2,r2,4
  104ba8:	e0fffe17 	ldw	r3,-8(fp)
  104bac:	18c02f17 	ldw	r3,188(r3)
  104bb0:	18c00104 	addi	r3,r3,4
  104bb4:	18c00037 	ldwio	r3,0(r3)
  104bb8:	193c002c 	andhi	r4,r3,61440
  104bbc:	e0fffd17 	ldw	r3,-12(fp)
  104bc0:	18c01c34 	orhi	r3,r3,112
  104bc4:	20c6b03a 	or	r3,r4,r3
  104bc8:	10c00035 	stwio	r3,0(r2)

    /* Wait until flash controller idle */
    ret_code = alt_onchip_flash_poll_for_status_to_go_idle(flash);
  104bcc:	e13ffe17 	ldw	r4,-8(fp)
  104bd0:	010566c0 	call	10566c <alt_onchip_flash_poll_for_status_to_go_idle>
  104bd4:	e0bfff15 	stw	r2,-4(fp)

    /* Wait until flash controller indicate erase passed */
    ret_code = alt_onchip_flash_poll_for_status_erase_passed(flash);
  104bd8:	e13ffe17 	ldw	r4,-8(fp)
  104bdc:	01056fc0 	call	1056fc <alt_onchip_flash_poll_for_status_erase_passed>
  104be0:	e0bfff15 	stw	r2,-4(fp)

    /* Disable write and erase operation */
    ALTERA_ONCHIP_FLASH_DISABLE_WRITE_AND_ERASE_OPERATION(flash->csr_base);
  104be4:	e0bffe17 	ldw	r2,-8(fp)
  104be8:	10802f17 	ldw	r2,188(r2)
  104bec:	10c00104 	addi	r3,r2,4
  104bf0:	e0bffe17 	ldw	r2,-8(fp)
  104bf4:	10802f17 	ldw	r2,188(r2)
  104bf8:	10800104 	addi	r2,r2,4
  104bfc:	11000037 	ldwio	r4,0(r2)
  104c00:	00840034 	movhi	r2,4096
  104c04:	10bfffc4 	addi	r2,r2,-1
  104c08:	2084b03a 	or	r2,r4,r2
  104c0c:	18800035 	stwio	r2,0(r3)

    return ret_code;
  104c10:	e0bfff17 	ldw	r2,-4(fp)
}
  104c14:	e037883a 	mov	sp,fp
  104c18:	dfc00117 	ldw	ra,4(sp)
  104c1c:	df000017 	ldw	fp,0(sp)
  104c20:	dec00204 	addi	sp,sp,8
  104c24:	f800283a 	ret

00104c28 <alt_onchip_flash_write_block>:
    int           block_offset,
    int           data_offset,
    const void    *data,
    int           length
)
{
  104c28:	defff204 	addi	sp,sp,-56
  104c2c:	dfc00d15 	stw	ra,52(sp)
  104c30:	df000c15 	stw	fp,48(sp)
  104c34:	df000c04 	addi	fp,sp,48
  104c38:	e13ff715 	stw	r4,-36(fp)
  104c3c:	e17ff615 	stw	r5,-40(fp)
  104c40:	e1bff515 	stw	r6,-44(fp)
  104c44:	e1fff415 	stw	r7,-48(fp)
    int ret_code = 0;
  104c48:	e03fff15 	stw	zero,-4(fp)
    alt_onchip_flash_dev *flash = (alt_onchip_flash_dev*)flash_info;
  104c4c:	e0bff717 	ldw	r2,-36(fp)
  104c50:	e0bffb15 	stw	r2,-20(fp)
    int buffer_offset = 0;
  104c54:	e03ffe15 	stw	zero,-8(fp)
    int length_of_current_write;
    int current_data_offset = data_offset;
  104c58:	e0bff517 	ldw	r2,-44(fp)
  104c5c:	e0bffd15 	stw	r2,-12(fp)
    int next_data_offset;
    alt_u32 chunk_of_data;

    /* Make sure the input parameters is not outside of this device's range. */
    if (
        (block_offset >= flash->dev.length) ||
  104c60:	e0bffb17 	ldw	r2,-20(fp)
  104c64:	10800b17 	ldw	r2,44(r2)
    if (
  104c68:	e0fff617 	ldw	r3,-40(fp)
  104c6c:	18800a0e 	bge	r3,r2,104c98 <alt_onchip_flash_write_block+0x70>
        (data_offset >= flash->dev.length) ||
  104c70:	e0bffb17 	ldw	r2,-20(fp)
  104c74:	10800b17 	ldw	r2,44(r2)
        (block_offset >= flash->dev.length) ||
  104c78:	e0fff517 	ldw	r3,-44(fp)
  104c7c:	1880060e 	bge	r3,r2,104c98 <alt_onchip_flash_write_block+0x70>
        (length > (flash->dev.length - data_offset))
  104c80:	e0bffb17 	ldw	r2,-20(fp)
  104c84:	10c00b17 	ldw	r3,44(r2)
  104c88:	e0bff517 	ldw	r2,-44(fp)
  104c8c:	1887c83a 	sub	r3,r3,r2
        (data_offset >= flash->dev.length) ||
  104c90:	e0800217 	ldw	r2,8(fp)
  104c94:	1880020e 	bge	r3,r2,104ca0 <alt_onchip_flash_write_block+0x78>
    ) {
        return -EFAULT;
  104c98:	00bffc84 	movi	r2,-14
  104c9c:	00009306 	br	104eec <alt_onchip_flash_write_block+0x2c4>
    }

    /* Make sure IP support support write and erase operation */
    if ((flash->csr_base == NULL) || (flash->is_read_only != 0)) {
  104ca0:	e0bffb17 	ldw	r2,-20(fp)
  104ca4:	10802f17 	ldw	r2,188(r2)
  104ca8:	10000326 	beq	r2,zero,104cb8 <alt_onchip_flash_write_block+0x90>
  104cac:	e0bffb17 	ldw	r2,-20(fp)
  104cb0:	10802e17 	ldw	r2,184(r2)
  104cb4:	10000226 	beq	r2,zero,104cc0 <alt_onchip_flash_write_block+0x98>
        return -ENODEV;
  104cb8:	00bffb44 	movi	r2,-19
  104cbc:	00008b06 	br	104eec <alt_onchip_flash_write_block+0x2c4>
    }

    /* Wait until flash controller idle */
    ret_code = alt_onchip_flash_poll_for_status_to_go_idle(flash);
  104cc0:	e13ffb17 	ldw	r4,-20(fp)
  104cc4:	010566c0 	call	10566c <alt_onchip_flash_poll_for_status_to_go_idle>
  104cc8:	e0bfff15 	stw	r2,-4(fp)
    if (ret_code != 0)
  104ccc:	e0bfff17 	ldw	r2,-4(fp)
  104cd0:	10000226 	beq	r2,zero,104cdc <alt_onchip_flash_write_block+0xb4>
    {
        return ret_code;
  104cd4:	e0bfff17 	ldw	r2,-4(fp)
  104cd8:	00008406 	br	104eec <alt_onchip_flash_write_block+0x2c4>
    }

    /* Enable write and erase operation */
    ALTERA_ONCHIP_FLASH_ENABLE_WRITE_AND_ERASE_OPERATION(flash->csr_base);
  104cdc:	e0bffb17 	ldw	r2,-20(fp)
  104ce0:	10802f17 	ldw	r2,188(r2)
  104ce4:	10c00104 	addi	r3,r2,4
  104ce8:	e0bffb17 	ldw	r2,-20(fp)
  104cec:	10802f17 	ldw	r2,188(r2)
  104cf0:	10800104 	addi	r2,r2,4
  104cf4:	10800037 	ldwio	r2,0(r2)
  104cf8:	113c002c 	andhi	r4,r2,61440
  104cfc:	00802034 	movhi	r2,128
  104d00:	10bfffc4 	addi	r2,r2,-1
  104d04:	2084b03a 	or	r2,r4,r2
  104d08:	18800035 	stwio	r2,0(r3)

    /* Check data length */
    while (length)
  104d0c:	00006506 	br	104ea4 <alt_onchip_flash_write_block+0x27c>
    {
        /* Minimum write size to onchip flash is 32 bits of data */
        chunk_of_data = 0xFFFFFFFF;
  104d10:	00bfffc4 	movi	r2,-1
  104d14:	e0bff815 	stw	r2,-32(fp)

        /* The start of data_offset must be 4 bytes (32 bits) aligned */
        if ((current_data_offset & (ALTERA_ONCHIP_FLASH_DATA_ALIGN_SIZE - 1)) == 0)
  104d18:	e0bffd17 	ldw	r2,-12(fp)
  104d1c:	108000cc 	andi	r2,r2,3
  104d20:	10001e1e 	bne	r2,zero,104d9c <alt_onchip_flash_write_block+0x174>
        {
            /* The address is 4-byte aligned here */
            next_data_offset = (current_data_offset + ALTERA_ONCHIP_FLASH_DATA_ALIGN_SIZE) & ~(ALTERA_ONCHIP_FLASH_DATA_ALIGN_SIZE - 1);
  104d24:	e0bffd17 	ldw	r2,-12(fp)
  104d28:	10c00104 	addi	r3,r2,4
  104d2c:	00bfff04 	movi	r2,-4
  104d30:	1884703a 	and	r2,r3,r2
  104d34:	e0bffc15 	stw	r2,-16(fp)
            length_of_current_write = MIN(length, next_data_offset - current_data_offset);
  104d38:	e0fffc17 	ldw	r3,-16(fp)
  104d3c:	e0bffd17 	ldw	r2,-12(fp)
  104d40:	1887c83a 	sub	r3,r3,r2
  104d44:	e0800217 	ldw	r2,8(fp)
  104d48:	1880010e 	bge	r3,r2,104d50 <alt_onchip_flash_write_block+0x128>
  104d4c:	1805883a 	mov	r2,r3
  104d50:	e0bffa15 	stw	r2,-24(fp)
            /* Prepare the 4 bytes chunk of data to be written */
            memcpy(&chunk_of_data, &((alt_u8*)data)[buffer_offset], length_of_current_write);
  104d54:	e0bffe17 	ldw	r2,-8(fp)
  104d58:	e0fff417 	ldw	r3,-48(fp)
  104d5c:	1887883a 	add	r3,r3,r2
  104d60:	e13ffa17 	ldw	r4,-24(fp)
  104d64:	e0bff804 	addi	r2,fp,-32
  104d68:	200d883a 	mov	r6,r4
  104d6c:	180b883a 	mov	r5,r3
  104d70:	1009883a 	mov	r4,r2
  104d74:	0102ebc0 	call	102ebc <memcpy>
            buffer_offset += length_of_current_write;
  104d78:	e0fffe17 	ldw	r3,-8(fp)
  104d7c:	e0bffa17 	ldw	r2,-24(fp)
  104d80:	1885883a 	add	r2,r3,r2
  104d84:	e0bffe15 	stw	r2,-8(fp)
            length -= length_of_current_write;
  104d88:	e0c00217 	ldw	r3,8(fp)
  104d8c:	e0bffa17 	ldw	r2,-24(fp)
  104d90:	1885c83a 	sub	r2,r3,r2
  104d94:	e0800215 	stw	r2,8(fp)
  104d98:	00003006 	br	104e5c <alt_onchip_flash_write_block+0x234>
        } else {
            /* Calculate how many padding bytes need to be added before the start of a data offset */
            int padding = current_data_offset & (ALTERA_ONCHIP_FLASH_DATA_ALIGN_SIZE - 1);
  104d9c:	e0bffd17 	ldw	r2,-12(fp)
  104da0:	108000cc 	andi	r2,r2,3
  104da4:	e0bff915 	stw	r2,-28(fp)

            /* Calculate new 4-byte aligned data offset */
            current_data_offset = current_data_offset - padding;
  104da8:	e0fffd17 	ldw	r3,-12(fp)
  104dac:	e0bff917 	ldw	r2,-28(fp)
  104db0:	1885c83a 	sub	r2,r3,r2
  104db4:	e0bffd15 	stw	r2,-12(fp)
            next_data_offset = (current_data_offset + ALTERA_ONCHIP_FLASH_DATA_ALIGN_SIZE) & ~(ALTERA_ONCHIP_FLASH_DATA_ALIGN_SIZE - 1);
  104db8:	e0bffd17 	ldw	r2,-12(fp)
  104dbc:	10c00104 	addi	r3,r2,4
  104dc0:	00bfff04 	movi	r2,-4
  104dc4:	1884703a 	and	r2,r3,r2
  104dc8:	e0bffc15 	stw	r2,-16(fp)
            length_of_current_write = MIN(length + padding, next_data_offset - current_data_offset);
  104dcc:	e0fffc17 	ldw	r3,-16(fp)
  104dd0:	e0bffd17 	ldw	r2,-12(fp)
  104dd4:	1889c83a 	sub	r4,r3,r2
  104dd8:	e0c00217 	ldw	r3,8(fp)
  104ddc:	e0bff917 	ldw	r2,-28(fp)
  104de0:	1887883a 	add	r3,r3,r2
  104de4:	2005883a 	mov	r2,r4
  104de8:	1880010e 	bge	r3,r2,104df0 <alt_onchip_flash_write_block+0x1c8>
  104dec:	1805883a 	mov	r2,r3
  104df0:	e0bffa15 	stw	r2,-24(fp)
            /* Prepare the 4 bytes chunk of data to be written */
            memcpy((void *)(((int)&chunk_of_data) + (int)padding), &((alt_u8*)data)[buffer_offset], length_of_current_write - padding);
  104df4:	e0fff804 	addi	r3,fp,-32
  104df8:	e0bff917 	ldw	r2,-28(fp)
  104dfc:	1885883a 	add	r2,r3,r2
  104e00:	100f883a 	mov	r7,r2
  104e04:	e0bffe17 	ldw	r2,-8(fp)
  104e08:	e0fff417 	ldw	r3,-48(fp)
  104e0c:	1889883a 	add	r4,r3,r2
  104e10:	e0fffa17 	ldw	r3,-24(fp)
  104e14:	e0bff917 	ldw	r2,-28(fp)
  104e18:	1885c83a 	sub	r2,r3,r2
  104e1c:	100d883a 	mov	r6,r2
  104e20:	200b883a 	mov	r5,r4
  104e24:	3809883a 	mov	r4,r7
  104e28:	0102ebc0 	call	102ebc <memcpy>
            buffer_offset += length_of_current_write - padding;
  104e2c:	e0fffa17 	ldw	r3,-24(fp)
  104e30:	e0bff917 	ldw	r2,-28(fp)
  104e34:	1885c83a 	sub	r2,r3,r2
  104e38:	e0fffe17 	ldw	r3,-8(fp)
  104e3c:	1885883a 	add	r2,r3,r2
  104e40:	e0bffe15 	stw	r2,-8(fp)
            length -= length_of_current_write - padding;
  104e44:	e0fffa17 	ldw	r3,-24(fp)
  104e48:	e0bff917 	ldw	r2,-28(fp)
  104e4c:	1885c83a 	sub	r2,r3,r2
  104e50:	e0c00217 	ldw	r3,8(fp)
  104e54:	1885c83a 	sub	r2,r3,r2
  104e58:	e0800215 	stw	r2,8(fp)
        }

        /* Writing to flash via IO 32 bits at a time */
        IOWR_32DIRECT(flash->dev.base_addr, current_data_offset, chunk_of_data);
  104e5c:	e0bffb17 	ldw	r2,-20(fp)
  104e60:	10c00a17 	ldw	r3,40(r2)
  104e64:	e0bffd17 	ldw	r2,-12(fp)
  104e68:	1885883a 	add	r2,r3,r2
  104e6c:	e0fff817 	ldw	r3,-32(fp)
  104e70:	10c00035 	stwio	r3,0(r2)

        /* Wait until flash controller idle */
        ret_code = alt_onchip_flash_poll_for_status_to_go_idle(flash);
  104e74:	e13ffb17 	ldw	r4,-20(fp)
  104e78:	010566c0 	call	10566c <alt_onchip_flash_poll_for_status_to_go_idle>
  104e7c:	e0bfff15 	stw	r2,-4(fp)
        if (ret_code != 0)
  104e80:	e0bfff17 	ldw	r2,-4(fp)
  104e84:	10000a1e 	bne	r2,zero,104eb0 <alt_onchip_flash_write_block+0x288>
        {
            break;
        }

        /* Wait until flash controller indicate write passed */
        ret_code = alt_onchip_flash_poll_for_status_write_passed(flash);
  104e88:	e13ffb17 	ldw	r4,-20(fp)
  104e8c:	01057900 	call	105790 <alt_onchip_flash_poll_for_status_write_passed>
  104e90:	e0bfff15 	stw	r2,-4(fp)
        if (ret_code != 0)
  104e94:	e0bfff17 	ldw	r2,-4(fp)
  104e98:	1000071e 	bne	r2,zero,104eb8 <alt_onchip_flash_write_block+0x290>
        {
            break;
        }

        /* Prepare to write next 4 bytes */
        current_data_offset = next_data_offset;
  104e9c:	e0bffc17 	ldw	r2,-16(fp)
  104ea0:	e0bffd15 	stw	r2,-12(fp)
    while (length)
  104ea4:	e0800217 	ldw	r2,8(fp)
  104ea8:	103f991e 	bne	r2,zero,104d10 <alt_onchip_flash_write_block+0xe8>
  104eac:	00000306 	br	104ebc <alt_onchip_flash_write_block+0x294>
            break;
  104eb0:	0001883a 	nop
  104eb4:	00000106 	br	104ebc <alt_onchip_flash_write_block+0x294>
            break;
  104eb8:	0001883a 	nop
    }

    /* Disable write and erase operation */
    ALTERA_ONCHIP_FLASH_DISABLE_WRITE_AND_ERASE_OPERATION(flash->csr_base);
  104ebc:	e0bffb17 	ldw	r2,-20(fp)
  104ec0:	10802f17 	ldw	r2,188(r2)
  104ec4:	10c00104 	addi	r3,r2,4
  104ec8:	e0bffb17 	ldw	r2,-20(fp)
  104ecc:	10802f17 	ldw	r2,188(r2)
  104ed0:	10800104 	addi	r2,r2,4
  104ed4:	11000037 	ldwio	r4,0(r2)
  104ed8:	00840034 	movhi	r2,4096
  104edc:	10bfffc4 	addi	r2,r2,-1
  104ee0:	2084b03a 	or	r2,r4,r2
  104ee4:	18800035 	stwio	r2,0(r3)

    return ret_code;
  104ee8:	e0bfff17 	ldw	r2,-4(fp)
}
  104eec:	e037883a 	mov	sp,fp
  104ef0:	dfc00117 	ldw	ra,4(sp)
  104ef4:	df000017 	ldw	fp,0(sp)
  104ef8:	dec00204 	addi	sp,sp,8
  104efc:	f800283a 	ret

00104f00 <alt_onchip_flash_write>:
    alt_flash_dev *flash_info,
    int           offset,
    const void    *src_addr,
    int           length
)
{
  104f00:	defff104 	addi	sp,sp,-60
  104f04:	dfc00e15 	stw	ra,56(sp)
  104f08:	df000d15 	stw	fp,52(sp)
  104f0c:	df000d04 	addi	fp,sp,52
  104f10:	e13ff715 	stw	r4,-36(fp)
  104f14:	e17ff615 	stw	r5,-40(fp)
  104f18:	e1bff515 	stw	r6,-44(fp)
  104f1c:	e1fff415 	stw	r7,-48(fp)
    int         ret_code = 0;
  104f20:	e03fff15 	stw	zero,-4(fp)
    int         i,j;
    int         data_to_write;
    int         current_offset;
    int         full_length = length;
  104f24:	e0bff417 	ldw	r2,-48(fp)
  104f28:	e0bffb15 	stw	r2,-20(fp)
    int         start_offset = offset;
  104f2c:	e0bff617 	ldw	r2,-40(fp)
  104f30:	e0bffa15 	stw	r2,-24(fp)
    alt_onchip_flash_dev* flash = (alt_onchip_flash_dev*)flash_info;
  104f34:	e0bff717 	ldw	r2,-36(fp)
  104f38:	e0bff915 	stw	r2,-28(fp)

    /* Make sure the input parameters is not outside of this device's range. */
    if ((offset >= flash->dev.length) || (length > (flash->dev.length - offset)))
  104f3c:	e0bff917 	ldw	r2,-28(fp)
  104f40:	10800b17 	ldw	r2,44(r2)
  104f44:	e0fff617 	ldw	r3,-40(fp)
  104f48:	1880060e 	bge	r3,r2,104f64 <alt_onchip_flash_write+0x64>
  104f4c:	e0bff917 	ldw	r2,-28(fp)
  104f50:	10c00b17 	ldw	r3,44(r2)
  104f54:	e0bff617 	ldw	r2,-40(fp)
  104f58:	1887c83a 	sub	r3,r3,r2
  104f5c:	e0bff417 	ldw	r2,-48(fp)
  104f60:	1880020e 	bge	r3,r2,104f6c <alt_onchip_flash_write+0x6c>
    {
        return -EFAULT;
  104f64:	00bffc84 	movi	r2,-14
  104f68:	00009306 	br	1051b8 <alt_onchip_flash_write+0x2b8>
    }

    /*
    * First and foremost which sectors are affected?
    */
    for(i=0;i<flash->dev.number_of_regions;i++)
  104f6c:	e03ffe15 	stw	zero,-8(fp)
  104f70:	00008206 	br	10517c <alt_onchip_flash_write+0x27c>
    {
        /* Is it in this erase block region?*/
        if((offset >= flash->dev.region_info[i].offset) &&
  104f74:	e0fff917 	ldw	r3,-28(fp)
  104f78:	e0bffe17 	ldw	r2,-8(fp)
  104f7c:	1004913a 	slli	r2,r2,4
  104f80:	1885883a 	add	r2,r3,r2
  104f84:	10800d17 	ldw	r2,52(r2)
  104f88:	e0fff617 	ldw	r3,-40(fp)
  104f8c:	18807816 	blt	r3,r2,105170 <alt_onchip_flash_write+0x270>
            (offset < (flash->dev.region_info[i].offset +
  104f90:	e0fff917 	ldw	r3,-28(fp)
  104f94:	e0bffe17 	ldw	r2,-8(fp)
  104f98:	1004913a 	slli	r2,r2,4
  104f9c:	1885883a 	add	r2,r3,r2
  104fa0:	10c00d17 	ldw	r3,52(r2)
            flash->dev.region_info[i].region_size)))
  104fa4:	e13ff917 	ldw	r4,-28(fp)
  104fa8:	e0bffe17 	ldw	r2,-8(fp)
  104fac:	1004913a 	slli	r2,r2,4
  104fb0:	2085883a 	add	r2,r4,r2
  104fb4:	10800e17 	ldw	r2,56(r2)
            (offset < (flash->dev.region_info[i].offset +
  104fb8:	1885883a 	add	r2,r3,r2
        if((offset >= flash->dev.region_info[i].offset) &&
  104fbc:	e0fff617 	ldw	r3,-40(fp)
  104fc0:	18806b0e 	bge	r3,r2,105170 <alt_onchip_flash_write+0x270>
        {
            current_offset = flash->dev.region_info[i].offset;
  104fc4:	e0fff917 	ldw	r3,-28(fp)
  104fc8:	e0bffe17 	ldw	r2,-8(fp)
  104fcc:	1004913a 	slli	r2,r2,4
  104fd0:	1885883a 	add	r2,r3,r2
  104fd4:	10800d17 	ldw	r2,52(r2)
  104fd8:	e0bffc15 	stw	r2,-16(fp)

            for(j=0;j<flash->dev.region_info[i].number_of_blocks;j++)
  104fdc:	e03ffd15 	stw	zero,-12(fp)
  104fe0:	00005c06 	br	105154 <alt_onchip_flash_write+0x254>
            {
                if ((offset >= current_offset ) &&
  104fe4:	e0fff617 	ldw	r3,-40(fp)
  104fe8:	e0bffc17 	ldw	r2,-16(fp)
  104fec:	18804d16 	blt	r3,r2,105124 <alt_onchip_flash_write+0x224>
                    (offset < (current_offset +
                    flash->dev.region_info[i].block_size)))
  104ff0:	e0fff917 	ldw	r3,-28(fp)
  104ff4:	e0bffe17 	ldw	r2,-8(fp)
  104ff8:	10800104 	addi	r2,r2,4
  104ffc:	1004913a 	slli	r2,r2,4
  105000:	1885883a 	add	r2,r3,r2
  105004:	10c00017 	ldw	r3,0(r2)
                    (offset < (current_offset +
  105008:	e0bffc17 	ldw	r2,-16(fp)
  10500c:	1885883a 	add	r2,r3,r2
                if ((offset >= current_offset ) &&
  105010:	e0fff617 	ldw	r3,-40(fp)
  105014:	1880430e 	bge	r3,r2,105124 <alt_onchip_flash_write+0x224>
                {
                    /*
                    * Check if the contents of the block are different
                    * from the data we wish to put there
                    */
                    data_to_write = (current_offset + flash->dev.region_info[i].block_size - offset);
  105018:	e0fff917 	ldw	r3,-28(fp)
  10501c:	e0bffe17 	ldw	r2,-8(fp)
  105020:	10800104 	addi	r2,r2,4
  105024:	1004913a 	slli	r2,r2,4
  105028:	1885883a 	add	r2,r3,r2
  10502c:	10c00017 	ldw	r3,0(r2)
  105030:	e0bffc17 	ldw	r2,-16(fp)
  105034:	1887883a 	add	r3,r3,r2
  105038:	e0bff617 	ldw	r2,-40(fp)
  10503c:	1885c83a 	sub	r2,r3,r2
  105040:	e0bff815 	stw	r2,-32(fp)
                    data_to_write = MIN(data_to_write, length);
  105044:	e0fff817 	ldw	r3,-32(fp)
  105048:	e0bff417 	ldw	r2,-48(fp)
  10504c:	1880010e 	bge	r3,r2,105054 <alt_onchip_flash_write+0x154>
  105050:	1805883a 	mov	r2,r3
  105054:	e0bff815 	stw	r2,-32(fp)
                    if(memcmp(src_addr, (alt_u8*)flash->dev.base_addr+offset, data_to_write))
  105058:	e0bff917 	ldw	r2,-28(fp)
  10505c:	10c00a17 	ldw	r3,40(r2)
  105060:	e0bff617 	ldw	r2,-40(fp)
  105064:	1885883a 	add	r2,r3,r2
  105068:	e0fff817 	ldw	r3,-32(fp)
  10506c:	180d883a 	mov	r6,r3
  105070:	100b883a 	mov	r5,r2
  105074:	e13ff517 	ldw	r4,-44(fp)
  105078:	01067a80 	call	1067a8 <memcmp>
  10507c:	10001326 	beq	r2,zero,1050cc <alt_onchip_flash_write+0x1cc>
                    {
                        ret_code = (*flash->dev.erase_block)(&flash->dev, current_offset);
  105080:	e0bff917 	ldw	r2,-28(fp)
  105084:	10800817 	ldw	r2,32(r2)
  105088:	e0fff917 	ldw	r3,-28(fp)
  10508c:	e17ffc17 	ldw	r5,-16(fp)
  105090:	1809883a 	mov	r4,r3
  105094:	103ee83a 	callr	r2
  105098:	e0bfff15 	stw	r2,-4(fp)

                        if (!ret_code)
  10509c:	e0bfff17 	ldw	r2,-4(fp)
  1050a0:	10000a1e 	bne	r2,zero,1050cc <alt_onchip_flash_write+0x1cc>
                        {
                            ret_code = (*flash->dev.write_block)(
  1050a4:	e0bff917 	ldw	r2,-28(fp)
  1050a8:	10800917 	ldw	r2,36(r2)
  1050ac:	e13ff917 	ldw	r4,-28(fp)
  1050b0:	e0fff817 	ldw	r3,-32(fp)
  1050b4:	d8c00015 	stw	r3,0(sp)
  1050b8:	e1fff517 	ldw	r7,-44(fp)
  1050bc:	e1bff617 	ldw	r6,-40(fp)
  1050c0:	e17ffc17 	ldw	r5,-16(fp)
  1050c4:	103ee83a 	callr	r2
  1050c8:	e0bfff15 	stw	r2,-4(fp)
                                                                data_to_write);
                        }
                    }

                    /* Was this the last block? */
                    if ((length == data_to_write) || ret_code)
  1050cc:	e0fff417 	ldw	r3,-48(fp)
  1050d0:	e0bff817 	ldw	r2,-32(fp)
  1050d4:	18802e26 	beq	r3,r2,105190 <alt_onchip_flash_write+0x290>
  1050d8:	e0bfff17 	ldw	r2,-4(fp)
  1050dc:	10002c1e 	bne	r2,zero,105190 <alt_onchip_flash_write+0x290>
                    {
                        goto finished;
                    }

                    length -= data_to_write;
  1050e0:	e0fff417 	ldw	r3,-48(fp)
  1050e4:	e0bff817 	ldw	r2,-32(fp)
  1050e8:	1885c83a 	sub	r2,r3,r2
  1050ec:	e0bff415 	stw	r2,-48(fp)
                    offset = current_offset + flash->dev.region_info[i].block_size;
  1050f0:	e0fff917 	ldw	r3,-28(fp)
  1050f4:	e0bffe17 	ldw	r2,-8(fp)
  1050f8:	10800104 	addi	r2,r2,4
  1050fc:	1004913a 	slli	r2,r2,4
  105100:	1885883a 	add	r2,r3,r2
  105104:	10800017 	ldw	r2,0(r2)
  105108:	e0fffc17 	ldw	r3,-16(fp)
  10510c:	1885883a 	add	r2,r3,r2
  105110:	e0bff615 	stw	r2,-40(fp)
                    src_addr = (alt_u8*)src_addr + data_to_write;
  105114:	e0bff817 	ldw	r2,-32(fp)
  105118:	e0fff517 	ldw	r3,-44(fp)
  10511c:	1885883a 	add	r2,r3,r2
  105120:	e0bff515 	stw	r2,-44(fp)
                }
                current_offset += flash->dev.region_info[i].block_size;
  105124:	e0fff917 	ldw	r3,-28(fp)
  105128:	e0bffe17 	ldw	r2,-8(fp)
  10512c:	10800104 	addi	r2,r2,4
  105130:	1004913a 	slli	r2,r2,4
  105134:	1885883a 	add	r2,r3,r2
  105138:	10800017 	ldw	r2,0(r2)
  10513c:	e0fffc17 	ldw	r3,-16(fp)
  105140:	1885883a 	add	r2,r3,r2
  105144:	e0bffc15 	stw	r2,-16(fp)
            for(j=0;j<flash->dev.region_info[i].number_of_blocks;j++)
  105148:	e0bffd17 	ldw	r2,-12(fp)
  10514c:	10800044 	addi	r2,r2,1
  105150:	e0bffd15 	stw	r2,-12(fp)
  105154:	e0fff917 	ldw	r3,-28(fp)
  105158:	e0bffe17 	ldw	r2,-8(fp)
  10515c:	1004913a 	slli	r2,r2,4
  105160:	1885883a 	add	r2,r3,r2
  105164:	10800f17 	ldw	r2,60(r2)
  105168:	e0fffd17 	ldw	r3,-12(fp)
  10516c:	18bf9d16 	blt	r3,r2,104fe4 <alt_onchip_flash_write+0xe4>
    for(i=0;i<flash->dev.number_of_regions;i++)
  105170:	e0bffe17 	ldw	r2,-8(fp)
  105174:	10800044 	addi	r2,r2,1
  105178:	e0bffe15 	stw	r2,-8(fp)
  10517c:	e0bff917 	ldw	r2,-28(fp)
  105180:	10800c17 	ldw	r2,48(r2)
  105184:	e0fffe17 	ldw	r3,-8(fp)
  105188:	18bf7a16 	blt	r3,r2,104f74 <alt_onchip_flash_write+0x74>
            }
        }
    }

finished:
  10518c:	00000106 	br	105194 <alt_onchip_flash_write+0x294>
                        goto finished;
  105190:	0001883a 	nop
    alt_dcache_flush((alt_u8*)flash->dev.base_addr+start_offset, full_length);
  105194:	e0bff917 	ldw	r2,-28(fp)
  105198:	10c00a17 	ldw	r3,40(r2)
  10519c:	e0bffa17 	ldw	r2,-24(fp)
  1051a0:	1885883a 	add	r2,r3,r2
  1051a4:	e0fffb17 	ldw	r3,-20(fp)
  1051a8:	180b883a 	mov	r5,r3
  1051ac:	1009883a 	mov	r4,r2
  1051b0:	0105bc00 	call	105bc0 <alt_dcache_flush>
    return ret_code;
  1051b4:	e0bfff17 	ldw	r2,-4(fp)
}
  1051b8:	e037883a 	mov	sp,fp
  1051bc:	dfc00117 	ldw	ra,4(sp)
  1051c0:	df000017 	ldw	fp,0(sp)
  1051c4:	dec00204 	addi	sp,sp,8
  1051c8:	f800283a 	ret

001051cc <altera_onchip_flash_init>:
**/
void altera_onchip_flash_init
(
    alt_onchip_flash_dev *flash
)
{
  1051cc:	defff504 	addi	sp,sp,-44
  1051d0:	dfc00a15 	stw	ra,40(sp)
  1051d4:	df000915 	stw	fp,36(sp)
  1051d8:	dc000815 	stw	r16,32(sp)
  1051dc:	df000904 	addi	fp,sp,36
  1051e0:	e13ff715 	stw	r4,-36(fp)
    /* A region is a sector of the onchip flash */
    int number_of_regions;
    flash_region* region_info;
    int sector1_status = ALTERA_ONCHIP_FLASH_STATUS_SECTOR1_AVAILABLE;
  1051e4:	e03ffd15 	stw	zero,-12(fp)
    int sector2_status = ALTERA_ONCHIP_FLASH_STATUS_SECTOR2_AVAILABLE;
  1051e8:	e03ffc15 	stw	zero,-16(fp)
    int sector3_status = ALTERA_ONCHIP_FLASH_STATUS_SECTOR3_AVAILABLE;
  1051ec:	e03ffb15 	stw	zero,-20(fp)
    int sector4_status = ALTERA_ONCHIP_FLASH_STATUS_SECTOR4_AVAILABLE;
  1051f0:	e03ffa15 	stw	zero,-24(fp)
    int sector5_status = ALTERA_ONCHIP_FLASH_STATUS_SECTOR5_AVAILABLE;
  1051f4:	e03ff915 	stw	zero,-28(fp)

    /* Set up flash_region data structures. */
    number_of_regions = 0;
  1051f8:	e03ffe15 	stw	zero,-8(fp)
    region_info = &flash->dev.region_info[0];
  1051fc:	e0bff717 	ldw	r2,-36(fp)
  105200:	10800d04 	addi	r2,r2,52
  105204:	e0bff815 	stw	r2,-32(fp)

    if (flash->csr_base != NULL) {
  105208:	e0bff717 	ldw	r2,-36(fp)
  10520c:	10802f17 	ldw	r2,188(r2)
  105210:	10001926 	beq	r2,zero,105278 <altera_onchip_flash_init+0xac>
        sector1_status = IORD_ALTERA_ONCHIP_FLASH_STATUS(flash->csr_base) & ALTERA_ONCHIP_FLASH_STATUS_SECTOR1_MSK;
  105214:	e0bff717 	ldw	r2,-36(fp)
  105218:	10802f17 	ldw	r2,188(r2)
  10521c:	10800037 	ldwio	r2,0(r2)
  105220:	1080080c 	andi	r2,r2,32
  105224:	e0bffd15 	stw	r2,-12(fp)
        sector2_status = IORD_ALTERA_ONCHIP_FLASH_STATUS(flash->csr_base) & ALTERA_ONCHIP_FLASH_STATUS_SECTOR2_MSK;
  105228:	e0bff717 	ldw	r2,-36(fp)
  10522c:	10802f17 	ldw	r2,188(r2)
  105230:	10800037 	ldwio	r2,0(r2)
  105234:	1080100c 	andi	r2,r2,64
  105238:	e0bffc15 	stw	r2,-16(fp)
        sector3_status = IORD_ALTERA_ONCHIP_FLASH_STATUS(flash->csr_base) & ALTERA_ONCHIP_FLASH_STATUS_SECTOR3_MSK;
  10523c:	e0bff717 	ldw	r2,-36(fp)
  105240:	10802f17 	ldw	r2,188(r2)
  105244:	10800037 	ldwio	r2,0(r2)
  105248:	1080200c 	andi	r2,r2,128
  10524c:	e0bffb15 	stw	r2,-20(fp)
        sector4_status = IORD_ALTERA_ONCHIP_FLASH_STATUS(flash->csr_base) & ALTERA_ONCHIP_FLASH_STATUS_SECTOR4_MSK;
  105250:	e0bff717 	ldw	r2,-36(fp)
  105254:	10802f17 	ldw	r2,188(r2)
  105258:	10800037 	ldwio	r2,0(r2)
  10525c:	1080400c 	andi	r2,r2,256
  105260:	e0bffa15 	stw	r2,-24(fp)
        sector5_status = IORD_ALTERA_ONCHIP_FLASH_STATUS(flash->csr_base) & ALTERA_ONCHIP_FLASH_STATUS_SECTOR5_MSK;
  105264:	e0bff717 	ldw	r2,-36(fp)
  105268:	10802f17 	ldw	r2,188(r2)
  10526c:	10800037 	ldwio	r2,0(r2)
  105270:	1080800c 	andi	r2,r2,512
  105274:	e0bff915 	stw	r2,-28(fp)
    }

    if ((flash->sector1_enabled == 1) && (sector1_status != ALTERA_ONCHIP_FLASH_STATUS_SECTOR1_UNAVAILABLE)) {
  105278:	e0bff717 	ldw	r2,-36(fp)
  10527c:	10803017 	ldw	r2,192(r2)
  105280:	10800058 	cmpnei	r2,r2,1
  105284:	10002c1e 	bne	r2,zero,105338 <altera_onchip_flash_init+0x16c>
  105288:	e0bffd17 	ldw	r2,-12(fp)
  10528c:	10800820 	cmpeqi	r2,r2,32
  105290:	1000291e 	bne	r2,zero,105338 <altera_onchip_flash_init+0x16c>

        region_info[number_of_regions].offset = flash->sector1_start_addr;
  105294:	e0bffe17 	ldw	r2,-8(fp)
  105298:	1004913a 	slli	r2,r2,4
  10529c:	e0fff817 	ldw	r3,-32(fp)
  1052a0:	1885883a 	add	r2,r3,r2
  1052a4:	e0fff717 	ldw	r3,-36(fp)
  1052a8:	18c03117 	ldw	r3,196(r3)
  1052ac:	10c00015 	stw	r3,0(r2)
        region_info[number_of_regions].region_size = flash->sector1_end_addr - flash->sector1_start_addr + 1;
  1052b0:	e0bff717 	ldw	r2,-36(fp)
  1052b4:	10c03217 	ldw	r3,200(r2)
  1052b8:	e0bff717 	ldw	r2,-36(fp)
  1052bc:	10803117 	ldw	r2,196(r2)
  1052c0:	1887c83a 	sub	r3,r3,r2
  1052c4:	e0bffe17 	ldw	r2,-8(fp)
  1052c8:	1004913a 	slli	r2,r2,4
  1052cc:	e13ff817 	ldw	r4,-32(fp)
  1052d0:	2085883a 	add	r2,r4,r2
  1052d4:	18c00044 	addi	r3,r3,1
  1052d8:	10c00115 	stw	r3,4(r2)
        region_info[number_of_regions].number_of_blocks = flash->dev.region_info[number_of_regions].region_size / flash->page_size;
  1052dc:	e0fff717 	ldw	r3,-36(fp)
  1052e0:	e0bffe17 	ldw	r2,-8(fp)
  1052e4:	1004913a 	slli	r2,r2,4
  1052e8:	1885883a 	add	r2,r3,r2
  1052ec:	11000e17 	ldw	r4,56(r2)
  1052f0:	e0bff717 	ldw	r2,-36(fp)
  1052f4:	11403f17 	ldw	r5,252(r2)
  1052f8:	e0bffe17 	ldw	r2,-8(fp)
  1052fc:	1004913a 	slli	r2,r2,4
  105300:	e0fff817 	ldw	r3,-32(fp)
  105304:	18a1883a 	add	r16,r3,r2
  105308:	0102cdc0 	call	102cdc <__divsi3>
  10530c:	80800215 	stw	r2,8(r16)
        region_info[number_of_regions].block_size = flash->page_size;
  105310:	e0bffe17 	ldw	r2,-8(fp)
  105314:	1004913a 	slli	r2,r2,4
  105318:	e0fff817 	ldw	r3,-32(fp)
  10531c:	1885883a 	add	r2,r3,r2
  105320:	e0fff717 	ldw	r3,-36(fp)
  105324:	18c03f17 	ldw	r3,252(r3)
  105328:	10c00315 	stw	r3,12(r2)

        number_of_regions++;
  10532c:	e0bffe17 	ldw	r2,-8(fp)
  105330:	10800044 	addi	r2,r2,1
  105334:	e0bffe15 	stw	r2,-8(fp)
    }

    if ((flash->sector2_enabled == 1) && (sector2_status != ALTERA_ONCHIP_FLASH_STATUS_SECTOR2_UNAVAILABLE)) {
  105338:	e0bff717 	ldw	r2,-36(fp)
  10533c:	10803317 	ldw	r2,204(r2)
  105340:	10800058 	cmpnei	r2,r2,1
  105344:	10002c1e 	bne	r2,zero,1053f8 <altera_onchip_flash_init+0x22c>
  105348:	e0bffc17 	ldw	r2,-16(fp)
  10534c:	10801020 	cmpeqi	r2,r2,64
  105350:	1000291e 	bne	r2,zero,1053f8 <altera_onchip_flash_init+0x22c>

        region_info[number_of_regions].offset = flash->sector2_start_addr;
  105354:	e0bffe17 	ldw	r2,-8(fp)
  105358:	1004913a 	slli	r2,r2,4
  10535c:	e0fff817 	ldw	r3,-32(fp)
  105360:	1885883a 	add	r2,r3,r2
  105364:	e0fff717 	ldw	r3,-36(fp)
  105368:	18c03417 	ldw	r3,208(r3)
  10536c:	10c00015 	stw	r3,0(r2)
        region_info[number_of_regions].region_size = flash->sector2_end_addr - flash->sector2_start_addr + 1;
  105370:	e0bff717 	ldw	r2,-36(fp)
  105374:	10c03517 	ldw	r3,212(r2)
  105378:	e0bff717 	ldw	r2,-36(fp)
  10537c:	10803417 	ldw	r2,208(r2)
  105380:	1887c83a 	sub	r3,r3,r2
  105384:	e0bffe17 	ldw	r2,-8(fp)
  105388:	1004913a 	slli	r2,r2,4
  10538c:	e13ff817 	ldw	r4,-32(fp)
  105390:	2085883a 	add	r2,r4,r2
  105394:	18c00044 	addi	r3,r3,1
  105398:	10c00115 	stw	r3,4(r2)
        region_info[number_of_regions].number_of_blocks = flash->dev.region_info[number_of_regions].region_size / flash->page_size;
  10539c:	e0fff717 	ldw	r3,-36(fp)
  1053a0:	e0bffe17 	ldw	r2,-8(fp)
  1053a4:	1004913a 	slli	r2,r2,4
  1053a8:	1885883a 	add	r2,r3,r2
  1053ac:	11000e17 	ldw	r4,56(r2)
  1053b0:	e0bff717 	ldw	r2,-36(fp)
  1053b4:	11403f17 	ldw	r5,252(r2)
  1053b8:	e0bffe17 	ldw	r2,-8(fp)
  1053bc:	1004913a 	slli	r2,r2,4
  1053c0:	e0fff817 	ldw	r3,-32(fp)
  1053c4:	18a1883a 	add	r16,r3,r2
  1053c8:	0102cdc0 	call	102cdc <__divsi3>
  1053cc:	80800215 	stw	r2,8(r16)
        region_info[number_of_regions].block_size = flash->page_size;
  1053d0:	e0bffe17 	ldw	r2,-8(fp)
  1053d4:	1004913a 	slli	r2,r2,4
  1053d8:	e0fff817 	ldw	r3,-32(fp)
  1053dc:	1885883a 	add	r2,r3,r2
  1053e0:	e0fff717 	ldw	r3,-36(fp)
  1053e4:	18c03f17 	ldw	r3,252(r3)
  1053e8:	10c00315 	stw	r3,12(r2)

        number_of_regions++;
  1053ec:	e0bffe17 	ldw	r2,-8(fp)
  1053f0:	10800044 	addi	r2,r2,1
  1053f4:	e0bffe15 	stw	r2,-8(fp)
	}

    if ((flash->sector3_enabled == 1) && (sector3_status != ALTERA_ONCHIP_FLASH_STATUS_SECTOR3_UNAVAILABLE)) {
  1053f8:	e0bff717 	ldw	r2,-36(fp)
  1053fc:	10803617 	ldw	r2,216(r2)
  105400:	10800058 	cmpnei	r2,r2,1
  105404:	10002c1e 	bne	r2,zero,1054b8 <altera_onchip_flash_init+0x2ec>
  105408:	e0bffb17 	ldw	r2,-20(fp)
  10540c:	10802020 	cmpeqi	r2,r2,128
  105410:	1000291e 	bne	r2,zero,1054b8 <altera_onchip_flash_init+0x2ec>

        region_info[number_of_regions].offset = flash->sector3_start_addr;
  105414:	e0bffe17 	ldw	r2,-8(fp)
  105418:	1004913a 	slli	r2,r2,4
  10541c:	e0fff817 	ldw	r3,-32(fp)
  105420:	1885883a 	add	r2,r3,r2
  105424:	e0fff717 	ldw	r3,-36(fp)
  105428:	18c03717 	ldw	r3,220(r3)
  10542c:	10c00015 	stw	r3,0(r2)
        region_info[number_of_regions].region_size = flash->sector3_end_addr - flash->sector3_start_addr + 1;
  105430:	e0bff717 	ldw	r2,-36(fp)
  105434:	10c03817 	ldw	r3,224(r2)
  105438:	e0bff717 	ldw	r2,-36(fp)
  10543c:	10803717 	ldw	r2,220(r2)
  105440:	1887c83a 	sub	r3,r3,r2
  105444:	e0bffe17 	ldw	r2,-8(fp)
  105448:	1004913a 	slli	r2,r2,4
  10544c:	e13ff817 	ldw	r4,-32(fp)
  105450:	2085883a 	add	r2,r4,r2
  105454:	18c00044 	addi	r3,r3,1
  105458:	10c00115 	stw	r3,4(r2)
        region_info[number_of_regions].number_of_blocks = flash->dev.region_info[number_of_regions].region_size / flash->page_size;
  10545c:	e0fff717 	ldw	r3,-36(fp)
  105460:	e0bffe17 	ldw	r2,-8(fp)
  105464:	1004913a 	slli	r2,r2,4
  105468:	1885883a 	add	r2,r3,r2
  10546c:	11000e17 	ldw	r4,56(r2)
  105470:	e0bff717 	ldw	r2,-36(fp)
  105474:	11403f17 	ldw	r5,252(r2)
  105478:	e0bffe17 	ldw	r2,-8(fp)
  10547c:	1004913a 	slli	r2,r2,4
  105480:	e0fff817 	ldw	r3,-32(fp)
  105484:	18a1883a 	add	r16,r3,r2
  105488:	0102cdc0 	call	102cdc <__divsi3>
  10548c:	80800215 	stw	r2,8(r16)
        region_info[number_of_regions].block_size = flash->page_size;
  105490:	e0bffe17 	ldw	r2,-8(fp)
  105494:	1004913a 	slli	r2,r2,4
  105498:	e0fff817 	ldw	r3,-32(fp)
  10549c:	1885883a 	add	r2,r3,r2
  1054a0:	e0fff717 	ldw	r3,-36(fp)
  1054a4:	18c03f17 	ldw	r3,252(r3)
  1054a8:	10c00315 	stw	r3,12(r2)

        number_of_regions++;
  1054ac:	e0bffe17 	ldw	r2,-8(fp)
  1054b0:	10800044 	addi	r2,r2,1
  1054b4:	e0bffe15 	stw	r2,-8(fp)
	}

	if ((flash->sector4_enabled == 1) && (sector4_status != ALTERA_ONCHIP_FLASH_STATUS_SECTOR4_UNAVAILABLE)) {
  1054b8:	e0bff717 	ldw	r2,-36(fp)
  1054bc:	10803917 	ldw	r2,228(r2)
  1054c0:	10800058 	cmpnei	r2,r2,1
  1054c4:	10002c1e 	bne	r2,zero,105578 <altera_onchip_flash_init+0x3ac>
  1054c8:	e0bffa17 	ldw	r2,-24(fp)
  1054cc:	10804020 	cmpeqi	r2,r2,256
  1054d0:	1000291e 	bne	r2,zero,105578 <altera_onchip_flash_init+0x3ac>

        region_info[number_of_regions].offset = flash->sector4_start_addr;
  1054d4:	e0bffe17 	ldw	r2,-8(fp)
  1054d8:	1004913a 	slli	r2,r2,4
  1054dc:	e0fff817 	ldw	r3,-32(fp)
  1054e0:	1885883a 	add	r2,r3,r2
  1054e4:	e0fff717 	ldw	r3,-36(fp)
  1054e8:	18c03a17 	ldw	r3,232(r3)
  1054ec:	10c00015 	stw	r3,0(r2)
        region_info[number_of_regions].region_size = flash->sector4_end_addr - flash->sector4_start_addr + 1;
  1054f0:	e0bff717 	ldw	r2,-36(fp)
  1054f4:	10c03b17 	ldw	r3,236(r2)
  1054f8:	e0bff717 	ldw	r2,-36(fp)
  1054fc:	10803a17 	ldw	r2,232(r2)
  105500:	1887c83a 	sub	r3,r3,r2
  105504:	e0bffe17 	ldw	r2,-8(fp)
  105508:	1004913a 	slli	r2,r2,4
  10550c:	e13ff817 	ldw	r4,-32(fp)
  105510:	2085883a 	add	r2,r4,r2
  105514:	18c00044 	addi	r3,r3,1
  105518:	10c00115 	stw	r3,4(r2)
        region_info[number_of_regions].number_of_blocks = flash->dev.region_info[number_of_regions].region_size / flash->page_size;
  10551c:	e0fff717 	ldw	r3,-36(fp)
  105520:	e0bffe17 	ldw	r2,-8(fp)
  105524:	1004913a 	slli	r2,r2,4
  105528:	1885883a 	add	r2,r3,r2
  10552c:	11000e17 	ldw	r4,56(r2)
  105530:	e0bff717 	ldw	r2,-36(fp)
  105534:	11403f17 	ldw	r5,252(r2)
  105538:	e0bffe17 	ldw	r2,-8(fp)
  10553c:	1004913a 	slli	r2,r2,4
  105540:	e0fff817 	ldw	r3,-32(fp)
  105544:	18a1883a 	add	r16,r3,r2
  105548:	0102cdc0 	call	102cdc <__divsi3>
  10554c:	80800215 	stw	r2,8(r16)
        region_info[number_of_regions].block_size = flash->page_size;
  105550:	e0bffe17 	ldw	r2,-8(fp)
  105554:	1004913a 	slli	r2,r2,4
  105558:	e0fff817 	ldw	r3,-32(fp)
  10555c:	1885883a 	add	r2,r3,r2
  105560:	e0fff717 	ldw	r3,-36(fp)
  105564:	18c03f17 	ldw	r3,252(r3)
  105568:	10c00315 	stw	r3,12(r2)

        number_of_regions++;
  10556c:	e0bffe17 	ldw	r2,-8(fp)
  105570:	10800044 	addi	r2,r2,1
  105574:	e0bffe15 	stw	r2,-8(fp)
	}

    if ((flash->sector5_enabled == 1) && (sector5_status != ALTERA_ONCHIP_FLASH_STATUS_SECTOR5_UNAVAILABLE)) {
  105578:	e0bff717 	ldw	r2,-36(fp)
  10557c:	10803c17 	ldw	r2,240(r2)
  105580:	10800058 	cmpnei	r2,r2,1
  105584:	10002c1e 	bne	r2,zero,105638 <altera_onchip_flash_init+0x46c>
  105588:	e0bff917 	ldw	r2,-28(fp)
  10558c:	10808020 	cmpeqi	r2,r2,512
  105590:	1000291e 	bne	r2,zero,105638 <altera_onchip_flash_init+0x46c>

        region_info[number_of_regions].offset = flash->sector5_start_addr;
  105594:	e0bffe17 	ldw	r2,-8(fp)
  105598:	1004913a 	slli	r2,r2,4
  10559c:	e0fff817 	ldw	r3,-32(fp)
  1055a0:	1885883a 	add	r2,r3,r2
  1055a4:	e0fff717 	ldw	r3,-36(fp)
  1055a8:	18c03d17 	ldw	r3,244(r3)
  1055ac:	10c00015 	stw	r3,0(r2)
        region_info[number_of_regions].region_size = flash->sector5_end_addr - flash->sector5_start_addr + 1;
  1055b0:	e0bff717 	ldw	r2,-36(fp)
  1055b4:	10c03e17 	ldw	r3,248(r2)
  1055b8:	e0bff717 	ldw	r2,-36(fp)
  1055bc:	10803d17 	ldw	r2,244(r2)
  1055c0:	1887c83a 	sub	r3,r3,r2
  1055c4:	e0bffe17 	ldw	r2,-8(fp)
  1055c8:	1004913a 	slli	r2,r2,4
  1055cc:	e13ff817 	ldw	r4,-32(fp)
  1055d0:	2085883a 	add	r2,r4,r2
  1055d4:	18c00044 	addi	r3,r3,1
  1055d8:	10c00115 	stw	r3,4(r2)
        region_info[number_of_regions].number_of_blocks = flash->dev.region_info[number_of_regions].region_size / flash->page_size;
  1055dc:	e0fff717 	ldw	r3,-36(fp)
  1055e0:	e0bffe17 	ldw	r2,-8(fp)
  1055e4:	1004913a 	slli	r2,r2,4
  1055e8:	1885883a 	add	r2,r3,r2
  1055ec:	11000e17 	ldw	r4,56(r2)
  1055f0:	e0bff717 	ldw	r2,-36(fp)
  1055f4:	11403f17 	ldw	r5,252(r2)
  1055f8:	e0bffe17 	ldw	r2,-8(fp)
  1055fc:	1004913a 	slli	r2,r2,4
  105600:	e0fff817 	ldw	r3,-32(fp)
  105604:	18a1883a 	add	r16,r3,r2
  105608:	0102cdc0 	call	102cdc <__divsi3>
  10560c:	80800215 	stw	r2,8(r16)
        region_info[number_of_regions].block_size = flash->page_size;
  105610:	e0bffe17 	ldw	r2,-8(fp)
  105614:	1004913a 	slli	r2,r2,4
  105618:	e0fff817 	ldw	r3,-32(fp)
  10561c:	1885883a 	add	r2,r3,r2
  105620:	e0fff717 	ldw	r3,-36(fp)
  105624:	18c03f17 	ldw	r3,252(r3)
  105628:	10c00315 	stw	r3,12(r2)

        number_of_regions++;
  10562c:	e0bffe17 	ldw	r2,-8(fp)
  105630:	10800044 	addi	r2,r2,1
  105634:	e0bffe15 	stw	r2,-8(fp)
    }

    /* Update number of regions. */
    flash->dev.number_of_regions = number_of_regions;
  105638:	e0bff717 	ldw	r2,-36(fp)
  10563c:	e0fffe17 	ldw	r3,-8(fp)
  105640:	10c00c15 	stw	r3,48(r2)

    /*
    *  Register this device as a valid flash device type
    */
    alt_flash_device_register(&(flash->dev));
  105644:	e0bff717 	ldw	r2,-36(fp)
  105648:	1009883a 	mov	r4,r2
  10564c:	01049240 	call	104924 <alt_flash_device_register>
}
  105650:	0001883a 	nop
  105654:	e6ffff04 	addi	sp,fp,-4
  105658:	dfc00217 	ldw	ra,8(sp)
  10565c:	df000117 	ldw	fp,4(sp)
  105660:	dc000017 	ldw	r16,0(sp)
  105664:	dec00304 	addi	sp,sp,12
  105668:	f800283a 	ret

0010566c <alt_onchip_flash_poll_for_status_to_go_idle>:
**/
int alt_onchip_flash_poll_for_status_to_go_idle
(
    alt_onchip_flash_dev *flash
)
{
  10566c:	defffa04 	addi	sp,sp,-24
  105670:	dfc00515 	stw	ra,20(sp)
  105674:	df000415 	stw	fp,16(sp)
  105678:	df000404 	addi	fp,sp,16
  10567c:	e13ffc15 	stw	r4,-16(fp)
    int ret_code = 0;
  105680:	e03fff15 	stw	zero,-4(fp)
    int timeout = ALTERA_ONCHIP_FLASH_STATUS_BIT_POLLING_TIMEOUT_VALUE;
  105684:	008002f4 	movhi	r2,11
  105688:	10ab9804 	addi	r2,r2,-20896
  10568c:	e0bffd15 	stw	r2,-12(fp)
    int count_down = ALTERA_ONCHIP_FLASH_STATUS_BIT_POLLING_TIMEOUT_VALUE;
  105690:	008002f4 	movhi	r2,11
  105694:	10ab9804 	addi	r2,r2,-20896
  105698:	e0bffe15 	stw	r2,-8(fp)

    while (
  10569c:	00000c06 	br	1056d0 <alt_onchip_flash_poll_for_status_to_go_idle+0x64>
        (IORD_ALTERA_ONCHIP_FLASH_STATUS(flash->csr_base) &
              ALTERA_ONCHIP_FLASH_STATUS_BUSY_MSK
        ) !=  ALTERA_ONCHIP_FLASH_STATUS_BUSY_IDLE
    ) {
	 
	alt_busy_sleep(1); /* delay 1us */
  1056a0:	01000044 	movi	r4,1
  1056a4:	01059500 	call	105950 <alt_busy_sleep>

        /* If timeout value is zero, it will never timeout. */
        if (timeout != 0) {
  1056a8:	e0bffd17 	ldw	r2,-12(fp)
  1056ac:	10000826 	beq	r2,zero,1056d0 <alt_onchip_flash_poll_for_status_to_go_idle+0x64>
            count_down--;
  1056b0:	e0bffe17 	ldw	r2,-8(fp)
  1056b4:	10bfffc4 	addi	r2,r2,-1
  1056b8:	e0bffe15 	stw	r2,-8(fp)
            if (count_down == 0) {
  1056bc:	e0bffe17 	ldw	r2,-8(fp)
  1056c0:	1000031e 	bne	r2,zero,1056d0 <alt_onchip_flash_poll_for_status_to_go_idle+0x64>
                /* Timeout */
                ret_code = -ETIMEDOUT;
  1056c4:	00bfe304 	movi	r2,-116
  1056c8:	e0bfff15 	stw	r2,-4(fp)
                break;
  1056cc:	00000506 	br	1056e4 <alt_onchip_flash_poll_for_status_to_go_idle+0x78>
        (IORD_ALTERA_ONCHIP_FLASH_STATUS(flash->csr_base) &
  1056d0:	e0bffc17 	ldw	r2,-16(fp)
  1056d4:	10802f17 	ldw	r2,188(r2)
  1056d8:	10800037 	ldwio	r2,0(r2)
  1056dc:	108000cc 	andi	r2,r2,3
    while (
  1056e0:	103fef1e 	bne	r2,zero,1056a0 <alt_onchip_flash_poll_for_status_to_go_idle+0x34>
            }
        }
    }

    return ret_code;
  1056e4:	e0bfff17 	ldw	r2,-4(fp)
}
  1056e8:	e037883a 	mov	sp,fp
  1056ec:	dfc00117 	ldw	ra,4(sp)
  1056f0:	df000017 	ldw	fp,0(sp)
  1056f4:	dec00204 	addi	sp,sp,8
  1056f8:	f800283a 	ret

001056fc <alt_onchip_flash_poll_for_status_erase_passed>:
**/
int alt_onchip_flash_poll_for_status_erase_passed
(
    alt_onchip_flash_dev *flash
)
{
  1056fc:	defffa04 	addi	sp,sp,-24
  105700:	dfc00515 	stw	ra,20(sp)
  105704:	df000415 	stw	fp,16(sp)
  105708:	df000404 	addi	fp,sp,16
  10570c:	e13ffc15 	stw	r4,-16(fp)
    int ret_code = 0;
  105710:	e03fff15 	stw	zero,-4(fp)
    int timeout = ALTERA_ONCHIP_FLASH_STATUS_BIT_POLLING_TIMEOUT_VALUE;
  105714:	008002f4 	movhi	r2,11
  105718:	10ab9804 	addi	r2,r2,-20896
  10571c:	e0bffd15 	stw	r2,-12(fp)
    int count_down = ALTERA_ONCHIP_FLASH_STATUS_BIT_POLLING_TIMEOUT_VALUE;
  105720:	008002f4 	movhi	r2,11
  105724:	10ab9804 	addi	r2,r2,-20896
  105728:	e0bffe15 	stw	r2,-8(fp)

    while (
  10572c:	00000c06 	br	105760 <alt_onchip_flash_poll_for_status_erase_passed+0x64>
        (IORD_ALTERA_ONCHIP_FLASH_STATUS(flash->csr_base) &
              ALTERA_ONCHIP_FLASH_STATUS_ERASE_MSK
        ) !=  ALTERA_ONCHIP_FLASH_STATUS_ERASE_PASSED
    ) {

	alt_busy_sleep(1); /* delay 1us */
  105730:	01000044 	movi	r4,1
  105734:	01059500 	call	105950 <alt_busy_sleep>

        /* If timeout value is zero, it will never timeout. */
        if (timeout != 0) {
  105738:	e0bffd17 	ldw	r2,-12(fp)
  10573c:	10000826 	beq	r2,zero,105760 <alt_onchip_flash_poll_for_status_erase_passed+0x64>
            count_down--;
  105740:	e0bffe17 	ldw	r2,-8(fp)
  105744:	10bfffc4 	addi	r2,r2,-1
  105748:	e0bffe15 	stw	r2,-8(fp)
            if (count_down == 0) {
  10574c:	e0bffe17 	ldw	r2,-8(fp)
  105750:	1000031e 	bne	r2,zero,105760 <alt_onchip_flash_poll_for_status_erase_passed+0x64>
                /* Timeout */
                ret_code = -ETIMEDOUT;
  105754:	00bfe304 	movi	r2,-116
  105758:	e0bfff15 	stw	r2,-4(fp)
                break;
  10575c:	00000606 	br	105778 <alt_onchip_flash_poll_for_status_erase_passed+0x7c>
        (IORD_ALTERA_ONCHIP_FLASH_STATUS(flash->csr_base) &
  105760:	e0bffc17 	ldw	r2,-16(fp)
  105764:	10802f17 	ldw	r2,188(r2)
  105768:	10800037 	ldwio	r2,0(r2)
  10576c:	1080040c 	andi	r2,r2,16
    while (
  105770:	10800418 	cmpnei	r2,r2,16
  105774:	103fee1e 	bne	r2,zero,105730 <alt_onchip_flash_poll_for_status_erase_passed+0x34>
            }
        }
    }

    return ret_code;
  105778:	e0bfff17 	ldw	r2,-4(fp)
}
  10577c:	e037883a 	mov	sp,fp
  105780:	dfc00117 	ldw	ra,4(sp)
  105784:	df000017 	ldw	fp,0(sp)
  105788:	dec00204 	addi	sp,sp,8
  10578c:	f800283a 	ret

00105790 <alt_onchip_flash_poll_for_status_write_passed>:
**/
int alt_onchip_flash_poll_for_status_write_passed
(
    alt_onchip_flash_dev *flash
)
{
  105790:	defffa04 	addi	sp,sp,-24
  105794:	dfc00515 	stw	ra,20(sp)
  105798:	df000415 	stw	fp,16(sp)
  10579c:	df000404 	addi	fp,sp,16
  1057a0:	e13ffc15 	stw	r4,-16(fp)
    int ret_code = 0;
  1057a4:	e03fff15 	stw	zero,-4(fp)
    int timeout = ALTERA_ONCHIP_FLASH_STATUS_BIT_POLLING_TIMEOUT_VALUE;
  1057a8:	008002f4 	movhi	r2,11
  1057ac:	10ab9804 	addi	r2,r2,-20896
  1057b0:	e0bffd15 	stw	r2,-12(fp)
    int count_down = ALTERA_ONCHIP_FLASH_STATUS_BIT_POLLING_TIMEOUT_VALUE;
  1057b4:	008002f4 	movhi	r2,11
  1057b8:	10ab9804 	addi	r2,r2,-20896
  1057bc:	e0bffe15 	stw	r2,-8(fp)

    while (
  1057c0:	00000c06 	br	1057f4 <alt_onchip_flash_poll_for_status_write_passed+0x64>
        (IORD_ALTERA_ONCHIP_FLASH_STATUS(flash->csr_base) &
              ALTERA_ONCHIP_FLASH_STATUS_WRITE_MSK
        ) !=  ALTERA_ONCHIP_FLASH_STATUS_WRITE_PASSED
    ) {

	alt_busy_sleep(1); /* delay 1us */
  1057c4:	01000044 	movi	r4,1
  1057c8:	01059500 	call	105950 <alt_busy_sleep>

        /* If timeout value is zero, it will never timeout. */
        if (timeout != 0) {
  1057cc:	e0bffd17 	ldw	r2,-12(fp)
  1057d0:	10000826 	beq	r2,zero,1057f4 <alt_onchip_flash_poll_for_status_write_passed+0x64>
            count_down--;
  1057d4:	e0bffe17 	ldw	r2,-8(fp)
  1057d8:	10bfffc4 	addi	r2,r2,-1
  1057dc:	e0bffe15 	stw	r2,-8(fp)
            if (count_down == 0) {
  1057e0:	e0bffe17 	ldw	r2,-8(fp)
  1057e4:	1000031e 	bne	r2,zero,1057f4 <alt_onchip_flash_poll_for_status_write_passed+0x64>
                /* Timeout */
                ret_code = -ETIMEDOUT;
  1057e8:	00bfe304 	movi	r2,-116
  1057ec:	e0bfff15 	stw	r2,-4(fp)
                break;
  1057f0:	00000606 	br	10580c <alt_onchip_flash_poll_for_status_write_passed+0x7c>
        (IORD_ALTERA_ONCHIP_FLASH_STATUS(flash->csr_base) &
  1057f4:	e0bffc17 	ldw	r2,-16(fp)
  1057f8:	10802f17 	ldw	r2,188(r2)
  1057fc:	10800037 	ldwio	r2,0(r2)
  105800:	1080020c 	andi	r2,r2,8
    while (
  105804:	10800218 	cmpnei	r2,r2,8
  105808:	103fee1e 	bne	r2,zero,1057c4 <alt_onchip_flash_poll_for_status_write_passed+0x34>
            }
        }
    }

    return ret_code;
  10580c:	e0bfff17 	ldw	r2,-4(fp)
}
  105810:	e037883a 	mov	sp,fp
  105814:	dfc00117 	ldw	ra,4(sp)
  105818:	df000017 	ldw	fp,0(sp)
  10581c:	dec00204 	addi	sp,sp,8
  105820:	f800283a 	ret

00105824 <alt_alarm_start>:
 */ 

int alt_alarm_start (alt_alarm* alarm, alt_u32 nticks,
                     alt_u32 (*callback) (void* context),
                     void* context)
{
  105824:	defff504 	addi	sp,sp,-44
  105828:	df000a15 	stw	fp,40(sp)
  10582c:	df000a04 	addi	fp,sp,40
  105830:	e13ff915 	stw	r4,-28(fp)
  105834:	e17ff815 	stw	r5,-32(fp)
  105838:	e1bff715 	stw	r6,-36(fp)
  10583c:	e1fff615 	stw	r7,-40(fp)
  alt_irq_context irq_context;
  alt_u32 current_nticks = 0;
  105840:	e03fff15 	stw	zero,-4(fp)
  return _alt_tick_rate;
  105844:	d0a02017 	ldw	r2,-32640(gp)
  
  if (alt_ticks_per_second ())
  105848:	10003c26 	beq	r2,zero,10593c <alt_alarm_start+0x118>
  {
    if (alarm)
  10584c:	e0bff917 	ldw	r2,-28(fp)
  105850:	10003826 	beq	r2,zero,105934 <alt_alarm_start+0x110>
    {
      alarm->callback = callback;
  105854:	e0bff917 	ldw	r2,-28(fp)
  105858:	e0fff717 	ldw	r3,-36(fp)
  10585c:	10c00315 	stw	r3,12(r2)
      alarm->context  = context;
  105860:	e0bff917 	ldw	r2,-28(fp)
  105864:	e0fff617 	ldw	r3,-40(fp)
  105868:	10c00515 	stw	r3,20(r2)
  NIOS2_READ_STATUS (context);
  10586c:	0005303a 	rdctl	r2,status
  105870:	e0bffd15 	stw	r2,-12(fp)
  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  105874:	e0fffd17 	ldw	r3,-12(fp)
  105878:	00bfff84 	movi	r2,-2
  10587c:	1884703a 	and	r2,r3,r2
  105880:	1001703a 	wrctl	status,r2
  return context;
  105884:	e0bffd17 	ldw	r2,-12(fp)
 
      irq_context = alt_irq_disable_all ();
  105888:	e0bffe15 	stw	r2,-8(fp)
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
  10588c:	d0a02117 	ldw	r2,-32636(gp)
      
      current_nticks = alt_nticks();
  105890:	e0bfff15 	stw	r2,-4(fp)
      
      alarm->time = nticks + current_nticks + 1; 
  105894:	e0fff817 	ldw	r3,-32(fp)
  105898:	e0bfff17 	ldw	r2,-4(fp)
  10589c:	1885883a 	add	r2,r3,r2
  1058a0:	10c00044 	addi	r3,r2,1
  1058a4:	e0bff917 	ldw	r2,-28(fp)
  1058a8:	10c00215 	stw	r3,8(r2)
      /* 
       * If the desired alarm time causes a roll-over, set the rollover
       * flag. This will prevent the subsequent tick event from causing
       * an alarm too early.
       */
      if(alarm->time < current_nticks)
  1058ac:	e0bff917 	ldw	r2,-28(fp)
  1058b0:	10c00217 	ldw	r3,8(r2)
  1058b4:	e0bfff17 	ldw	r2,-4(fp)
  1058b8:	1880042e 	bgeu	r3,r2,1058cc <alt_alarm_start+0xa8>
      {
        alarm->rollover = 1;
  1058bc:	e0bff917 	ldw	r2,-28(fp)
  1058c0:	00c00044 	movi	r3,1
  1058c4:	10c00405 	stb	r3,16(r2)
  1058c8:	00000206 	br	1058d4 <alt_alarm_start+0xb0>
      }
      else
      {
        alarm->rollover = 0;
  1058cc:	e0bff917 	ldw	r2,-28(fp)
  1058d0:	10000405 	stb	zero,16(r2)
      }
    
      alt_llist_insert (&alt_alarm_list, &alarm->llist);
  1058d4:	e0bff917 	ldw	r2,-28(fp)
  1058d8:	d0e00904 	addi	r3,gp,-32732
  1058dc:	e0fffb15 	stw	r3,-20(fp)
  1058e0:	e0bffa15 	stw	r2,-24(fp)
  entry->previous = list;
  1058e4:	e0bffa17 	ldw	r2,-24(fp)
  1058e8:	e0fffb17 	ldw	r3,-20(fp)
  1058ec:	10c00115 	stw	r3,4(r2)
  entry->next     = list->next;
  1058f0:	e0bffb17 	ldw	r2,-20(fp)
  1058f4:	10c00017 	ldw	r3,0(r2)
  1058f8:	e0bffa17 	ldw	r2,-24(fp)
  1058fc:	10c00015 	stw	r3,0(r2)
  list->next->previous = entry;
  105900:	e0bffb17 	ldw	r2,-20(fp)
  105904:	10800017 	ldw	r2,0(r2)
  105908:	e0fffa17 	ldw	r3,-24(fp)
  10590c:	10c00115 	stw	r3,4(r2)
  list->next           = entry;
  105910:	e0bffb17 	ldw	r2,-20(fp)
  105914:	e0fffa17 	ldw	r3,-24(fp)
  105918:	10c00015 	stw	r3,0(r2)
  10591c:	e0bffe17 	ldw	r2,-8(fp)
  105920:	e0bffc15 	stw	r2,-16(fp)
  NIOS2_WRITE_STATUS (context);
  105924:	e0bffc17 	ldw	r2,-16(fp)
  105928:	1001703a 	wrctl	status,r2
      alt_irq_enable_all (irq_context);

      return 0;
  10592c:	0005883a 	mov	r2,zero
  105930:	00000306 	br	105940 <alt_alarm_start+0x11c>
    }
    else
    {
      return -EINVAL;
  105934:	00bffa84 	movi	r2,-22
  105938:	00000106 	br	105940 <alt_alarm_start+0x11c>
    }
  }
  else
  {
    return -ENOTSUP;
  10593c:	00bfde84 	movi	r2,-134
  }
}
  105940:	e037883a 	mov	sp,fp
  105944:	df000017 	ldw	fp,0(sp)
  105948:	dec00104 	addi	sp,sp,4
  10594c:	f800283a 	ret

00105950 <alt_busy_sleep>:
#include "alt_types.h"

#include "priv/alt_busy_sleep.h"

unsigned int alt_busy_sleep (unsigned int us)
{
  105950:	defffa04 	addi	sp,sp,-24
  105954:	dfc00515 	stw	ra,20(sp)
  105958:	df000415 	stw	fp,16(sp)
  10595c:	df000404 	addi	fp,sp,16
  105960:	e13ffc15 	stw	r4,-16(fp)
  int big_loops;
  alt_u32 cycles_per_loop;
  
  if (!strcmp(NIOS2_CPU_IMPLEMENTATION,"tiny"))
  {
    cycles_per_loop = 9;
  105964:	00800244 	movi	r2,9
  105968:	e0bffe15 	stw	r2,-8(fp)
    cycles_per_loop = 3;
  }
  

  big_loops = us / (INT_MAX/
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));
  10596c:	014003f4 	movhi	r5,15
  105970:	29509004 	addi	r5,r5,16960
  105974:	e13ffe17 	ldw	r4,-8(fp)
  105978:	0102e940 	call	102e94 <__mulsi3>
  10597c:	100b883a 	mov	r5,r2
  105980:	0100bef4 	movhi	r4,763
  105984:	213c2004 	addi	r4,r4,-3968
  105988:	0102dd40 	call	102dd4 <__udivsi3>
  big_loops = us / (INT_MAX/
  10598c:	100b883a 	mov	r5,r2
  105990:	01200034 	movhi	r4,32768
  105994:	213fffc4 	addi	r4,r4,-1
  105998:	0102dd40 	call	102dd4 <__udivsi3>
  10599c:	100b883a 	mov	r5,r2
  1059a0:	e13ffc17 	ldw	r4,-16(fp)
  1059a4:	0102dd40 	call	102dd4 <__udivsi3>
  1059a8:	e0bffd15 	stw	r2,-12(fp)

  if (big_loops)
  1059ac:	e0bffd17 	ldw	r2,-12(fp)
  1059b0:	10002a26 	beq	r2,zero,105a5c <alt_busy_sleep+0x10c>
  {
    for(i=0;i<big_loops;i++)
  1059b4:	e03fff15 	stw	zero,-4(fp)
  1059b8:	00001706 	br	105a18 <alt_busy_sleep+0xc8>
      /*
      * Do NOT Try to single step the asm statement below 
      * (single step will never return)
      * Step out of this function or set a breakpoint after the asm statements
      */
      __asm__ volatile (
  1059bc:	00a00034 	movhi	r2,32768
  1059c0:	10bfffc4 	addi	r2,r2,-1
  1059c4:	10bfffc4 	addi	r2,r2,-1
  1059c8:	103ffe1e 	bne	r2,zero,1059c4 <alt_busy_sleep+0x74>
        "\n\t.pushsection .debug_alt_sim_info"
        "\n\t.int 4, 0, 0b, 1b"
        "\n\t.popsection"
        :: "r" (INT_MAX));
      us -= (INT_MAX/(ALT_CPU_FREQ/
      (cycles_per_loop * 1000000)));
  1059cc:	014003f4 	movhi	r5,15
  1059d0:	29509004 	addi	r5,r5,16960
  1059d4:	e13ffe17 	ldw	r4,-8(fp)
  1059d8:	0102e940 	call	102e94 <__mulsi3>
      us -= (INT_MAX/(ALT_CPU_FREQ/
  1059dc:	100b883a 	mov	r5,r2
  1059e0:	0100bef4 	movhi	r4,763
  1059e4:	213c2004 	addi	r4,r4,-3968
  1059e8:	0102dd40 	call	102dd4 <__udivsi3>
  1059ec:	100b883a 	mov	r5,r2
  1059f0:	01200034 	movhi	r4,32768
  1059f4:	213fffc4 	addi	r4,r4,-1
  1059f8:	0102dd40 	call	102dd4 <__udivsi3>
  1059fc:	1007883a 	mov	r3,r2
  105a00:	e0bffc17 	ldw	r2,-16(fp)
  105a04:	10c5c83a 	sub	r2,r2,r3
  105a08:	e0bffc15 	stw	r2,-16(fp)
    for(i=0;i<big_loops;i++)
  105a0c:	e0bfff17 	ldw	r2,-4(fp)
  105a10:	10800044 	addi	r2,r2,1
  105a14:	e0bfff15 	stw	r2,-4(fp)
  105a18:	e0ffff17 	ldw	r3,-4(fp)
  105a1c:	e0bffd17 	ldw	r2,-12(fp)
  105a20:	18bfe616 	blt	r3,r2,1059bc <alt_busy_sleep+0x6c>
      "\n\tbne %0,zero,0b"
      "\n1:"
      "\n\t.pushsection .debug_alt_sim_info"
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
  105a24:	014003f4 	movhi	r5,15
  105a28:	29509004 	addi	r5,r5,16960
  105a2c:	e13ffe17 	ldw	r4,-8(fp)
  105a30:	0102e940 	call	102e94 <__mulsi3>
  105a34:	100b883a 	mov	r5,r2
  105a38:	0100bef4 	movhi	r4,763
  105a3c:	213c2004 	addi	r4,r4,-3968
  105a40:	0102dd40 	call	102dd4 <__udivsi3>
  105a44:	e17ffc17 	ldw	r5,-16(fp)
  105a48:	1009883a 	mov	r4,r2
  105a4c:	0102e940 	call	102e94 <__mulsi3>
    __asm__ volatile (
  105a50:	10bfffc4 	addi	r2,r2,-1
  105a54:	103ffe1e 	bne	r2,zero,105a50 <alt_busy_sleep+0x100>
  105a58:	00000d06 	br	105a90 <alt_busy_sleep+0x140>
      "\n\tbgt %0,zero,0b"
      "\n1:"
      "\n\t.pushsection .debug_alt_sim_info"
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
  105a5c:	014003f4 	movhi	r5,15
  105a60:	29509004 	addi	r5,r5,16960
  105a64:	e13ffe17 	ldw	r4,-8(fp)
  105a68:	0102e940 	call	102e94 <__mulsi3>
  105a6c:	100b883a 	mov	r5,r2
  105a70:	0100bef4 	movhi	r4,763
  105a74:	213c2004 	addi	r4,r4,-3968
  105a78:	0102dd40 	call	102dd4 <__udivsi3>
  105a7c:	e17ffc17 	ldw	r5,-16(fp)
  105a80:	1009883a 	mov	r4,r2
  105a84:	0102e940 	call	102e94 <__mulsi3>
    __asm__ volatile (
  105a88:	10bfffc4 	addi	r2,r2,-1
  105a8c:	00bffe16 	blt	zero,r2,105a88 <alt_busy_sleep+0x138>
  }
#endif /* #ifndef ALT_SIM_OPTIMIZE */
  return 0;
  105a90:	0005883a 	mov	r2,zero
}
  105a94:	e037883a 	mov	sp,fp
  105a98:	dfc00117 	ldw	ra,4(sp)
  105a9c:	df000017 	ldw	fp,0(sp)
  105aa0:	dec00204 	addi	sp,sp,8
  105aa4:	f800283a 	ret

00105aa8 <alt_get_errno>:
{
  105aa8:	defffe04 	addi	sp,sp,-8
  105aac:	dfc00115 	stw	ra,4(sp)
  105ab0:	df000015 	stw	fp,0(sp)
  105ab4:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
  105ab8:	d0a01217 	ldw	r2,-32696(gp)
  105abc:	10000326 	beq	r2,zero,105acc <alt_get_errno+0x24>
  105ac0:	d0a01217 	ldw	r2,-32696(gp)
  105ac4:	103ee83a 	callr	r2
  105ac8:	00000106 	br	105ad0 <alt_get_errno+0x28>
  105acc:	d0a01c04 	addi	r2,gp,-32656
}
  105ad0:	e037883a 	mov	sp,fp
  105ad4:	dfc00117 	ldw	ra,4(sp)
  105ad8:	df000017 	ldw	fp,0(sp)
  105adc:	dec00204 	addi	sp,sp,8
  105ae0:	f800283a 	ret

00105ae4 <close>:
 *
 * ALT_CLOSE is mapped onto the close() system call in alt_syscall.h
 */
 
int ALT_CLOSE (int fildes)
{
  105ae4:	defffb04 	addi	sp,sp,-20
  105ae8:	dfc00415 	stw	ra,16(sp)
  105aec:	df000315 	stw	fp,12(sp)
  105af0:	df000304 	addi	fp,sp,12
  105af4:	e13ffd15 	stw	r4,-12(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (fildes < 0) ? NULL : &alt_fd_list[fildes];
  105af8:	e0bffd17 	ldw	r2,-12(fp)
  105afc:	10000916 	blt	r2,zero,105b24 <close+0x40>
  105b00:	e0fffd17 	ldw	r3,-12(fp)
  105b04:	1805883a 	mov	r2,r3
  105b08:	1085883a 	add	r2,r2,r2
  105b0c:	10c5883a 	add	r2,r2,r3
  105b10:	100490ba 	slli	r2,r2,2
  105b14:	00c00074 	movhi	r3,1
  105b18:	18c4a704 	addi	r3,r3,4764
  105b1c:	10c5883a 	add	r2,r2,r3
  105b20:	00000106 	br	105b28 <close+0x44>
  105b24:	0005883a 	mov	r2,zero
  105b28:	e0bfff15 	stw	r2,-4(fp)

  if (fd)
  105b2c:	e0bfff17 	ldw	r2,-4(fp)
  105b30:	10001926 	beq	r2,zero,105b98 <close+0xb4>
    /*
     * If the associated file system/device has a close function, call it so 
     * that any necessary cleanup code can run.
     */

    rval = (fd->dev->close) ? fd->dev->close(fd) : 0;
  105b34:	e0bfff17 	ldw	r2,-4(fp)
  105b38:	10800017 	ldw	r2,0(r2)
  105b3c:	10800417 	ldw	r2,16(r2)
  105b40:	10000626 	beq	r2,zero,105b5c <close+0x78>
  105b44:	e0bfff17 	ldw	r2,-4(fp)
  105b48:	10800017 	ldw	r2,0(r2)
  105b4c:	10800417 	ldw	r2,16(r2)
  105b50:	e13fff17 	ldw	r4,-4(fp)
  105b54:	103ee83a 	callr	r2
  105b58:	00000106 	br	105b60 <close+0x7c>
  105b5c:	0005883a 	mov	r2,zero
  105b60:	e0bffe15 	stw	r2,-8(fp)

    /* Free the file descriptor structure and return. */

    alt_release_fd (fildes);
  105b64:	e13ffd17 	ldw	r4,-12(fp)
  105b68:	010640c0 	call	10640c <alt_release_fd>
    if (rval < 0)
  105b6c:	e0bffe17 	ldw	r2,-8(fp)
  105b70:	1000070e 	bge	r2,zero,105b90 <close+0xac>
    {
      ALT_ERRNO = -rval;
  105b74:	0105aa80 	call	105aa8 <alt_get_errno>
  105b78:	1007883a 	mov	r3,r2
  105b7c:	e0bffe17 	ldw	r2,-8(fp)
  105b80:	0085c83a 	sub	r2,zero,r2
  105b84:	18800015 	stw	r2,0(r3)
      return -1;
  105b88:	00bfffc4 	movi	r2,-1
  105b8c:	00000706 	br	105bac <close+0xc8>
    }
    return 0;
  105b90:	0005883a 	mov	r2,zero
  105b94:	00000506 	br	105bac <close+0xc8>
  }
  else
  {
    ALT_ERRNO = EBADFD;
  105b98:	0105aa80 	call	105aa8 <alt_get_errno>
  105b9c:	1007883a 	mov	r3,r2
  105ba0:	00801444 	movi	r2,81
  105ba4:	18800015 	stw	r2,0(r3)
    return -1;
  105ba8:	00bfffc4 	movi	r2,-1
  }
}
  105bac:	e037883a 	mov	sp,fp
  105bb0:	dfc00117 	ldw	ra,4(sp)
  105bb4:	df000017 	ldw	fp,0(sp)
  105bb8:	dec00204 	addi	sp,sp,8
  105bbc:	f800283a 	ret

00105bc0 <alt_dcache_flush>:
 *
 * Any dirty lines in the data cache are written back to memory.
 */

void alt_dcache_flush (void* start, alt_u32 len)
{
  105bc0:	defffd04 	addi	sp,sp,-12
  105bc4:	df000215 	stw	fp,8(sp)
  105bc8:	df000204 	addi	fp,sp,8
  105bcc:	e13fff15 	stw	r4,-4(fp)
  105bd0:	e17ffe15 	stw	r5,-8(fp)
  {
    ALT_FLUSH_DATA(i);
  }

#endif /* NIOS2_DCACHE_SIZE > 0 */
}
  105bd4:	0001883a 	nop
  105bd8:	e037883a 	mov	sp,fp
  105bdc:	df000017 	ldw	fp,0(sp)
  105be0:	dec00104 	addi	sp,sp,4
  105be4:	f800283a 	ret

00105be8 <alt_dev_null_write>:
 * by the alt_dev_null device. It simple discards all data passed to it, and
 * indicates that the data has been successfully transmitted.
 */

static int alt_dev_null_write (alt_fd* fd, const char* ptr, int len)
{
  105be8:	defffc04 	addi	sp,sp,-16
  105bec:	df000315 	stw	fp,12(sp)
  105bf0:	df000304 	addi	fp,sp,12
  105bf4:	e13fff15 	stw	r4,-4(fp)
  105bf8:	e17ffe15 	stw	r5,-8(fp)
  105bfc:	e1bffd15 	stw	r6,-12(fp)
  return len;
  105c00:	e0bffd17 	ldw	r2,-12(fp)
}
  105c04:	e037883a 	mov	sp,fp
  105c08:	df000017 	ldw	fp,0(sp)
  105c0c:	dec00104 	addi	sp,sp,4
  105c10:	f800283a 	ret

00105c14 <alt_get_errno>:
{
  105c14:	defffe04 	addi	sp,sp,-8
  105c18:	dfc00115 	stw	ra,4(sp)
  105c1c:	df000015 	stw	fp,0(sp)
  105c20:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
  105c24:	d0a01217 	ldw	r2,-32696(gp)
  105c28:	10000326 	beq	r2,zero,105c38 <alt_get_errno+0x24>
  105c2c:	d0a01217 	ldw	r2,-32696(gp)
  105c30:	103ee83a 	callr	r2
  105c34:	00000106 	br	105c3c <alt_get_errno+0x28>
  105c38:	d0a01c04 	addi	r2,gp,-32656
}
  105c3c:	e037883a 	mov	sp,fp
  105c40:	dfc00117 	ldw	ra,4(sp)
  105c44:	df000017 	ldw	fp,0(sp)
  105c48:	dec00204 	addi	sp,sp,8
  105c4c:	f800283a 	ret

00105c50 <alt_dev_llist_insert>:
/*
 *
 */

int alt_dev_llist_insert (alt_dev_llist* dev, alt_llist* list)
{
  105c50:	defffa04 	addi	sp,sp,-24
  105c54:	dfc00515 	stw	ra,20(sp)
  105c58:	df000415 	stw	fp,16(sp)
  105c5c:	df000404 	addi	fp,sp,16
  105c60:	e13ffd15 	stw	r4,-12(fp)
  105c64:	e17ffc15 	stw	r5,-16(fp)
  /*
   * check that the device exists, and that it has a valid name.
   */

  if (!dev || !dev->name)
  105c68:	e0bffd17 	ldw	r2,-12(fp)
  105c6c:	10000326 	beq	r2,zero,105c7c <alt_dev_llist_insert+0x2c>
  105c70:	e0bffd17 	ldw	r2,-12(fp)
  105c74:	10800217 	ldw	r2,8(r2)
  105c78:	1000061e 	bne	r2,zero,105c94 <alt_dev_llist_insert+0x44>
  {
    ALT_ERRNO = EINVAL;
  105c7c:	0105c140 	call	105c14 <alt_get_errno>
  105c80:	1007883a 	mov	r3,r2
  105c84:	00800584 	movi	r2,22
  105c88:	18800015 	stw	r2,0(r3)
    return -EINVAL;
  105c8c:	00bffa84 	movi	r2,-22
  105c90:	00001306 	br	105ce0 <alt_dev_llist_insert+0x90>
  
  /*
   * register the device.
   */
  
  alt_llist_insert(list, &dev->llist);
  105c94:	e0bffd17 	ldw	r2,-12(fp)
  105c98:	e0fffc17 	ldw	r3,-16(fp)
  105c9c:	e0ffff15 	stw	r3,-4(fp)
  105ca0:	e0bffe15 	stw	r2,-8(fp)
  entry->previous = list;
  105ca4:	e0bffe17 	ldw	r2,-8(fp)
  105ca8:	e0ffff17 	ldw	r3,-4(fp)
  105cac:	10c00115 	stw	r3,4(r2)
  entry->next     = list->next;
  105cb0:	e0bfff17 	ldw	r2,-4(fp)
  105cb4:	10c00017 	ldw	r3,0(r2)
  105cb8:	e0bffe17 	ldw	r2,-8(fp)
  105cbc:	10c00015 	stw	r3,0(r2)
  list->next->previous = entry;
  105cc0:	e0bfff17 	ldw	r2,-4(fp)
  105cc4:	10800017 	ldw	r2,0(r2)
  105cc8:	e0fffe17 	ldw	r3,-8(fp)
  105ccc:	10c00115 	stw	r3,4(r2)
  list->next           = entry;
  105cd0:	e0bfff17 	ldw	r2,-4(fp)
  105cd4:	e0fffe17 	ldw	r3,-8(fp)
  105cd8:	10c00015 	stw	r3,0(r2)

  return 0;  
  105cdc:	0005883a 	mov	r2,zero
}
  105ce0:	e037883a 	mov	sp,fp
  105ce4:	dfc00117 	ldw	ra,4(sp)
  105ce8:	df000017 	ldw	fp,0(sp)
  105cec:	dec00204 	addi	sp,sp,8
  105cf0:	f800283a 	ret

00105cf4 <alt_flash_open_dev>:
#include "priv/alt_file.h"

ALT_LLIST_HEAD(alt_flash_dev_list);

alt_flash_fd* alt_flash_open_dev(const char* name)
{
  105cf4:	defffc04 	addi	sp,sp,-16
  105cf8:	dfc00315 	stw	ra,12(sp)
  105cfc:	df000215 	stw	fp,8(sp)
  105d00:	df000204 	addi	fp,sp,8
  105d04:	e13ffe15 	stw	r4,-8(fp)
  alt_flash_dev* dev = (alt_flash_dev*)alt_find_dev(name, &alt_flash_dev_list);
  105d08:	d1601304 	addi	r5,gp,-32692
  105d0c:	e13ffe17 	ldw	r4,-8(fp)
  105d10:	01064a00 	call	1064a0 <alt_find_dev>
  105d14:	e0bfff15 	stw	r2,-4(fp)

  if ((dev) && dev->open)
  105d18:	e0bfff17 	ldw	r2,-4(fp)
  105d1c:	10000926 	beq	r2,zero,105d44 <alt_flash_open_dev+0x50>
  105d20:	e0bfff17 	ldw	r2,-4(fp)
  105d24:	10800317 	ldw	r2,12(r2)
  105d28:	10000626 	beq	r2,zero,105d44 <alt_flash_open_dev+0x50>
  {
    return dev->open(dev, name);
  105d2c:	e0bfff17 	ldw	r2,-4(fp)
  105d30:	10800317 	ldw	r2,12(r2)
  105d34:	e17ffe17 	ldw	r5,-8(fp)
  105d38:	e13fff17 	ldw	r4,-4(fp)
  105d3c:	103ee83a 	callr	r2
  105d40:	00000106 	br	105d48 <alt_flash_open_dev+0x54>
  }

  return dev;
  105d44:	e0bfff17 	ldw	r2,-4(fp)
}
  105d48:	e037883a 	mov	sp,fp
  105d4c:	dfc00117 	ldw	ra,4(sp)
  105d50:	df000017 	ldw	fp,0(sp)
  105d54:	dec00204 	addi	sp,sp,8
  105d58:	f800283a 	ret

00105d5c <alt_flash_close_dev>:

void alt_flash_close_dev(alt_flash_fd* fd)
{
  105d5c:	defffd04 	addi	sp,sp,-12
  105d60:	dfc00215 	stw	ra,8(sp)
  105d64:	df000115 	stw	fp,4(sp)
  105d68:	df000104 	addi	fp,sp,4
  105d6c:	e13fff15 	stw	r4,-4(fp)
  if (fd && fd->close)
  105d70:	e0bfff17 	ldw	r2,-4(fp)
  105d74:	10000826 	beq	r2,zero,105d98 <alt_flash_close_dev+0x3c>
  105d78:	e0bfff17 	ldw	r2,-4(fp)
  105d7c:	10800417 	ldw	r2,16(r2)
  105d80:	10000526 	beq	r2,zero,105d98 <alt_flash_close_dev+0x3c>
  {
    fd->close(fd);
  105d84:	e0bfff17 	ldw	r2,-4(fp)
  105d88:	10800417 	ldw	r2,16(r2)
  105d8c:	e13fff17 	ldw	r4,-4(fp)
  105d90:	103ee83a 	callr	r2
  }
  return;
  105d94:	0001883a 	nop
  105d98:	0001883a 	nop
}
  105d9c:	e037883a 	mov	sp,fp
  105da0:	dfc00117 	ldw	ra,4(sp)
  105da4:	df000017 	ldw	fp,0(sp)
  105da8:	dec00204 	addi	sp,sp,8
  105dac:	f800283a 	ret

00105db0 <alt_ic_isr_register>:
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
  105db0:	defff904 	addi	sp,sp,-28
  105db4:	dfc00615 	stw	ra,24(sp)
  105db8:	df000515 	stw	fp,20(sp)
  105dbc:	df000504 	addi	fp,sp,20
  105dc0:	e13fff15 	stw	r4,-4(fp)
  105dc4:	e17ffe15 	stw	r5,-8(fp)
  105dc8:	e1bffd15 	stw	r6,-12(fp)
  105dcc:	e1fffc15 	stw	r7,-16(fp)
    return alt_iic_isr_register(ic_id, irq, isr, isr_context, flags);
  105dd0:	e0800217 	ldw	r2,8(fp)
  105dd4:	d8800015 	stw	r2,0(sp)
  105dd8:	e1fffc17 	ldw	r7,-16(fp)
  105ddc:	e1bffd17 	ldw	r6,-12(fp)
  105de0:	e17ffe17 	ldw	r5,-8(fp)
  105de4:	e13fff17 	ldw	r4,-4(fp)
  105de8:	0105f600 	call	105f60 <alt_iic_isr_register>
}  
  105dec:	e037883a 	mov	sp,fp
  105df0:	dfc00117 	ldw	ra,4(sp)
  105df4:	df000017 	ldw	fp,0(sp)
  105df8:	dec00204 	addi	sp,sp,8
  105dfc:	f800283a 	ret

00105e00 <alt_ic_irq_enable>:
  * @param ic_id            Ignored.
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_enable (alt_u32 ic_id, alt_u32 irq)
{
  105e00:	defff904 	addi	sp,sp,-28
  105e04:	df000615 	stw	fp,24(sp)
  105e08:	df000604 	addi	fp,sp,24
  105e0c:	e13ffb15 	stw	r4,-20(fp)
  105e10:	e17ffa15 	stw	r5,-24(fp)
  105e14:	e0bffa17 	ldw	r2,-24(fp)
  105e18:	e0bfff15 	stw	r2,-4(fp)
  NIOS2_READ_STATUS (context);
  105e1c:	0005303a 	rdctl	r2,status
  105e20:	e0bffe15 	stw	r2,-8(fp)
  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  105e24:	e0fffe17 	ldw	r3,-8(fp)
  105e28:	00bfff84 	movi	r2,-2
  105e2c:	1884703a 	and	r2,r3,r2
  105e30:	1001703a 	wrctl	status,r2
  return context;
  105e34:	e0bffe17 	ldw	r2,-8(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_enable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
  105e38:	e0bffd15 	stw	r2,-12(fp)

  alt_irq_active |= (1 << id);
  105e3c:	00c00044 	movi	r3,1
  105e40:	e0bfff17 	ldw	r2,-4(fp)
  105e44:	1884983a 	sll	r2,r3,r2
  105e48:	1007883a 	mov	r3,r2
  105e4c:	d0a02217 	ldw	r2,-32632(gp)
  105e50:	1884b03a 	or	r2,r3,r2
  105e54:	d0a02215 	stw	r2,-32632(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
  105e58:	d0a02217 	ldw	r2,-32632(gp)
  105e5c:	100170fa 	wrctl	ienable,r2
  105e60:	e0bffd17 	ldw	r2,-12(fp)
  105e64:	e0bffc15 	stw	r2,-16(fp)
  NIOS2_WRITE_STATUS (context);
  105e68:	e0bffc17 	ldw	r2,-16(fp)
  105e6c:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
  105e70:	0005883a 	mov	r2,zero
    return alt_irq_enable(irq);
  105e74:	0001883a 	nop
}
  105e78:	e037883a 	mov	sp,fp
  105e7c:	df000017 	ldw	fp,0(sp)
  105e80:	dec00104 	addi	sp,sp,4
  105e84:	f800283a 	ret

00105e88 <alt_ic_irq_disable>:
  * @param ic_id            Ignored.
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_disable(alt_u32 ic_id, alt_u32 irq)
{
  105e88:	defff904 	addi	sp,sp,-28
  105e8c:	df000615 	stw	fp,24(sp)
  105e90:	df000604 	addi	fp,sp,24
  105e94:	e13ffb15 	stw	r4,-20(fp)
  105e98:	e17ffa15 	stw	r5,-24(fp)
  105e9c:	e0bffa17 	ldw	r2,-24(fp)
  105ea0:	e0bfff15 	stw	r2,-4(fp)
  NIOS2_READ_STATUS (context);
  105ea4:	0005303a 	rdctl	r2,status
  105ea8:	e0bffe15 	stw	r2,-8(fp)
  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  105eac:	e0fffe17 	ldw	r3,-8(fp)
  105eb0:	00bfff84 	movi	r2,-2
  105eb4:	1884703a 	and	r2,r3,r2
  105eb8:	1001703a 	wrctl	status,r2
  return context;
  105ebc:	e0bffe17 	ldw	r2,-8(fp)
  status = alt_irq_disable_all ();
  105ec0:	e0bffd15 	stw	r2,-12(fp)
  alt_irq_active &= ~(1 << id);
  105ec4:	00c00044 	movi	r3,1
  105ec8:	e0bfff17 	ldw	r2,-4(fp)
  105ecc:	1884983a 	sll	r2,r3,r2
  105ed0:	0084303a 	nor	r2,zero,r2
  105ed4:	1007883a 	mov	r3,r2
  105ed8:	d0a02217 	ldw	r2,-32632(gp)
  105edc:	1884703a 	and	r2,r3,r2
  105ee0:	d0a02215 	stw	r2,-32632(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
  105ee4:	d0a02217 	ldw	r2,-32632(gp)
  105ee8:	100170fa 	wrctl	ienable,r2
  105eec:	e0bffd17 	ldw	r2,-12(fp)
  105ef0:	e0bffc15 	stw	r2,-16(fp)
  NIOS2_WRITE_STATUS (context);
  105ef4:	e0bffc17 	ldw	r2,-16(fp)
  105ef8:	1001703a 	wrctl	status,r2
  return 0;
  105efc:	0005883a 	mov	r2,zero
    return alt_irq_disable(irq);
  105f00:	0001883a 	nop
}
  105f04:	e037883a 	mov	sp,fp
  105f08:	df000017 	ldw	fp,0(sp)
  105f0c:	dec00104 	addi	sp,sp,4
  105f10:	f800283a 	ret

00105f14 <alt_ic_irq_enabled>:
  * @param irq              IRQ number
  * @return                 Zero if corresponding interrupt is disabled and
  *                         non-zero otherwise.
  */
alt_u32 alt_ic_irq_enabled(alt_u32 ic_id, alt_u32 irq)
{
  105f14:	defffc04 	addi	sp,sp,-16
  105f18:	df000315 	stw	fp,12(sp)
  105f1c:	df000304 	addi	fp,sp,12
  105f20:	e13ffe15 	stw	r4,-8(fp)
  105f24:	e17ffd15 	stw	r5,-12(fp)
    alt_u32 irq_enabled;

    NIOS2_READ_IENABLE(irq_enabled);
  105f28:	000530fa 	rdctl	r2,ienable
  105f2c:	e0bfff15 	stw	r2,-4(fp)

    return (irq_enabled & (1 << irq)) ? 1: 0;
  105f30:	00c00044 	movi	r3,1
  105f34:	e0bffd17 	ldw	r2,-12(fp)
  105f38:	1884983a 	sll	r2,r3,r2
  105f3c:	1007883a 	mov	r3,r2
  105f40:	e0bfff17 	ldw	r2,-4(fp)
  105f44:	1884703a 	and	r2,r3,r2
  105f48:	1004c03a 	cmpne	r2,r2,zero
  105f4c:	10803fcc 	andi	r2,r2,255
}
  105f50:	e037883a 	mov	sp,fp
  105f54:	df000017 	ldw	fp,0(sp)
  105f58:	dec00104 	addi	sp,sp,4
  105f5c:	f800283a 	ret

00105f60 <alt_iic_isr_register>:
  * @param flags            
  * @return                 0 if successful, else error (-1)
  */
int alt_iic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
  105f60:	defff504 	addi	sp,sp,-44
  105f64:	dfc00a15 	stw	ra,40(sp)
  105f68:	df000915 	stw	fp,36(sp)
  105f6c:	df000904 	addi	fp,sp,36
  105f70:	e13ffa15 	stw	r4,-24(fp)
  105f74:	e17ff915 	stw	r5,-28(fp)
  105f78:	e1bff815 	stw	r6,-32(fp)
  105f7c:	e1fff715 	stw	r7,-36(fp)
  int rc = -EINVAL;  
  105f80:	00bffa84 	movi	r2,-22
  105f84:	e0bfff15 	stw	r2,-4(fp)
  int id = irq;             /* IRQ interpreted as the interrupt ID. */
  105f88:	e0bff917 	ldw	r2,-28(fp)
  105f8c:	e0bffe15 	stw	r2,-8(fp)
  alt_irq_context status;

  if (id < ALT_NIRQ)
  105f90:	e0bffe17 	ldw	r2,-8(fp)
  105f94:	10800808 	cmpgei	r2,r2,32
  105f98:	1000241e 	bne	r2,zero,10602c <alt_iic_isr_register+0xcc>
  NIOS2_READ_STATUS (context);
  105f9c:	0005303a 	rdctl	r2,status
  105fa0:	e0bffc15 	stw	r2,-16(fp)
  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  105fa4:	e0fffc17 	ldw	r3,-16(fp)
  105fa8:	00bfff84 	movi	r2,-2
  105fac:	1884703a 	and	r2,r3,r2
  105fb0:	1001703a 	wrctl	status,r2
  return context;
  105fb4:	e0bffc17 	ldw	r2,-16(fp)
     * interrupts are disabled while the handler tables are updated to ensure
     * that an interrupt doesn't occur while the tables are in an inconsistant
     * state.
     */

    status = alt_irq_disable_all();
  105fb8:	e0bffd15 	stw	r2,-12(fp)

    alt_irq[id].handler = isr;
  105fbc:	e0bffe17 	ldw	r2,-8(fp)
  105fc0:	100890fa 	slli	r4,r2,3
  105fc4:	e0fff817 	ldw	r3,-32(fp)
  105fc8:	00800074 	movhi	r2,1
  105fcc:	2085883a 	add	r2,r4,r2
  105fd0:	10c58715 	stw	r3,5660(r2)
    alt_irq[id].context = isr_context;
  105fd4:	e0bffe17 	ldw	r2,-8(fp)
  105fd8:	100890fa 	slli	r4,r2,3
  105fdc:	e0fff717 	ldw	r3,-36(fp)
  105fe0:	00800074 	movhi	r2,1
  105fe4:	2085883a 	add	r2,r4,r2
  105fe8:	10c58815 	stw	r3,5664(r2)

    rc = (isr) ? alt_ic_irq_enable(ic_id, id) : alt_ic_irq_disable(ic_id, id);
  105fec:	e0bff817 	ldw	r2,-32(fp)
  105ff0:	10000526 	beq	r2,zero,106008 <alt_iic_isr_register+0xa8>
  105ff4:	e0bffe17 	ldw	r2,-8(fp)
  105ff8:	100b883a 	mov	r5,r2
  105ffc:	e13ffa17 	ldw	r4,-24(fp)
  106000:	0105e000 	call	105e00 <alt_ic_irq_enable>
  106004:	00000406 	br	106018 <alt_iic_isr_register+0xb8>
  106008:	e0bffe17 	ldw	r2,-8(fp)
  10600c:	100b883a 	mov	r5,r2
  106010:	e13ffa17 	ldw	r4,-24(fp)
  106014:	0105e880 	call	105e88 <alt_ic_irq_disable>
  106018:	e0bfff15 	stw	r2,-4(fp)
  10601c:	e0bffd17 	ldw	r2,-12(fp)
  106020:	e0bffb15 	stw	r2,-20(fp)
  NIOS2_WRITE_STATUS (context);
  106024:	e0bffb17 	ldw	r2,-20(fp)
  106028:	1001703a 	wrctl	status,r2

    alt_irq_enable_all(status);
  }

  return rc; 
  10602c:	e0bfff17 	ldw	r2,-4(fp)
}
  106030:	e037883a 	mov	sp,fp
  106034:	dfc00117 	ldw	ra,4(sp)
  106038:	df000017 	ldw	fp,0(sp)
  10603c:	dec00204 	addi	sp,sp,8
  106040:	f800283a 	ret

00106044 <alt_open_fd>:
 * If the device can not be succesfully opened, then the input file descriptor
 * remains unchanged.
 */

static void alt_open_fd(alt_fd* fd, const char* name, int flags, int mode)
{
  106044:	defff904 	addi	sp,sp,-28
  106048:	dfc00615 	stw	ra,24(sp)
  10604c:	df000515 	stw	fp,20(sp)
  106050:	df000504 	addi	fp,sp,20
  106054:	e13ffe15 	stw	r4,-8(fp)
  106058:	e17ffd15 	stw	r5,-12(fp)
  10605c:	e1bffc15 	stw	r6,-16(fp)
  106060:	e1fffb15 	stw	r7,-20(fp)
  int old;

  old = open (name, flags, mode);
  106064:	e1bffb17 	ldw	r6,-20(fp)
  106068:	e17ffc17 	ldw	r5,-16(fp)
  10606c:	e13ffd17 	ldw	r4,-12(fp)
  106070:	01062ac0 	call	1062ac <open>
  106074:	e0bfff15 	stw	r2,-4(fp)

  if (old >= 0)
  106078:	e0bfff17 	ldw	r2,-4(fp)
  10607c:	10002016 	blt	r2,zero,106100 <alt_open_fd+0xbc>
  {
    fd->dev      = alt_fd_list[old].dev;
  106080:	e0ffff17 	ldw	r3,-4(fp)
  106084:	1805883a 	mov	r2,r3
  106088:	1085883a 	add	r2,r2,r2
  10608c:	10c5883a 	add	r2,r2,r3
  106090:	100490ba 	slli	r2,r2,2
  106094:	00c00074 	movhi	r3,1
  106098:	10c7883a 	add	r3,r2,r3
  10609c:	18c4a717 	ldw	r3,4764(r3)
  1060a0:	e0bffe17 	ldw	r2,-8(fp)
  1060a4:	10c00015 	stw	r3,0(r2)
    fd->priv     = alt_fd_list[old].priv;
  1060a8:	e0ffff17 	ldw	r3,-4(fp)
  1060ac:	1805883a 	mov	r2,r3
  1060b0:	1085883a 	add	r2,r2,r2
  1060b4:	10c5883a 	add	r2,r2,r3
  1060b8:	100490ba 	slli	r2,r2,2
  1060bc:	00c00074 	movhi	r3,1
  1060c0:	10c7883a 	add	r3,r2,r3
  1060c4:	18c4a817 	ldw	r3,4768(r3)
  1060c8:	e0bffe17 	ldw	r2,-8(fp)
  1060cc:	10c00115 	stw	r3,4(r2)
    fd->fd_flags = alt_fd_list[old].fd_flags;
  1060d0:	e0ffff17 	ldw	r3,-4(fp)
  1060d4:	1805883a 	mov	r2,r3
  1060d8:	1085883a 	add	r2,r2,r2
  1060dc:	10c5883a 	add	r2,r2,r3
  1060e0:	100490ba 	slli	r2,r2,2
  1060e4:	00c00074 	movhi	r3,1
  1060e8:	10c7883a 	add	r3,r2,r3
  1060ec:	18c4a917 	ldw	r3,4772(r3)
  1060f0:	e0bffe17 	ldw	r2,-8(fp)
  1060f4:	10c00215 	stw	r3,8(r2)

    alt_release_fd (old);
  1060f8:	e13fff17 	ldw	r4,-4(fp)
  1060fc:	010640c0 	call	10640c <alt_release_fd>
  }
} 
  106100:	0001883a 	nop
  106104:	e037883a 	mov	sp,fp
  106108:	dfc00117 	ldw	ra,4(sp)
  10610c:	df000017 	ldw	fp,0(sp)
  106110:	dec00204 	addi	sp,sp,8
  106114:	f800283a 	ret

00106118 <alt_io_redirect>:
 */
 
void alt_io_redirect(const char* stdout_dev, 
                     const char* stdin_dev, 
                     const char* stderr_dev)
{
  106118:	defffb04 	addi	sp,sp,-20
  10611c:	dfc00415 	stw	ra,16(sp)
  106120:	df000315 	stw	fp,12(sp)
  106124:	df000304 	addi	fp,sp,12
  106128:	e13fff15 	stw	r4,-4(fp)
  10612c:	e17ffe15 	stw	r5,-8(fp)
  106130:	e1bffd15 	stw	r6,-12(fp)
  /* Redirect the channels */

  alt_open_fd (&alt_fd_list[STDOUT_FILENO], stdout_dev, O_WRONLY, 0777);
  106134:	01c07fc4 	movi	r7,511
  106138:	01800044 	movi	r6,1
  10613c:	e17fff17 	ldw	r5,-4(fp)
  106140:	01000074 	movhi	r4,1
  106144:	2104aa04 	addi	r4,r4,4776
  106148:	01060440 	call	106044 <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDIN_FILENO], stdin_dev, O_RDONLY, 0777);
  10614c:	01c07fc4 	movi	r7,511
  106150:	000d883a 	mov	r6,zero
  106154:	e17ffe17 	ldw	r5,-8(fp)
  106158:	01000074 	movhi	r4,1
  10615c:	2104a704 	addi	r4,r4,4764
  106160:	01060440 	call	106044 <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDERR_FILENO], stderr_dev, O_WRONLY, 0777);
  106164:	01c07fc4 	movi	r7,511
  106168:	01800044 	movi	r6,1
  10616c:	e17ffd17 	ldw	r5,-12(fp)
  106170:	01000074 	movhi	r4,1
  106174:	2104ad04 	addi	r4,r4,4788
  106178:	01060440 	call	106044 <alt_open_fd>
}  
  10617c:	0001883a 	nop
  106180:	e037883a 	mov	sp,fp
  106184:	dfc00117 	ldw	ra,4(sp)
  106188:	df000017 	ldw	fp,0(sp)
  10618c:	dec00204 	addi	sp,sp,8
  106190:	f800283a 	ret

00106194 <alt_get_errno>:
{
  106194:	defffe04 	addi	sp,sp,-8
  106198:	dfc00115 	stw	ra,4(sp)
  10619c:	df000015 	stw	fp,0(sp)
  1061a0:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
  1061a4:	d0a01217 	ldw	r2,-32696(gp)
  1061a8:	10000326 	beq	r2,zero,1061b8 <alt_get_errno+0x24>
  1061ac:	d0a01217 	ldw	r2,-32696(gp)
  1061b0:	103ee83a 	callr	r2
  1061b4:	00000106 	br	1061bc <alt_get_errno+0x28>
  1061b8:	d0a01c04 	addi	r2,gp,-32656
}
  1061bc:	e037883a 	mov	sp,fp
  1061c0:	dfc00117 	ldw	ra,4(sp)
  1061c4:	df000017 	ldw	fp,0(sp)
  1061c8:	dec00204 	addi	sp,sp,8
  1061cc:	f800283a 	ret

001061d0 <alt_file_locked>:
 * performed for devices. Filesystems are required to handle the ioctl() call
 * themselves, and report the error from the filesystems open() function. 
 */ 

static int alt_file_locked (alt_fd* fd)
{
  1061d0:	defffd04 	addi	sp,sp,-12
  1061d4:	df000215 	stw	fp,8(sp)
  1061d8:	df000204 	addi	fp,sp,8
  1061dc:	e13ffe15 	stw	r4,-8(fp)

  /*
   * Mark the file descriptor as belonging to a device.
   */

  fd->fd_flags |= ALT_FD_DEV;
  1061e0:	e0bffe17 	ldw	r2,-8(fp)
  1061e4:	10800217 	ldw	r2,8(r2)
  1061e8:	10d00034 	orhi	r3,r2,16384
  1061ec:	e0bffe17 	ldw	r2,-8(fp)
  1061f0:	10c00215 	stw	r3,8(r2)
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
  1061f4:	e03fff15 	stw	zero,-4(fp)
  1061f8:	00002306 	br	106288 <alt_file_locked+0xb8>
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
  1061fc:	e0ffff17 	ldw	r3,-4(fp)
  106200:	1805883a 	mov	r2,r3
  106204:	1085883a 	add	r2,r2,r2
  106208:	10c5883a 	add	r2,r2,r3
  10620c:	100490ba 	slli	r2,r2,2
  106210:	00c00074 	movhi	r3,1
  106214:	10c7883a 	add	r3,r2,r3
  106218:	18c4a717 	ldw	r3,4764(r3)
  10621c:	e0bffe17 	ldw	r2,-8(fp)
  106220:	10800017 	ldw	r2,0(r2)
  106224:	1880151e 	bne	r3,r2,10627c <alt_file_locked+0xac>
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
  106228:	e0ffff17 	ldw	r3,-4(fp)
  10622c:	1805883a 	mov	r2,r3
  106230:	1085883a 	add	r2,r2,r2
  106234:	10c5883a 	add	r2,r2,r3
  106238:	100490ba 	slli	r2,r2,2
  10623c:	00c00074 	movhi	r3,1
  106240:	10c7883a 	add	r3,r2,r3
  106244:	1884a917 	ldw	r2,4772(r3)
    if ((alt_fd_list[i].dev == fd->dev) &&
  106248:	10000c0e 	bge	r2,zero,10627c <alt_file_locked+0xac>
        (&alt_fd_list[i] != fd))
  10624c:	e0ffff17 	ldw	r3,-4(fp)
  106250:	1805883a 	mov	r2,r3
  106254:	1085883a 	add	r2,r2,r2
  106258:	10c5883a 	add	r2,r2,r3
  10625c:	100490ba 	slli	r2,r2,2
  106260:	00c00074 	movhi	r3,1
  106264:	18c4a704 	addi	r3,r3,4764
  106268:	10c5883a 	add	r2,r2,r3
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
  10626c:	e0fffe17 	ldw	r3,-8(fp)
  106270:	18800226 	beq	r3,r2,10627c <alt_file_locked+0xac>
    {
      return -EACCES;
  106274:	00bffcc4 	movi	r2,-13
  106278:	00000806 	br	10629c <alt_file_locked+0xcc>
  for (i = 0; i <= alt_max_fd; i++)
  10627c:	e0bfff17 	ldw	r2,-4(fp)
  106280:	10800044 	addi	r2,r2,1
  106284:	e0bfff15 	stw	r2,-4(fp)
  106288:	d0a01117 	ldw	r2,-32700(gp)
  10628c:	1007883a 	mov	r3,r2
  106290:	e0bfff17 	ldw	r2,-4(fp)
  106294:	18bfd92e 	bgeu	r3,r2,1061fc <alt_file_locked+0x2c>
    }
  }
  
  /* The device is not locked */
 
  return 0;
  106298:	0005883a 	mov	r2,zero
}
  10629c:	e037883a 	mov	sp,fp
  1062a0:	df000017 	ldw	fp,0(sp)
  1062a4:	dec00104 	addi	sp,sp,4
  1062a8:	f800283a 	ret

001062ac <open>:
 *
 * ALT_OPEN is mapped onto the open() system call in alt_syscall.h
 */
 
int ALT_OPEN (const char* file, int flags, int mode)
{ 
  1062ac:	defff604 	addi	sp,sp,-40
  1062b0:	dfc00915 	stw	ra,36(sp)
  1062b4:	df000815 	stw	fp,32(sp)
  1062b8:	df000804 	addi	fp,sp,32
  1062bc:	e13ffa15 	stw	r4,-24(fp)
  1062c0:	e17ff915 	stw	r5,-28(fp)
  1062c4:	e1bff815 	stw	r6,-32(fp)
  alt_dev* dev;
  alt_fd*  fd;
  int index  = -1;
  1062c8:	00bfffc4 	movi	r2,-1
  1062cc:	e0bffe15 	stw	r2,-8(fp)
  int status = -ENODEV;
  1062d0:	00bffb44 	movi	r2,-19
  1062d4:	e0bffd15 	stw	r2,-12(fp)
  int isafs = 0;
  1062d8:	e03ffc15 	stw	zero,-16(fp)
  /* 
   * Check the device list, to see if a device with a matching name is 
   * registered.
   */
  
  if (!(dev = alt_find_dev (file, &alt_dev_list)))
  1062dc:	d1600f04 	addi	r5,gp,-32708
  1062e0:	e13ffa17 	ldw	r4,-24(fp)
  1062e4:	01064a00 	call	1064a0 <alt_find_dev>
  1062e8:	e0bfff15 	stw	r2,-4(fp)
  1062ec:	e0bfff17 	ldw	r2,-4(fp)
  1062f0:	1000051e 	bne	r2,zero,106308 <open+0x5c>
  {
    /* No matching device, so try the filesystem list */

    dev   = alt_find_file (file);
  1062f4:	e13ffa17 	ldw	r4,-24(fp)
  1062f8:	01065300 	call	106530 <alt_find_file>
  1062fc:	e0bfff15 	stw	r2,-4(fp)
    isafs = 1;
  106300:	00800044 	movi	r2,1
  106304:	e0bffc15 	stw	r2,-16(fp)

  /* 
   * If a matching device or filesystem is found, allocate a file descriptor. 
   */

  if (dev)
  106308:	e0bfff17 	ldw	r2,-4(fp)
  10630c:	10002c26 	beq	r2,zero,1063c0 <open+0x114>
  {
    if ((index = alt_get_fd (dev)) < 0)
  106310:	e13fff17 	ldw	r4,-4(fp)
  106314:	01066380 	call	106638 <alt_get_fd>
  106318:	e0bffe15 	stw	r2,-8(fp)
  10631c:	e0bffe17 	ldw	r2,-8(fp)
  106320:	1000030e 	bge	r2,zero,106330 <open+0x84>
    {
      status = index;
  106324:	e0bffe17 	ldw	r2,-8(fp)
  106328:	e0bffd15 	stw	r2,-12(fp)
  10632c:	00002606 	br	1063c8 <open+0x11c>
    }
    else
    {
      fd = &alt_fd_list[index];
  106330:	e0fffe17 	ldw	r3,-8(fp)
  106334:	1805883a 	mov	r2,r3
  106338:	1085883a 	add	r2,r2,r2
  10633c:	10c5883a 	add	r2,r2,r3
  106340:	100490ba 	slli	r2,r2,2
  106344:	00c00074 	movhi	r3,1
  106348:	18c4a704 	addi	r3,r3,4764
  10634c:	10c5883a 	add	r2,r2,r3
  106350:	e0bffb15 	stw	r2,-20(fp)
      fd->fd_flags = (flags & ~ALT_FD_FLAGS_MASK);
  106354:	e0fff917 	ldw	r3,-28(fp)
  106358:	00900034 	movhi	r2,16384
  10635c:	10bfffc4 	addi	r2,r2,-1
  106360:	1886703a 	and	r3,r3,r2
  106364:	e0bffb17 	ldw	r2,-20(fp)
  106368:	10c00215 	stw	r3,8(r2)
      
      /* If this is a device, ensure it isn't already locked */

      if (isafs || ((status = alt_file_locked (fd)) >= 0))
  10636c:	e0bffc17 	ldw	r2,-16(fp)
  106370:	1000051e 	bne	r2,zero,106388 <open+0xdc>
  106374:	e13ffb17 	ldw	r4,-20(fp)
  106378:	01061d00 	call	1061d0 <alt_file_locked>
  10637c:	e0bffd15 	stw	r2,-12(fp)
  106380:	e0bffd17 	ldw	r2,-12(fp)
  106384:	10001016 	blt	r2,zero,1063c8 <open+0x11c>
        /* 
         * If the device or filesystem provides an open() callback function,
         * call it now to perform any device/filesystem specific operations.
         */
    
        status = (dev->open) ? dev->open(fd, file, flags, mode): 0;
  106388:	e0bfff17 	ldw	r2,-4(fp)
  10638c:	10800317 	ldw	r2,12(r2)
  106390:	10000826 	beq	r2,zero,1063b4 <open+0x108>
  106394:	e0bfff17 	ldw	r2,-4(fp)
  106398:	10800317 	ldw	r2,12(r2)
  10639c:	e1fff817 	ldw	r7,-32(fp)
  1063a0:	e1bff917 	ldw	r6,-28(fp)
  1063a4:	e17ffa17 	ldw	r5,-24(fp)
  1063a8:	e13ffb17 	ldw	r4,-20(fp)
  1063ac:	103ee83a 	callr	r2
  1063b0:	00000106 	br	1063b8 <open+0x10c>
  1063b4:	0005883a 	mov	r2,zero
  1063b8:	e0bffd15 	stw	r2,-12(fp)
  1063bc:	00000206 	br	1063c8 <open+0x11c>
      }
    }
  }
  else
  {
    status = -ENODEV;
  1063c0:	00bffb44 	movi	r2,-19
  1063c4:	e0bffd15 	stw	r2,-12(fp)
  }

  /* Allocation failed, so clean up and return an error */ 

  if (status < 0)
  1063c8:	e0bffd17 	ldw	r2,-12(fp)
  1063cc:	1000090e 	bge	r2,zero,1063f4 <open+0x148>
  {
    alt_release_fd (index);  
  1063d0:	e13ffe17 	ldw	r4,-8(fp)
  1063d4:	010640c0 	call	10640c <alt_release_fd>
    ALT_ERRNO = -status;
  1063d8:	01061940 	call	106194 <alt_get_errno>
  1063dc:	1007883a 	mov	r3,r2
  1063e0:	e0bffd17 	ldw	r2,-12(fp)
  1063e4:	0085c83a 	sub	r2,zero,r2
  1063e8:	18800015 	stw	r2,0(r3)
    return -1;
  1063ec:	00bfffc4 	movi	r2,-1
  1063f0:	00000106 	br	1063f8 <open+0x14c>
  }
  
  /* return the reference upon success */

  return index;
  1063f4:	e0bffe17 	ldw	r2,-8(fp)
}
  1063f8:	e037883a 	mov	sp,fp
  1063fc:	dfc00117 	ldw	ra,4(sp)
  106400:	df000017 	ldw	fp,0(sp)
  106404:	dec00204 	addi	sp,sp,8
  106408:	f800283a 	ret

0010640c <alt_release_fd>:
 * File descriptors correcponding to standard in, standard out and standard 
 * error cannont be released backed to the pool. They are always reserved.
 */

void alt_release_fd (int fd)
{
  10640c:	defffe04 	addi	sp,sp,-8
  106410:	df000115 	stw	fp,4(sp)
  106414:	df000104 	addi	fp,sp,4
  106418:	e13fff15 	stw	r4,-4(fp)
  if (fd > 2)
  10641c:	e0bfff17 	ldw	r2,-4(fp)
  106420:	108000d0 	cmplti	r2,r2,3
  106424:	1000101e 	bne	r2,zero,106468 <alt_release_fd+0x5c>
  {
    alt_fd_list[fd].fd_flags = 0;
  106428:	e0ffff17 	ldw	r3,-4(fp)
  10642c:	1805883a 	mov	r2,r3
  106430:	1085883a 	add	r2,r2,r2
  106434:	10c5883a 	add	r2,r2,r3
  106438:	100490ba 	slli	r2,r2,2
  10643c:	00c00074 	movhi	r3,1
  106440:	10c7883a 	add	r3,r2,r3
  106444:	1804a915 	stw	zero,4772(r3)
    alt_fd_list[fd].dev      = 0;
  106448:	e0ffff17 	ldw	r3,-4(fp)
  10644c:	1805883a 	mov	r2,r3
  106450:	1085883a 	add	r2,r2,r2
  106454:	10c5883a 	add	r2,r2,r3
  106458:	100490ba 	slli	r2,r2,2
  10645c:	00c00074 	movhi	r3,1
  106460:	10c7883a 	add	r3,r2,r3
  106464:	1804a715 	stw	zero,4764(r3)
  }
}
  106468:	0001883a 	nop
  10646c:	e037883a 	mov	sp,fp
  106470:	df000017 	ldw	fp,0(sp)
  106474:	dec00104 	addi	sp,sp,4
  106478:	f800283a 	ret

0010647c <altera_nios2_gen2_irq_init>:
/*
 * To initialize the internal interrupt controller, just clear the IENABLE
 * register so that all possible IRQs are disabled.
 */
void altera_nios2_gen2_irq_init(void) 
{
  10647c:	deffff04 	addi	sp,sp,-4
  106480:	df000015 	stw	fp,0(sp)
  106484:	d839883a 	mov	fp,sp
    NIOS2_WRITE_IENABLE(0);
  106488:	000170fa 	wrctl	ienable,zero
}
  10648c:	0001883a 	nop
  106490:	e037883a 	mov	sp,fp
  106494:	df000017 	ldw	fp,0(sp)
  106498:	dec00104 	addi	sp,sp,4
  10649c:	f800283a 	ret

001064a0 <alt_find_dev>:
 * "name" must be an exact match for the devices registered name for a match to
 * be found.
 */
 
alt_dev* alt_find_dev(const char* name, alt_llist* llist)
{
  1064a0:	defffa04 	addi	sp,sp,-24
  1064a4:	dfc00515 	stw	ra,20(sp)
  1064a8:	df000415 	stw	fp,16(sp)
  1064ac:	df000404 	addi	fp,sp,16
  1064b0:	e13ffd15 	stw	r4,-12(fp)
  1064b4:	e17ffc15 	stw	r5,-16(fp)
  alt_dev* next = (alt_dev*) llist->next;
  1064b8:	e0bffc17 	ldw	r2,-16(fp)
  1064bc:	10800017 	ldw	r2,0(r2)
  1064c0:	e0bfff15 	stw	r2,-4(fp)
  alt_32 len;

  len  = strlen(name) + 1;
  1064c4:	e13ffd17 	ldw	r4,-12(fp)
  1064c8:	01030200 	call	103020 <strlen>
  1064cc:	10800044 	addi	r2,r2,1
  1064d0:	e0bffe15 	stw	r2,-8(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
  1064d4:	00000d06 	br	10650c <alt_find_dev+0x6c>
    /* 
     * memcmp() is used here rather than strcmp() in order to reduce the size
     * of the executable.
     */

    if (!memcmp (next->name, name, len))
  1064d8:	e0bfff17 	ldw	r2,-4(fp)
  1064dc:	10800217 	ldw	r2,8(r2)
  1064e0:	e0fffe17 	ldw	r3,-8(fp)
  1064e4:	180d883a 	mov	r6,r3
  1064e8:	e17ffd17 	ldw	r5,-12(fp)
  1064ec:	1009883a 	mov	r4,r2
  1064f0:	01067a80 	call	1067a8 <memcmp>
  1064f4:	1000021e 	bne	r2,zero,106500 <alt_find_dev+0x60>
    {
      /* match found */

      return next;
  1064f8:	e0bfff17 	ldw	r2,-4(fp)
  1064fc:	00000706 	br	10651c <alt_find_dev+0x7c>
    }
    next = (alt_dev*) next->llist.next;
  106500:	e0bfff17 	ldw	r2,-4(fp)
  106504:	10800017 	ldw	r2,0(r2)
  106508:	e0bfff15 	stw	r2,-4(fp)
  while (next != (alt_dev*) llist)
  10650c:	e0ffff17 	ldw	r3,-4(fp)
  106510:	e0bffc17 	ldw	r2,-16(fp)
  106514:	18bff01e 	bne	r3,r2,1064d8 <alt_find_dev+0x38>
  }
  
  /* No match found */
  
  return NULL;
  106518:	0005883a 	mov	r2,zero
}
  10651c:	e037883a 	mov	sp,fp
  106520:	dfc00117 	ldw	ra,4(sp)
  106524:	df000017 	ldw	fp,0(sp)
  106528:	dec00204 	addi	sp,sp,8
  10652c:	f800283a 	ret

00106530 <alt_find_file>:
 * either '/' or '\0' is the prefix of the filename. For example the filename:
 * "/myfilesystem/junk.txt" would match: "/myfilesystem", but not: "/myfile". 
 */
 
alt_dev* alt_find_file (const char* name)
{
  106530:	defffb04 	addi	sp,sp,-20
  106534:	dfc00415 	stw	ra,16(sp)
  106538:	df000315 	stw	fp,12(sp)
  10653c:	df000304 	addi	fp,sp,12
  106540:	e13ffd15 	stw	r4,-12(fp)
  alt_dev* next = (alt_dev*) alt_fs_list.next;   
  106544:	d0a00d17 	ldw	r2,-32716(gp)
  106548:	e0bfff15 	stw	r2,-4(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
  10654c:	00003106 	br	106614 <alt_find_file+0xe4>
  {
    len = strlen(next->name);
  106550:	e0bfff17 	ldw	r2,-4(fp)
  106554:	10800217 	ldw	r2,8(r2)
  106558:	1009883a 	mov	r4,r2
  10655c:	01030200 	call	103020 <strlen>
  106560:	e0bffe15 	stw	r2,-8(fp)
    
    if (next->name[len-1] == '/')
  106564:	e0bfff17 	ldw	r2,-4(fp)
  106568:	10c00217 	ldw	r3,8(r2)
  10656c:	e0bffe17 	ldw	r2,-8(fp)
  106570:	10bfffc4 	addi	r2,r2,-1
  106574:	1885883a 	add	r2,r3,r2
  106578:	10800003 	ldbu	r2,0(r2)
  10657c:	10803fcc 	andi	r2,r2,255
  106580:	1080201c 	xori	r2,r2,128
  106584:	10bfe004 	addi	r2,r2,-128
  106588:	10800bd8 	cmpnei	r2,r2,47
  10658c:	1000031e 	bne	r2,zero,10659c <alt_find_file+0x6c>
    {
      len -= 1;
  106590:	e0bffe17 	ldw	r2,-8(fp)
  106594:	10bfffc4 	addi	r2,r2,-1
  106598:	e0bffe15 	stw	r2,-8(fp)
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
  10659c:	e0bffe17 	ldw	r2,-8(fp)
  1065a0:	e0fffd17 	ldw	r3,-12(fp)
  1065a4:	1885883a 	add	r2,r3,r2
  1065a8:	10800003 	ldbu	r2,0(r2)
  1065ac:	10803fcc 	andi	r2,r2,255
  1065b0:	1080201c 	xori	r2,r2,128
  1065b4:	10bfe004 	addi	r2,r2,-128
  1065b8:	10800be0 	cmpeqi	r2,r2,47
  1065bc:	1000081e 	bne	r2,zero,1065e0 <alt_find_file+0xb0>
  1065c0:	e0bffe17 	ldw	r2,-8(fp)
  1065c4:	e0fffd17 	ldw	r3,-12(fp)
  1065c8:	1885883a 	add	r2,r3,r2
  1065cc:	10800003 	ldbu	r2,0(r2)
  1065d0:	10803fcc 	andi	r2,r2,255
  1065d4:	1080201c 	xori	r2,r2,128
  1065d8:	10bfe004 	addi	r2,r2,-128
  1065dc:	10000a1e 	bne	r2,zero,106608 <alt_find_file+0xd8>
        !memcmp (next->name, name, len))
  1065e0:	e0bfff17 	ldw	r2,-4(fp)
  1065e4:	10800217 	ldw	r2,8(r2)
  1065e8:	e0fffe17 	ldw	r3,-8(fp)
  1065ec:	180d883a 	mov	r6,r3
  1065f0:	e17ffd17 	ldw	r5,-12(fp)
  1065f4:	1009883a 	mov	r4,r2
  1065f8:	01067a80 	call	1067a8 <memcmp>
    if (((name[len] == '/') || (name[len] == '\0')) && 
  1065fc:	1000021e 	bne	r2,zero,106608 <alt_find_file+0xd8>
    {
      /* match found */

      return next;
  106600:	e0bfff17 	ldw	r2,-4(fp)
  106604:	00000706 	br	106624 <alt_find_file+0xf4>
    }
    next = (alt_dev*) next->llist.next;
  106608:	e0bfff17 	ldw	r2,-4(fp)
  10660c:	10800017 	ldw	r2,0(r2)
  106610:	e0bfff15 	stw	r2,-4(fp)
  while (next != (alt_dev*) &alt_fs_list)
  106614:	e0ffff17 	ldw	r3,-4(fp)
  106618:	d0a00d04 	addi	r2,gp,-32716
  10661c:	18bfcc1e 	bne	r3,r2,106550 <alt_find_file+0x20>
  }
  
  /* No match found */
  
  return NULL;     
  106620:	0005883a 	mov	r2,zero
}
  106624:	e037883a 	mov	sp,fp
  106628:	dfc00117 	ldw	ra,4(sp)
  10662c:	df000017 	ldw	fp,0(sp)
  106630:	dec00204 	addi	sp,sp,8
  106634:	f800283a 	ret

00106638 <alt_get_fd>:
 * the offset of the file descriptor within the file descriptor array). A
 * negative value indicates failure.
 */

int alt_get_fd (alt_dev* dev)
{
  106638:	defffc04 	addi	sp,sp,-16
  10663c:	df000315 	stw	fp,12(sp)
  106640:	df000304 	addi	fp,sp,12
  106644:	e13ffd15 	stw	r4,-12(fp)
  alt_32 i;
  int rc = -EMFILE;
  106648:	00bffa04 	movi	r2,-24
  10664c:	e0bffe15 	stw	r2,-8(fp)
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
  106650:	e03fff15 	stw	zero,-4(fp)
  106654:	00001d06 	br	1066cc <alt_get_fd+0x94>
  {
    if (!alt_fd_list[i].dev)
  106658:	e0ffff17 	ldw	r3,-4(fp)
  10665c:	1805883a 	mov	r2,r3
  106660:	1085883a 	add	r2,r2,r2
  106664:	10c5883a 	add	r2,r2,r3
  106668:	100490ba 	slli	r2,r2,2
  10666c:	00c00074 	movhi	r3,1
  106670:	10c7883a 	add	r3,r2,r3
  106674:	1884a717 	ldw	r2,4764(r3)
  106678:	1000111e 	bne	r2,zero,1066c0 <alt_get_fd+0x88>
    {
      alt_fd_list[i].dev = dev;
  10667c:	e0ffff17 	ldw	r3,-4(fp)
  106680:	1805883a 	mov	r2,r3
  106684:	1085883a 	add	r2,r2,r2
  106688:	10c5883a 	add	r2,r2,r3
  10668c:	100490ba 	slli	r2,r2,2
  106690:	e13ffd17 	ldw	r4,-12(fp)
  106694:	00c00074 	movhi	r3,1
  106698:	10c7883a 	add	r3,r2,r3
  10669c:	1904a715 	stw	r4,4764(r3)
      if (i > alt_max_fd)
  1066a0:	d0e01117 	ldw	r3,-32700(gp)
  1066a4:	e0bfff17 	ldw	r2,-4(fp)
  1066a8:	1880020e 	bge	r3,r2,1066b4 <alt_get_fd+0x7c>
      {
        alt_max_fd = i;
  1066ac:	e0bfff17 	ldw	r2,-4(fp)
  1066b0:	d0a01115 	stw	r2,-32700(gp)
      }
      rc = i;
  1066b4:	e0bfff17 	ldw	r2,-4(fp)
  1066b8:	e0bffe15 	stw	r2,-8(fp)
      goto alt_get_fd_exit;
  1066bc:	00000706 	br	1066dc <alt_get_fd+0xa4>
  for (i = 0; i < ALT_MAX_FD; i++)
  1066c0:	e0bfff17 	ldw	r2,-4(fp)
  1066c4:	10800044 	addi	r2,r2,1
  1066c8:	e0bfff15 	stw	r2,-4(fp)
  1066cc:	e0bfff17 	ldw	r2,-4(fp)
  1066d0:	10800810 	cmplti	r2,r2,32
  1066d4:	103fe01e 	bne	r2,zero,106658 <alt_get_fd+0x20>
    }
  }

 alt_get_fd_exit:
  1066d8:	0001883a 	nop
   * file descriptor pool.
   */

  ALT_SEM_POST(alt_fd_list_lock);

  return rc;
  1066dc:	e0bffe17 	ldw	r2,-8(fp)
}
  1066e0:	e037883a 	mov	sp,fp
  1066e4:	df000017 	ldw	fp,0(sp)
  1066e8:	dec00104 	addi	sp,sp,4
  1066ec:	f800283a 	ret

001066f0 <alt_exception_cause_generated_bad_addr>:
 * Return: 1: BADADDR (bad_addr argument to handler) is valid
 *         0: BADADDR is not valid
 */
int 
alt_exception_cause_generated_bad_addr(alt_exception_cause cause)
{
  1066f0:	defffe04 	addi	sp,sp,-8
  1066f4:	df000115 	stw	fp,4(sp)
  1066f8:	df000104 	addi	fp,sp,4
  1066fc:	e13fff15 	stw	r4,-4(fp)
  switch (cause) {
  106700:	e0bfff17 	ldw	r2,-4(fp)
  106704:	10bffe84 	addi	r2,r2,-6
  106708:	10c00428 	cmpgeui	r3,r2,16
  10670c:	1800191e 	bne	r3,zero,106774 <alt_exception_cause_generated_bad_addr+0x84>
  106710:	100690ba 	slli	r3,r2,2
  106714:	00800434 	movhi	r2,16
  106718:	1885883a 	add	r2,r3,r2
  10671c:	1099c917 	ldw	r2,26404(r2)
  106720:	1000683a 	jmp	r2
  106724:	00106764 	muli	zero,zero,16797
  106728:	00106764 	muli	zero,zero,16797
  10672c:	00106774 	movhi	zero,16797
  106730:	00106774 	movhi	zero,16797
  106734:	00106774 	movhi	zero,16797
  106738:	00106764 	muli	zero,zero,16797
  10673c:	0010676c 	andhi	zero,zero,16797
  106740:	00106774 	movhi	zero,16797
  106744:	00106764 	muli	zero,zero,16797
  106748:	00106764 	muli	zero,zero,16797
  10674c:	00106774 	movhi	zero,16797
  106750:	00106764 	muli	zero,zero,16797
  106754:	0010676c 	andhi	zero,zero,16797
  106758:	00106774 	movhi	zero,16797
  10675c:	00106774 	movhi	zero,16797
  106760:	00106764 	muli	zero,zero,16797
  case NIOS2_EXCEPTION_MISALIGNED_TARGET_PC:
  case NIOS2_EXCEPTION_TLB_READ_PERM_VIOLATION:
  case NIOS2_EXCEPTION_TLB_WRITE_PERM_VIOLATION:
  case NIOS2_EXCEPTION_MPU_DATA_REGION_VIOLATION:
  case NIOS2_EXCEPTION_ECC_DATA_ERR:
    return 1;
  106764:	00800044 	movi	r2,1
  106768:	00000306 	br	106778 <alt_exception_cause_generated_bad_addr+0x88>

  case NIOS2_EXCEPTION_TLB_MISS:
  case NIOS2_EXCEPTION_ECC_TLB_ERR:
    return 0;
  10676c:	0005883a 	mov	r2,zero
  106770:	00000106 	br	106778 <alt_exception_cause_generated_bad_addr+0x88>

  default:
    return 0;
  106774:	0005883a 	mov	r2,zero
  }
}
  106778:	e037883a 	mov	sp,fp
  10677c:	df000017 	ldw	fp,0(sp)
  106780:	dec00104 	addi	sp,sp,4
  106784:	f800283a 	ret

00106788 <exit>:
  106788:	defffe04 	addi	sp,sp,-8
  10678c:	000b883a 	mov	r5,zero
  106790:	dc000015 	stw	r16,0(sp)
  106794:	dfc00115 	stw	ra,4(sp)
  106798:	2021883a 	mov	r16,r4
  10679c:	01067d80 	call	1067d8 <__call_exitprocs>
  1067a0:	8009883a 	mov	r4,r16
  1067a4:	01068f40 	call	1068f4 <_exit>

001067a8 <memcmp>:
  1067a8:	0007883a 	mov	r3,zero
  1067ac:	30c0021e 	bne	r6,r3,1067b8 <memcmp+0x10>
  1067b0:	0005883a 	mov	r2,zero
  1067b4:	f800283a 	ret
  1067b8:	20c5883a 	add	r2,r4,r3
  1067bc:	18c00044 	addi	r3,r3,1
  1067c0:	28cf883a 	add	r7,r5,r3
  1067c4:	10800003 	ldbu	r2,0(r2)
  1067c8:	39ffffc3 	ldbu	r7,-1(r7)
  1067cc:	11fff726 	beq	r2,r7,1067ac <memcmp+0x4>
  1067d0:	11c5c83a 	sub	r2,r2,r7
  1067d4:	f800283a 	ret

001067d8 <__call_exitprocs>:
  1067d8:	defff704 	addi	sp,sp,-36
  1067dc:	00800074 	movhi	r2,1
  1067e0:	dcc00315 	stw	r19,12(sp)
  1067e4:	14c50e17 	ldw	r19,5176(r2)
  1067e8:	dd800615 	stw	r22,24(sp)
  1067ec:	dd400515 	stw	r21,20(sp)
  1067f0:	dd000415 	stw	r20,16(sp)
  1067f4:	dfc00815 	stw	ra,32(sp)
  1067f8:	ddc00715 	stw	r23,28(sp)
  1067fc:	dc800215 	stw	r18,8(sp)
  106800:	dc400115 	stw	r17,4(sp)
  106804:	dc000015 	stw	r16,0(sp)
  106808:	202b883a 	mov	r21,r4
  10680c:	2829883a 	mov	r20,r5
  106810:	05800044 	movi	r22,1
  106814:	9c400d17 	ldw	r17,52(r19)
  106818:	88000426 	beq	r17,zero,10682c <__call_exitprocs+0x54>
  10681c:	8c802217 	ldw	r18,136(r17)
  106820:	8c000117 	ldw	r16,4(r17)
  106824:	843fffc4 	addi	r16,r16,-1
  106828:	80000b0e 	bge	r16,zero,106858 <__call_exitprocs+0x80>
  10682c:	dfc00817 	ldw	ra,32(sp)
  106830:	ddc00717 	ldw	r23,28(sp)
  106834:	dd800617 	ldw	r22,24(sp)
  106838:	dd400517 	ldw	r21,20(sp)
  10683c:	dd000417 	ldw	r20,16(sp)
  106840:	dcc00317 	ldw	r19,12(sp)
  106844:	dc800217 	ldw	r18,8(sp)
  106848:	dc400117 	ldw	r17,4(sp)
  10684c:	dc000017 	ldw	r16,0(sp)
  106850:	dec00904 	addi	sp,sp,36
  106854:	f800283a 	ret
  106858:	a0000526 	beq	r20,zero,106870 <__call_exitprocs+0x98>
  10685c:	903ff126 	beq	r18,zero,106824 <__call_exitprocs+0x4c>
  106860:	800490ba 	slli	r2,r16,2
  106864:	9085883a 	add	r2,r18,r2
  106868:	10802017 	ldw	r2,128(r2)
  10686c:	153fed1e 	bne	r2,r20,106824 <__call_exitprocs+0x4c>
  106870:	800490ba 	slli	r2,r16,2
  106874:	89000117 	ldw	r4,4(r17)
  106878:	888b883a 	add	r5,r17,r2
  10687c:	213fffc4 	addi	r4,r4,-1
  106880:	28c00217 	ldw	r3,8(r5)
  106884:	24000e1e 	bne	r4,r16,1068c0 <__call_exitprocs+0xe8>
  106888:	8c000115 	stw	r16,4(r17)
  10688c:	183fe526 	beq	r3,zero,106824 <__call_exitprocs+0x4c>
  106890:	8dc00117 	ldw	r23,4(r17)
  106894:	90000426 	beq	r18,zero,1068a8 <__call_exitprocs+0xd0>
  106898:	b408983a 	sll	r4,r22,r16
  10689c:	91404017 	ldw	r5,256(r18)
  1068a0:	214a703a 	and	r5,r4,r5
  1068a4:	2800081e 	bne	r5,zero,1068c8 <__call_exitprocs+0xf0>
  1068a8:	183ee83a 	callr	r3
  1068ac:	88800117 	ldw	r2,4(r17)
  1068b0:	15ffd81e 	bne	r2,r23,106814 <__call_exitprocs+0x3c>
  1068b4:	98800d17 	ldw	r2,52(r19)
  1068b8:	147fda26 	beq	r2,r17,106824 <__call_exitprocs+0x4c>
  1068bc:	003fd506 	br	106814 <__call_exitprocs+0x3c>
  1068c0:	28000215 	stw	zero,8(r5)
  1068c4:	003ff106 	br	10688c <__call_exitprocs+0xb4>
  1068c8:	91404117 	ldw	r5,260(r18)
  1068cc:	9085883a 	add	r2,r18,r2
  1068d0:	2148703a 	and	r4,r4,r5
  1068d4:	2000041e 	bne	r4,zero,1068e8 <__call_exitprocs+0x110>
  1068d8:	11400017 	ldw	r5,0(r2)
  1068dc:	a809883a 	mov	r4,r21
  1068e0:	183ee83a 	callr	r3
  1068e4:	003ff106 	br	1068ac <__call_exitprocs+0xd4>
  1068e8:	11000017 	ldw	r4,0(r2)
  1068ec:	183ee83a 	callr	r3
  1068f0:	003fee06 	br	1068ac <__call_exitprocs+0xd4>

001068f4 <_exit>:
 *
 * ALT_EXIT is mapped onto the _exit() system call in alt_syscall.h
 */

void ALT_EXIT (int exit_code)
{
  1068f4:	defffd04 	addi	sp,sp,-12
  1068f8:	df000215 	stw	fp,8(sp)
  1068fc:	df000204 	addi	fp,sp,8
  106900:	e13ffe15 	stw	r4,-8(fp)
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Entering _exit() function.\r\n");
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Exit code from main was %d.\r\n",exit_code);
  /* Stop all other threads */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Calling ALT_OS_STOP().\r\n");
  ALT_OS_STOP();
  106904:	0001883a 	nop
  106908:	e0bffe17 	ldw	r2,-8(fp)
  10690c:	e0bfff15 	stw	r2,-4(fp)
/*
 * Routine called on exit.
 */
static ALT_INLINE ALT_ALWAYS_INLINE void alt_sim_halt(int exit_code)
{
  register int r2 asm ("r2") = exit_code;
  106910:	e0bfff17 	ldw	r2,-4(fp)
  __asm__ volatile ("\n0:\n\taddi %0,%0, -1\n\tbgt %0,zero,0b" : : "r" (ALT_CPU_FREQ/100) ); /* Delay for >30ms */

  __asm__ volatile ("break 2" : : "r"(r2), "r"(r3) ALT_GMON_DATA );

#else /* !DEBUG_STUB */
  if (r2) {
  106914:	10000226 	beq	r2,zero,106920 <_exit+0x2c>
    ALT_SIM_FAIL();
  106918:	002af070 	cmpltui	zero,zero,43969
  10691c:	00000106 	br	106924 <_exit+0x30>
  } else {
    ALT_SIM_PASS();
  106920:	002af0b0 	cmpltui	zero,zero,43970
  ALT_SIM_HALT(exit_code);

  /* spin forever, since there's no where to go back to */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Spinning forever.\r\n");
  while (1);
  106924:	003fff06 	br	106924 <_exit+0x30>
